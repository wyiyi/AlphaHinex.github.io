<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>薅 AWS 羊毛</title>
      <link href="2021/01/17/aws-free-tier/"/>
      <url>2021/01/17/aws-free-tier/</url>
      
        <content type="html"><![CDATA[<p><a href="https://amazonaws-china.com/cn/" target="_blank" rel="noopener">AWS</a>，即 Amazon Web Services，是由 Amazon 提供的云服务。在 <a href="https://www.gartner.com/en" target="_blank" rel="noopener">Gartner</a> 新的 <a href="https://blogs.gartner.com/raj-bala/2020/09/10/gartner-publishes-the-magic-quadrant-for-cloud-infrastructure-and-platform-services-2020/?_ga=2.190865065.247882349.1610534360-616680468.1610534360" target="_blank" rel="noopener">2020 年云基础设施和平台服务 (CIPS) 魔力象限</a> 中，Gartner Research 将 AWS 定位在“领导者象限”中。在此魔力象限中，CIPS（Cloud Infrastructure and Platform Services）被定义为“标准化、高度自动化的产品，其中基础设施资源（例如计算、联网和存储）由集成式平台服务加以补充。”</p><p><img src="/contents/aws-free-tier/cips-mq.jpg" alt="Magic Quadrant for Cloud Infrastructure and Platform Services, 2020"></p><h2 id="免费套餐"><a href="#免费套餐" class="headerlink" title="免费套餐"></a>免费套餐</h2><p>作为领导者，AWS 提供的福利也是很厚道的，为每个账号都提供了免费套餐，包括试用、12 个月免费和永久免费三种类型的多种产品，详细可见：</p><ul><li><a href="https://amazonaws-china.com/cn/free" target="_blank" rel="noopener">AWS 海外区域账户免费套餐</a></li><li><a href="https://www.amazonaws.cn/free/" target="_blank" rel="noopener">AWS 中国（宁夏）区域免费套餐</a></li></ul><p>关于免费套餐的内容，官网有如下说明：</p><blockquote><p>12 个月免费：这些免费套餐产品仅适用于新 AWS 客户，在自注册 AWS 之日起 12 个月内可用。当 12 个月的免费使用期过期或您的应用程序使用量超过了免费套餐限额，您只需支付标准的按使用量付费的服务费率（请参阅每个服务页面上的完整定价详情）。存在限制条件；有关更多详细信息，请参阅优惠条款。<br>‍<br>永久免费：这些免费套餐产品在 12 个月的 AWS 免费套餐期限到期后不会自动过期，而是无期限地提供给现有的和新的 AWS 客户。<br>‍<br>试用：这些免费套餐产品是短期试用产品，始于第一次试用开始时。试用期过后，您只需支付标准的按使用量付费的服务费率（请参阅每个服务页面上的完整定价详情）。<br>‍<br>客户在全球区域中使用的套餐服务使用量，均将计入 Amazon AWS 免费套餐中。AWS 免费套餐中的免费使用量每月计算一次（所有区域）并自动应用到账单中，免费使用量不能累计。目前，我们尚未在 AWS GovCloud（美国）区域和中国（北京）区域提供 AWS 免费套餐。</p></blockquote><p><strong>即，免费使用不假，但是是有 <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/free-tier-limits.html" target="_blank" rel="noopener">限额</a> 的，超过限额是仍然要付费的，别问我怎么知道的。</strong></p><h2 id="怎么薅"><a href="#怎么薅" class="headerlink" title="怎么薅"></a>怎么薅</h2><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>到 <a href="https://amazonaws-china.com/cn/" target="_blank" rel="noopener">AWS</a> <code>创建 AWS 账户</code>，注册过程中需要填写银行卡信息，可以使用信用卡，注册后会产生 1 美元的预授权交易。完成注册信息填写后，需要等待服务激活，官方说法 <code>您的服务可能需要24小时才能完全激活</code>。进度会通过注册邮箱进行通知。</p><p>服务激活后，即可选择开通免费套餐中的服务了。</p><blockquote><p>免费套餐是为每个账号提供的，账号通过邮箱注册，注册信息中，手机号、银行卡号等信息，可以重复使用，只要邮箱不同即可，这意味着。。。</p></blockquote><h3 id="开通服务"><a href="#开通服务" class="headerlink" title="开通服务"></a>开通服务</h3><p>以开通 EC2 服务为例，EC2 是 AWS 的 <code>Virtual Servers in the Cloud</code>。</p><p>先在 <code>AWS 管理控制台</code> 中选择区域，如 <code>亚太地区 (东京)ap-northeast-1</code>，然后在 <code>Services</code> 中选择 <code>EC2</code>，在东京开通一台 EC2 服务。</p><p>点击 <code>启动实例</code>，选择系统镜像，勾选 <code>仅免费套餐</code>，选择一个符合条件的镜像，如 <code>Amazon Linux 2 AMI (HVM), SSD Volume Type</code>。之后选择符合免费套餐条件的实例类型 <code>t2.micro</code>。配置安全组时，可以开放一些端口供后续使用，也可以在需要时再进行设置。</p><p>完成设置准备启动时，会提示 <code>选择现有密钥对或创建新密钥对</code>，创建一个新密钥对，并下载私钥文件后，即可启动实例。</p><blockquote><p>注意过程中的提示：您必须下载私有密钥文件(*.pem 文件)才能继续操作。请将其存储在安全且易于访问的位置。您无法在创建文件后再次下载此文件。</p></blockquote><p>实例启动成功后，可至实例信息界面，点击 <code>连接</code>，选择 <code>EC2 Instance Connect</code>、<code>会话管理器</code>、<code>SSH 客户端</code> 方式连接至 EC2 实例。</p><h3 id="限额"><a href="#限额" class="headerlink" title="限额"></a>限额</h3><p>羊毛虽好，但不要无节制的薅。</p><p>免费套餐是有时限和限额的。</p><ul><li>12 个月免费是指 <strong>从注册之日</strong> 起 12 个月内</li><li>还要注意服务用量的叠加，如 EC2 服务 12 个月内免费，但每月免费时长是 750 小时，所以在免费套餐内，可以连续使用一个 Linux 实例一个月，或者使用十个 Linux 实例，每个每月 75 小时</li></ul><p>用量接近限额时，会收到邮件提醒，一定要注意免费套餐的限额，否则会收费。</p><p>另外 EC2 服务会带有一个外网 IP，即使时限没超过用量，带宽超过也是会收费的，如：</p><table><thead><tr><th align="left">Bandwidth</th><th align="left"></th><th align="left">$0.15</th></tr></thead><tbody><tr><td align="left">$0.000 per GB - data transfer in per month</td><td align="left">16.818 GB</td><td align="left">$0.00</td></tr><tr><td align="left">$0.000 per GB - data transfer out under the monthly global free tier</td><td align="left">15.000 GB</td><td align="left">$0.00</td></tr><tr><td align="left">$0.000 per GB - regional data transfer under the monthly global free tier</td><td align="left">0.007 GB</td><td align="left">$0.00</td></tr><tr><td align="left">$0.114 per GB - first 10 TB / month data transfer out beyond the global free tier</td><td align="left">1.299 GB</td><td align="left">$0.15</td></tr></tbody></table><h3 id="套餐到期"><a href="#套餐到期" class="headerlink" title="套餐到期"></a>套餐到期</h3><p>12 个月的免费套餐到期时，开通的服务不会自动停止。服务继续运行将会产生费用。如不再使用，需手动停止服务。</p><p>以 EC2 服务为例，选择对应实例，停止或终止实例即可。停止后可再次启动实例，终止后则不能。</p><blockquote><p>注意：停止或终止实例均会导致 IP 发生变化。重启实例不会改变 IP。</p></blockquote><blockquote><p>可通过控制台查询公网 IP 地址，也可以在主机中通过 <code>curl http://169.254.169.254/latest/meta-data/public-ipv4</code> 进行查询。</p></blockquote><p>另外，12个月免费期不是指 365 天，具体过期时间，可以收到的到期提醒邮件为准。</p>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GFW </tag>
            
            <tag> Cloud </tag>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS 制作 USB 启动盘</title>
      <link href="2021/01/10/mac-create-bootable-usb-stick/"/>
      <url>2021/01/10/mac-create-bootable-usb-stick/</url>
      
        <content type="html"><![CDATA[<p>安装操作系统时，当前常用的方式是获取操作系统对应的 ISO 文件，并制作 U 盘启动盘，使用 U 盘引导系统进行安装。</p><p>当使用 MacOS 时，可以很方便的利用系统自带工具，完成上述工作，具体步骤如下。</p><h2 id="获得操作系统镜像"><a href="#获得操作系统镜像" class="headerlink" title="获得操作系统镜像"></a>获得操作系统镜像</h2><p>推荐从官方进行下载，如：</p><ul><li><a href="https://www.microsoft.com/zh-cn/software-download/windows10ISO" target="_blank" rel="noopener">Windows 10</a></li><li><a href="https://ubuntu.com/#download" target="_blank" rel="noopener">Ubuntu</a></li><li><a href="https://www.centos.org/download/" target="_blank" rel="noopener">CentOS</a></li></ul><p>下载到的文件名如 <code>Win10_20H2_v2_Chinese(Simplified)_x64.iso</code>、<code>ubuntu-20.04.1-desktop-amd64.iso</code>、<code>CentOS-7-x86_64-DVD-2003.iso</code> 等。</p><h2 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h2><pre><code class="bash"># 使用 diskutil 查看 U 盘设备 ID$ diskutil list.../dev/disk2 (external, physical):   #:                       TYPE NAME                    SIZE       IDENTIFIER   0:                                                   *15.5 GB    disk2...# 取消 U 盘挂载，否则在后续操作中可能会提示资源忙，无法进行启动盘制作# 注意使用上面查询到的设备 ID，本例中为 /dev/disk2，一定注意不要写错$ diskutil unmountDisk /dev/disk2Unmount of all volumes on disk2 was successful# 使用 dd 将操作系统镜像写入 U 盘# if=file 代表要写入的源文件路径# of=file 代表要写入的目标文件，此处为代表 U 盘的设备 ID，但注意，命令中使用的是 rdisk2 而不是 disk2，也可以使用 disk2，区别稍后再讲# bs=n 代表同时设置输入输出的块大小，n 代表字节数，默认为 512，可以使用 b/k/m/g 等字母后缀代表不同的单位，如下面命令代表每个块大小为 1048576(1m) 字节# 写入时间较长，过程中没有任何输出，最终成功结束时会输出统计信息$ sudo dd if=/Users/alphahinex/Downloads/CentOS-7-x86_64-Minimal-2003.iso of=/dev/rdisk2 bs=1m1035+0 records in1035+0 records out1085276160 bytes transferred in 415.019150 secs (2615003 bytes/sec)</code></pre><p>写入完成后，会弹出 <code>此电脑不能读取您插入的磁盘。</code> 的提示，直接点 <code>忽略</code> 或 <code>推出</code> 即可，不要点 <code>初始化...</code>。</p><p>也可以使用 <code>diskutil</code> 将 U 盘弹出：</p><pre><code class="bash">$ diskutil eject /dev/disk2Disk /dev/disk2 ejected</code></pre><p>制作好的启动盘，在 Mac 或 Windows 上都无法查看其中内容，但并不影响使用。</p><h3 id="dev-rdisk"><a href="#dev-rdisk" class="headerlink" title="/dev/rdisk"></a>/dev/rdisk</h3><p>通过 <code>diskutil</code> 我们查询到的 U 盘设备路径为 <code>/dev/disk2</code>，在使用 <code>dd</code> 的时候为什么要使用 <code>/dev/rdisk2</code> 呢？</p><p>在 <a href="https://elinux.org/RPi_Easy_SD_Card_Setup" target="_blank" rel="noopener">RPi Easy SD Card Setup</a> 中，提到了在 Mac OS 中 <code>/dev/disk</code> 和 <code>/dev/rdisk</code> 的区别：</p><blockquote><p>Note: In OS X each disk may have two path references in /dev:</p><ul><li>/dev/disk# is a buffered device, which means any data being sent undergoes extra processing.</li><li>/dev/rdisk# is a raw path, which is much faster, and perfectly OK when using the dd program.</li></ul><p>On a Class 4 SD card the difference was around 20 times faster using the rdisk path.</p></blockquote><p>Mac 自带的 <code>hdiutil</code> 工具的使用手册中也有相关描述：</p><pre><code class="term">$ man hdiutil...DEVICE SPECIAL FILES     Since any /dev entry can be treated as a raw disk image, it is worth noting which devices can be accessed when and how.  /dev/rdisk nodes are character-special devices, but are     &quot;raw&quot; in the BSD sense and force block-aligned I/O.  They are closer to the physical disk than the buffer cache.  /dev/disk nodes, on the other hand, are buffered block-special     devices and are used primarily by the kernel&#39;s filesystem code.     It is not possible to read from a /dev/disk node while a filesystem is mounted from it, but anyone with read access to the appropriate /dev/rdisk node can use hdiutil verbs     such as fsid or pmap with it.  Beware that information read from a raw device while a filesystem is mounted may not be consistent because the consistent data is stored in mem-     ory or in the filesystem&#39;s journal.     The DiskImages framework will attempt to use authopen(1) to open any device which it can&#39;t open (due to EACCES) for reading with open(2).  Depending on session characteristics,     this behavior can cause apparent hangs while trying to access /dev entries while logged in remotely (an authorization panel is waiting on console).     Generally, the /dev/disk node is preferred for imaging devices (e.g.  convert or create -srcdevice operations), while /dev/rdisk is usable for the quick pmap or fsid.  In par-     ticular, converting the blocks of a mounted journaled filesystem to a read-only image will prevent the volume in the image from mounting (the journal will be permanently     dirty)....</code></pre><p>总结一下，就是在制作启动盘时使用 <code>/dev/rdisk#</code> 会比 <code>/dev/disk#</code> 速度更快。</p><p>使用数据验证一下：</p><pre><code class="bash">$ sudo dd if=/Users/alphahinex/Downloads/CentOS-7-x86_64-Minimal-2003.iso of=/dev/rdisk2 bs=1m1035+0 records in1035+0 records out1085276160 bytes transferred in 415.019150 secs (2615003 bytes/sec)$ sudo dd if=/Users/alphahinex/Downloads/CentOS-7-x86_64-Minimal-2003.iso of=/dev/disk2 bs=1m1035+0 records in1035+0 records out1085276160 bytes transferred in 771.201933 secs (1407253 bytes/sec)</code></pre><p>虽然效果并不拔群，但也确实快了近一倍。</p><blockquote><p><code>dd</code> 过程中，可以通过 <code>iostat</code> 命令查看磁盘状态，如 <code>iostat -c 1000 disk2</code></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/0abdd301e0d6" target="_blank" rel="noopener">Mac 制作 Ubuntu 18.04 启动盘</a></li><li><a href="https://superuser.com/questions/631592/why-is-dev-rdisk-about-20-times-faster-than-dev-disk-in-mac-os-x/1346063#1346063" target="_blank" rel="noopener">Why is “/dev/rdisk” about 20 times faster than “/dev/disk” in Mac OS X</a></li><li><a href="https://elinux.org/RPi_Easy_SD_Card_Setup" target="_blank" rel="noopener">RPi Easy SD Card Setup</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员对程序员的承诺</title>
      <link href="2021/01/03/promise-of-programmer-to-programmer/"/>
      <url>2021/01/03/promise-of-programmer-to-programmer/</url>
      
        <content type="html"><![CDATA[<p>开公众号至今已达到了一年，每周发一篇文章也坚持了一年，不容易，但成年人的世界，没有容易二字。</p><p>过去几年立了一些 flag：</p><ol><li>每天在 GitHub 上有 contribution</li><li>每两个月读一本书并进行分享</li><li>每周写一篇博客并发公众号</li></ol><p>虽然新的 flag 会接替之前的 flag 填充满主要的时间，但坚持做这些事的初衷都没有变：不断的改变自己，并尽可能的给他人带来积极的影响。</p><p>静态网站访问统计脚本 <a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a> 作者的 <a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">一段话</a> 让我很有感触：</p><blockquote><p>静态网站建站现在有很多快速的技术和平台，但静态是优点也有缺点，由于是静态的，一些动态的内容如评论、计数等等模块就需要借助外来平台，评论有“多说”，计数有“不蒜”！（多说即将关闭，不蒜子还活着涅，这是程序员对程序员的承诺。）</p></blockquote><p>作为一个需要持久化的对外服务，是一定需要作者为此付出成本的，无论是开发维护的成本，还是持久化所需的费用。但这个服务对任何人来讲（主要用户还是程序员）都是可以直接使用的，这就是 <strong>程序员对程序员的承诺</strong> 。</p><p>不同于 Google Photos 的无限空间永久免费之类的宣传语，这个承诺非常有分量，尤其是对程序员来讲，因为这是一个没有利益纠葛的契约，是一个程序员心中坚定的信念。</p><p><a href="https://mp.weixin.qq.com/s/3Y92JnbRZHCpZ-8XX-j9TA" target="_blank" rel="noopener">在中国，先定目标，再拆任务，是一个更靠谱的途径。</a> 罗振宇2021“时间的朋友”跨年演讲中如是说，我深以为然。</p><p>有了目标，有了承诺，一切借口也就失去了存在的意义。</p><p>2021，输出更优质的内容，打造更好的自己，影响更多的人，这是程序员对程序员的承诺。</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Override same class</title>
      <link href="2020/12/27/override-same-class/"/>
      <url>2020/12/27/override-same-class/</url>
      
        <content type="html"><![CDATA[<p>实际 Java Web 项目中经常会遇到这样的场景：希望对依赖的某个三方库中的行为进行覆盖式的定制（修改三方库中的某些行为），但并不希望发布定制的版本至私服。</p><p>通常在使用 WAR 包发布应用时，可将定制的类编译成 class 文件，放入 <code>WEB-INF/classes</code> 路径中，即可覆盖放置在 <code>WEB-INF/lib</code> 路径下的三方库中同名类，达到定制的目的。</p><p>那么为什么可以这样？</p><p>在两个相同的 class 必须都存在于 JAR 包中时，又怎么实现这种需求呢？</p><h2 id="为什么可以这样？"><a href="#为什么可以这样？" class="headerlink" title="为什么可以这样？"></a>为什么可以这样？</h2><h3 id="Servlet-规范"><a href="#Servlet-规范" class="headerlink" title="Servlet 规范"></a>Servlet 规范</h3><p>在 <a href="https://download.oracle.com/otndocs/jcp/servlet-2.4-fr-spec-oth-JSpec/" target="_blank" rel="noopener">Java(TM) Servlet Specification 2.4 Final Release</a> 中 SRV.9.5 Directory Structure 有如下要求：</p><blockquote><p>The Web application class loader must load classes from the WEB-INF/ classes<br>directory first, and then from library JARs in the WEB-INF/lib directory. Also, any<br>requests from the client to access the resources in WEB-INF/ directory must be<br>returned with a SC_NOT_FOUND(404) response.</p></blockquote><p>规定了 Web 应用的 Class Loader 必须先从 <code>WEB-INF/classes</code> 目录加载类文件，之后才能从 <code>WEB-INF/lib</code> 路径加载 JAR 文件。</p><h3 id="Web-Application-Class-Loader"><a href="#Web-Application-Class-Loader" class="headerlink" title="Web Application Class Loader"></a>Web Application Class Loader</h3><p>在 SRV.9.7.2 Web Application Class Loader 中有如下建议：</p><blockquote><p>It is recommended also that the application class loader be implemented so<br>that classes and resources packaged within the WAR are loaded in preference to<br>classes and resources residing in container-wide library JARs.</p></blockquote><p>建议 WAR 包中的 class 优先于 JAR 包中的 class 进行加载。</p><h3 id="Tomcat-Class-Loader"><a href="#Tomcat-Class-Loader" class="headerlink" title="Tomcat Class Loader"></a>Tomcat Class Loader</h3><p><a href="http://tomcat.apache.org/tomcat-8.0-doc/class-loader-howto.html" target="_blank" rel="noopener">Apache Tomcat 8 Class Loader HOW-TO</a> 中，描述了 Tomcat 初始化时创建的 Class Loader：</p><pre><code class="text">    Bootstrap        |     System        |     Common     /     \Webapp1   Webapp2 ...</code></pre><blockquote><p>Therefore, from the perspective of a web application, class or resource loading looks in the following repositories, in this order:</p><ul><li>Bootstrap classes of your JVM</li><li>/WEB-INF/classes of your web application</li><li>/WEB-INF/lib/*.jar of your web application</li><li>System class loader classes (described above)</li><li>Common class loader classes (described above)</li></ul><p>If the web application class loader is configured with <code>&lt;Loader delegate=&quot;true&quot;/&gt;</code> then the order becomes:</p><ul><li>Bootstrap classes of your JVM</li><li>System class loader classes (described above)</li><li>Common class loader classes (described above)</li><li>/WEB-INF/classes of your web application</li><li>/WEB-INF/lib/*.jar of your web application</li></ul></blockquote><p>Servlet 规范中的要求及推荐，以及 Tomcat 的具体实现，保证了 <code>/WEB-INF/classes</code> 优先于 <code>WEB-INF/lib</code> 进行加载，那么为什么优先加载就能实现覆盖呢？</p><h3 id="Class-Loader"><a href="#Class-Loader" class="headerlink" title="Class Loader"></a>Class Loader</h3><p>这就要提到 JVM 的类加载机制了。详细内容可查阅 <a href="class-loader">The Class Loader and Class File Verifier</a> 等资料，简单概括如下。</p><p>JVM 中的 Class Loader 可以分为两类：</p><ol><li>根 Class Loader，使用 C 或者其他编写 JVM 的语言编写，内置在 JVM 中，作为 JVM 的一部分，负责加载受信的类。这类 Class Loader 有且只有一个。</li><li>JVM 上的应用可以自由的继承 <code>java.lang.ClassLoader</code> 抽象类，构造定制的 Class Loader，负责从各种不同的源加载类。这类 Class Loader 不是 JVM 的一部分，使用 JAVA 编写。这类 Class Loader 可以没有或者有很多。</li></ol><p>类不是在初始化阶段全部加载好的，而是在需要使用的时候才去加载的。</p><p>一个 Class Loader 在加载一个类的时候，同时负责加载这个类所依赖的其他类。每个 Class Loader 负责从指定的来源加载类，但并不能限定每个类只引用同一来源的类。</p><p>比如自定义的类 A 需要使用 <code>java.lang.String</code> 类。类 A 由自定义的 AClassLoader 负责加载，则 AClassLoader 也负责加载 String 类。在加载 String 类时，AClassLoader 可以自行进行加载，但这是没有必要的，因为根 Class Loader 知道如何加载受信包下的类。</p><p>在 java.lang.ClassLoader 抽象类中，默认的加载类（loadClass）的方式为：如果已加载的类中没有这个类，则递归调用 parent Class Loader 的 loadClass 方法进行加载，只有当所有的父加载器都无法完成此类的加载时，才在当前 Class Loader 中尝试加载。</p><p>以上即为所谓的类加载器委派模型（Class Loader Delegation Model），即每个（第二类 Class Loader）类加载器接到加载类的任务时，都先将加载任务委派给父加载器。</p><p><a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/lang/ClassLoader.java#L563" target="_blank" rel="noopener">ClassLoader.loadClass</a> openjdk 中的代码实现如下：</p><pre><code class="JAVA">protected Class&lt;?&gt; loadClass(String name, boolean resolve)    throws ClassNotFoundException{    synchronized (getClassLoadingLock(name)) {        // First, check if the class has already been loaded        Class&lt;?&gt; c = findLoadedClass(name);        if (c == null) {            long t0 = System.nanoTime();            try {                if (parent != null) {                    c = parent.loadClass(name, false);                } else {                    c = findBootstrapClassOrNull(name);                }            } catch (ClassNotFoundException e) {                // ClassNotFoundException thrown if class not found                // from the non-null parent class loader            }            if (c == null) {                // If still not found, then invoke findClass in order                // to find the class.                long t1 = System.nanoTime();                c = findClass(name);                // this is the defining class loader; record the stats                PerfCounter.getParentDelegationTime().addTime(t1 - t0);                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                PerfCounter.getFindClasses().increment();            }        }        if (resolve) {            resolveClass(c);        }        return c;    }}</code></pre><p>规范要求类加载器先从 <code>WEB-INF/classes</code> 中加载 class，所以当一个在 <code>WEB-INF/classes</code> 路径下的类被加载了之后，就不会再从 <code>WEB-INF/lib</code> 的 JAR 包中加载相同的类了。</p><h2 id="两个相同的-class-都存在于-JAR-包中时怎么办？"><a href="#两个相同的-class-都存在于-JAR-包中时怎么办？" class="headerlink" title="两个相同的 class 都存在于 JAR 包中时怎么办？"></a>两个相同的 class 都存在于 JAR 包中时怎么办？</h2><p>那么假如 <code>WEB-INF/lib</code> 路径下不同的两个 JAR 包中包含两个相同的类（包名、类名完全相同）时，类加载器会选择加载哪个呢？</p><p>Servlet 规范中，对此并没有明确的要求，所以这种情况下的类加载顺序，可能会在不同的场景（比如操作系统）下有不同的行为。</p><h3 id="How-Tomcat-load-jarfiles-in-WEB-INF-lib？"><a href="#How-Tomcat-load-jarfiles-in-WEB-INF-lib？" class="headerlink" title="How Tomcat load jarfiles in WEB-INF/lib？"></a>How Tomcat load jarfiles in WEB-INF/lib？</h3><p>Tomcat 中是按什么顺序加载 <code>WEB-INF/lib</code> 路径下的 JAR 包的呢？</p><p>从 <a href="(https://stackoverflow.com/questions/5474765/order-of-loading-jar-files-from-lib-directory)">Order of loading jar files from lib directory</a> 的问答中可以看到，在 Tomcat 8.x 之前，是按照字母序顺序进行加载的。但从 8.x 开始，Tomcat 不再人为的增加这种排序，而是把这个顺序交给了具体的操作系统的实现。</p><p>从 <a href="(https://bz.apache.org/bugzilla/show_bug.cgi?id=57129)">Regression. Load WEB-INF/lib jarfiles in alphabetical order</a> 邮件列表的讨论中，可以看到，关于这个问题的争论，从 2014 年开始，一直持续到了 2020 年 9 月份，并且仍然没有一个结论，所以 Tomcat 8.x 之后的版本，依然不能认为 JAR 包名字字母序排序在前的 JAR 一定会被优先加载。</p><p>PS. 感兴趣的童鞋可以围观一下上面的邮件列表，里面的讨论不乏言辞激烈的针锋相对，但依旧没有使决策者因为妥协而改变，而是必须要有充足的理由才能做出决定。虽然按序加载 JAR 包会带来一定的好处，但个人也是倾向于不要依赖这种顺序。</p><h3 id="Work-around"><a href="#Work-around" class="headerlink" title="Work around"></a>Work around</h3><p>那么有没有其他的变通方法来解决这种情况下的这个特定的问题呢？有，从 JAR 包里去掉一个重复的类，保证只有想要加载的类存在于所有 JAR 包中。</p><p>如果这两个有相同类的 JAR 包都没有源码，只能通过 Maven 依赖到项目中的时候怎么办呢？</p><p>可以借助持续集成工具，在构建最终的发布包时，通过脚本等方式，对 JAR 包进行拆包、去重及重新打包，以达到目标。</p>]]></content>
      
      
      <categories>
          
          <category> Servlet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> Java </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TeamCity Kotlin DSL</title>
      <link href="2020/12/20/teamcity-kotlin-dsl/"/>
      <url>2020/12/20/teamcity-kotlin-dsl/</url>
      
        <content type="html"><![CDATA[<p>将持续集成环境的配置代码化（Configuration as code）有很多好处：</p><ol><li>可借助版本控制系统（VCS）对配置进行管理</li><li>很容易对配置变更进行审查（review）</li><li>提高配置的可移植性</li><li>不同的分支可以执行不同的构建，甚至是未合并的请求分支以及历史构建</li></ol><p>目前常见的持续集成服务都提供（甚至仅有）代码化配置方式，如：</p><ol><li><a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 的 <code>.travis.yml</code></li><li><a href="https://github.com/features/actions" target="_blank" rel="noopener">GitHub Actions</a> 的放在代码仓库 <code>.github/workflows</code> 路径下的 <a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions" target="_blank" rel="noopener">workflow yml 文件</a></li><li><a href="https://docs.gitlab.com/ee/ci/README.html" target="_blank" rel="noopener">GitLab CI/CD</a> 的 <code>.gitlab-ci.yml</code></li><li><a href="https://www.jenkins.io/" target="_blank" rel="noopener">Jenkins</a> 的 <a href="https://www.jenkins.io/doc/book/pipeline/jenkinsfile/" target="_blank" rel="noopener">Jenkinsfile</a></li><li><a href="https://www.jetbrains.com/teamcity/" target="_blank" rel="noopener">TeamCity</a> 的 <a href="https://www.jetbrains.com/help/teamcity/storing-project-settings-in-version-control.html" target="_blank" rel="noopener">Kotlin DSL 及 XML 格式配置</a></li></ol><p>TeamCity 从 10.0 版本起，<a href="https://confluence.jetbrains.com/display/TCD10/What%27s+New+in+TeamCity+10.0#What' target="_blank" rel="noopener"sNewinTeamCity10.0-DSLforTeamCityProjectConfiguration">引入了通过 Kotlin DSL 的方式定义构建配置</a>，并且在 <a href="https://confluence.jetbrains.com/display/TCD18/What%27s+New+in+TeamCity+2018.1#What' target="_blank" rel="noopener"sNewinTeamCity2018.1-PortableKotlinDSLformat">2018.x</a> 版本进行了较大改进。</p><p>之前也多次尝试过使用 Kotlin DSL，但体验上总是差一点未能下定决心切换。在 Everything as Code 的强大执念下，使用当前最新的 <a href="https://www.jetbrains.com/help/teamcity/2020.2/what-s-new-in-teamcity.html" target="_blank" rel="noopener">TeamCity 2020.2</a> 版本再次踏上了体验之旅。</p><h2 id="将已有配置转换为-Kotlin-DSL"><a href="#将已有配置转换为-Kotlin-DSL" class="headerlink" title="将已有配置转换为 Kotlin DSL"></a>将已有配置转换为 Kotlin DSL</h2><p>为帮助已有项目切换至 DSL，TeamCity 针对 build configuration 提供了 <code>View DSL</code> 按钮，即时查看当前配置对应的 kotlin 代码。</p><p>启用 DSL 作为构建配置时，需要在 project 的编辑界面的 <code>Versioned Settings</code> 中进行手动启用。</p><p><img src="/contents/teamcity-kotlin-dsl/versioned-settings.png" alt="Versioned Settings"></p><p>Settings format 有 xml 和 Kotlin 两种类型。点击 <code>Apply</code> 按钮完成切换。</p><p><strong>注意：在启用 <code>Versioned Settings</code> 后，TeamCity 会创建 <code>.teamcity</code> 目录，以及对应配置文件，并立刻 commit/push 到对应的代码仓库中！</strong></p><p>生成的配置文件，即 <a href="https://www.jetbrains.com/help/teamcity/2020.2/kotlin-dsl.html#KotlinDSL-portableDSL" target="_blank" rel="noopener">portable DSL scripts</a>，主要有如下两个：</p><ul><li><code>settings.kts</code> – 主 DSL 脚本，包含整个 project 的配置</li><li><code>pom.xml</code> – 使 <code>.teamcity</code> 文件夹可以按 Maven Project 形式被 IDE 打开，以便获得自动补全、编译以及编写单元测试等能力。<strong>此文件对 TeamCity Server 来讲是非必须的，仅用来帮助进行 DSL 开发</strong>。</li></ul><blockquote><p>通常情况下，<code>.teamcity</code> 中应该仅包括上面两个文件。但若项目中配置了一些附加内容（如使用自定义的 Maven <code>settings.xml</code>），在自动提交的文件中也会有所体现，以便可以进行整个 project 的移植。</p></blockquote><p>另外，为方便在 DSL 较复杂的场景进行配置拆分，可以保持 <code>settings.kts</code> 这个 Kotlin Script 文件作为主入口，将部分配置拆分到 Kotlin（.kt）文件中，再被 kts 文件引用。</p><p>在启用了 DSL，且未使用 Context Parameters 时，是允许通过 UI 及 DSL 两种方式对配置进行调整的。</p><p>如果 DSL 在由 TeamCity 生成并提交后未做过任何手动调整，通过 Web 界面做出的修改将直接更新代码库中的 DSL。</p><p>但如果手动修改过 DSL ，之后再通过 UI 做出的任何配置变更，都将以 <a href="https://www.jetbrains.com/help/teamcity/kotlin-dsl.html#Editing+Project+Settings+via+Web+UI" target="_blank" rel="noopener">patch</a> 的形式被提交到代码库中，此时需要手动将 patch 中的内容合并到 <code>settings.kts</code> 或 <code>.kt</code> 文件中，并将 <code>patches</code> 路径清理掉。</p><h2 id="Use-settings-from-VCS"><a href="#Use-settings-from-VCS" class="headerlink" title="Use settings from VCS"></a>Use settings from VCS</h2><p>在 <code>Versioned Settings</code> 的 <a href="https://www.jetbrains.com/help/teamcity/2020.2/storing-project-settings-in-version-control.html#Defining+Settings+to+Apply+to+Builds" target="_blank" rel="noopener">Configuration</a> 中，建议选择 <code>use settings from VCS</code>，这样做的好处是不同的分支可以执行不同的构建，甚至是未合并的请求分支以及历史构建，因为构建执行时会使用对应版本的代码库中的 DSL。</p><h2 id="在-DSL-中使用密文"><a href="#在-DSL-中使用密文" class="headerlink" title="在 DSL 中使用密文"></a>在 DSL 中使用密文</h2><p>在 Kotlin DSL 中，有两种方式处理密文：</p><ol><li>Context Parameters</li><li>Tokens</li></ol><p><img src="/contents/teamcity-kotlin-dsl/context-parameters.png" alt="Context Parameters"></p><blockquote><p>注意：在 project 配置页的 Parameters 中配置的三类参数，都会以明文形式体现到 DSL 中！</p></blockquote><p><img src="/contents/teamcity-kotlin-dsl/parameters.png" alt="Parameters"></p><h3 id="Context-Parameters"><a href="#Context-Parameters" class="headerlink" title="Context Parameters"></a>Context Parameters</h3><p>使用 Context Parameters 可以避免 DSL 出现密码等敏感信息，因为 DSL 是要提交到代码库的。</p><p>在 DSL 中引用 Context Parameters 时，可使用 <code>DslContext.getParameter(&quot;key&quot;)</code> 的方式。</p><p>在 TeamCity Server 中能看到设置的 Context Parameters 的 Name 和 Value 内容，并且可修改及删除。</p><p>当使用了 Context Parameters 后，通过 UI 编辑 DSL 的功能自动被禁用。</p><h3 id="Tokens"><a href="#Tokens" class="headerlink" title="Tokens"></a>Tokens</h3><p>在 TeamCity 中可为敏感信息生成一个 Token，会得到一个类似 <code>credentialsJSON:254e505a-697d-4962-9ba3-c90a3dab6c6e</code> 的 Token 字符串。使用时可参照 <a href="https://www.jetbrains.com/help/teamcity/2020.2/kotlin-dsl.html#Working+with+secure+values+in+DSL" target="_blank" rel="noopener">Working with secure values in DSL</a> 中描述，将 Token 字符串直接填入 DSL 中需要密文的位置。</p><p><strong>注意：仅填写时能看到明文，一旦生成 token 就只能引用，不能查看明文或进行修改，也不能删除，即使未被引用。</strong></p><h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><p>使用 DSL 的优势之一就是使配置可以被同一个 CI Server 的不同 project 或在不同 Server 中使用，即可移植性。</p><p>按照 <a href="https://www.jetbrains.com/help/teamcity/2020.2/kotlin-dsl.html#Sharing+Kotlin+DSL+Scripts" target="_blank" rel="noopener">官方文档</a> 的说法，如果代码仓库中包含合法 DSL，可以很容易的使用 <a href="https://www.jetbrains.com/help/teamcity/2020.2/creating-and-editing-projects.html" target="_blank" rel="noopener">Create Project From URL</a> 方式，基于 DSL 新建一个 project。</p><p><img src="/contents/teamcity-kotlin-dsl/import-scan-kts.png" alt="Import DSL"></p><p>但实际使用中发现，如果代码仓库的 master 分支中不包含 DSL，即使默认分支（比如 develop）中有 DSL，在使用上述方式创建 project 的时候，也不能自动检测到配置。</p><p>在这种情况下，可以先创建 project，之后在 VCS Root 中指定包含 DSL 的分支作为 Default branch，再到 <code>Versioned Settings</code> 中启用 DSL，点击 Apply 后，即可检测到原有配置。</p><p><img src="/contents/teamcity-kotlin-dsl/detect-kts.png" alt="Detect DSL"></p><h2 id="使用-IDE-编辑-DSL"><a href="#使用-IDE-编辑-DSL" class="headerlink" title="使用 IDE 编辑 DSL"></a>使用 IDE 编辑 DSL</h2><p>不同于 <a href="https://yaml.org/" target="_blank" rel="noopener">YAML</a> 格式的配置文件，TeamCity 的 DSL 基于 <a href="https://kotlinlang.org/" target="_blank" rel="noopener">Kotlin</a>，复用代码、动态创建配置、自动补全及代码导航等，真真正正的 Configuration as Code。</p><p>如何在 IDE 里做到这些呢？借助自动生成的 <code>pom.xml</code>，你可以将 <code>.teamcity</code> 路径，作为一个独立的 Maven 工程，引入到 IDE 中。</p><p>注意因为一些依赖是由 TeamCity Server 提供的（如：<a href="http://localhost:8111/app/dsl-plugins-repository），导入" target="_blank" rel="noopener">http://localhost:8111/app/dsl-plugins-repository），导入</a> IDE 的时候需要能够连接到持续集成服务。</p><h3 id="简化相同内容配置"><a href="#简化相同内容配置" class="headerlink" title="简化相同内容配置"></a>简化相同内容配置</h3><p>DRY（<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself）" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Don%27t_repeat_yourself）</a> 在编程时是一个重要的原则，编写 Kotlin DSL 时，我们可以借助编程思想来解决这个问题。</p><p>比如在每一个构建（buildType）中，我们都希望加入一个 feature（<em>Build Files Cleaner</em>，AKA <em>Swabra</em>），违反 DRY 原则的做法是在每个 buildType 中都增加如下内容：</p><pre><code class="kotlin">features {   swabra {   }}</code></pre><p>可以定义一个 function，将需要添加这个 feature 的 buildType 包起来，实现简化配置的目的：</p><pre><code class="kotlin">fun cleanFiles(buildType: BuildType): BuildType {   buildType.features {       swabra {}   }   return buildType}</code></pre><p>在使用时：</p><pre><code class="kotlin">buildType(cleanFiles(Build))buildType(cleanFiles(AnotherBuild))buildType(cleanFiles(OneMoreBuild))</code></pre><h2 id="TeamCity-Configuration-as-Code-Roadmap"><a href="#TeamCity-Configuration-as-Code-Roadmap" class="headerlink" title="TeamCity Configuration as Code Roadmap"></a><a href="https://www.jetbrains.com/teamcity/roadmap/#configuration-as-code" target="_blank" rel="noopener">TeamCity Configuration as Code Roadmap</a></h2><p>目前官网上放出的关于配置代码化的路线图有如下三个方面：</p><h3 id="Viewing-project-configuration-as-DSL-Developing"><a href="#Viewing-project-configuration-as-DSL-Developing" class="headerlink" title="Viewing project configuration as DSL - Developing"></a>Viewing project configuration as DSL - Developing</h3><blockquote><p>The View DSL button provides a great way to learn how to describe your build configuration in Kotlin code. Right now it is available only for build configurations, which is not very helpful if you want to write configurations for complete projects or if you are looking for the right piece of code to configure one particular thing. We are going to add similar buttons to other sections of TeamCity, so you can always find the correct way to configure your VCS roots, clean-up settings, or entire projects – as Kotlin code.</p></blockquote><p>当前最新的 2020.2 版本仅能使用 <code>View DSL</code> 按钮查看 build configuration 的代码，未来将增加可通过 <code>View DSL</code> 按钮查看整个 project 的 kotlin 代码。这将进一步的提升配置的可移植性。</p><h3 id="Omitting-imports-in-DSL-code-Designing"><a href="#Omitting-imports-in-DSL-code-Designing" class="headerlink" title="Omitting imports in DSL code - Designing"></a>Omitting imports in DSL code - Designing</h3><blockquote><p>We want the Kotlin DSL to be as brief and expressive as possible. To make it easier for you to describe your build configurations in Kotlin, we will allow you to omit the imports section in the beginning of the settings.kts file. This means that settings.kts can start directly with the project {…} section and will not require you to explicitly specify imports that are required to compile the script.</p></blockquote><p>允许省略 DSL 头部的 import。比较期待的改进。</p><h3 id="Disabling-UI-editing-Developing"><a href="#Disabling-UI-editing-Developing" class="headerlink" title="Disabling UI editing - Developing"></a>Disabling UI editing - Developing</h3><blockquote><p>TeamCity lets you set up CI/CD pipelines in a variety of ways based on your preferred workflow. Your projects can be configured through the DSL, through the UI, or through a mix of both. However, mixing manual edits with DSL changes may lead to a lot of confusion and versioning problems. To ensure that your configurations stay predictable and easy to manage, we will add a new option that will allow administrators to prohibit editing project configurations through the UI if they are set up using the Kotlin DSL.</p></blockquote><p>目前在未使用 <a href="https://blog.jetbrains.com/teamcity/2020/09/creating-teamcity-project-templates-with-kotlin-dsl-context-parameters/" target="_blank" rel="noopener">Kotlin DSL Context Parameter</a> 时，是允许使用 UI 及 DSL 混用的方式进行构建配置的调整的。未来将允许管理员对启用了 DSL 配置的项目禁用 UI 配置。</p><h2 id="总体感受"><a href="#总体感受" class="headerlink" title="总体感受"></a>总体感受</h2><p>虽然使用 Kotlin DSL 会带来一些学习成本，并且在使用密文的时候（尤其是 Token）可能需要做一些尝试，但与其所带来的好处相比，还是可以承受的。</p><p>如果你想尝试 TeamCity Kotlin DSL，现在是个不错的时机。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://rodm.github.io/blog/2017/03/teamcity-versioned-settings.html" target="_blank" rel="noopener">TeamCity Versioned Settings with Kotlin</a></li><li><a href="https://blog.jetbrains.com/teamcity/2019/03/configuration-as-code-part-1-getting-started-with-kotlin-dsl/" target="_blank" rel="noopener">Configuration as Code, Part 1: Getting Started with Kotlin DSL</a></li><li><a href="https://blog.jetbrains.com/teamcity/2019/03/configuration-as-code-part-2-working-with-kotlin-scripts/" target="_blank" rel="noopener">Configuration as Code, Part 2: Working with Kotlin Scripts</a></li><li><a href="https://blog.jetbrains.com/teamcity/2019/04/configuration-as-code-part-3-creating-build-configurations-dynamically/" target="_blank" rel="noopener">Configuration as Code, Part 3: Creating Build Configurations Dynamically</a></li><li><a href="https://blog.jetbrains.com/teamcity/2019/04/configuration-as-code-part-4-extending-the-teamcity-dsl/" target="_blank" rel="noopener">Configuration as Code, Part 4: Extending the TeamCity DSL</a></li><li><a href="https://blog.jetbrains.com/teamcity/2019/04/configuration-as-code-part-5-using-dsl-extensions-as-a-library/" target="_blank" rel="noopener">Configuration as Code, Part 5: Using DSL extensions as a library</a></li><li><a href="https://blog.jetbrains.com/teamcity/2019/05/configuration-as-code-part-6-testing-configuration-scripts/" target="_blank" rel="noopener">Configuration as Code, Part 6: Testing Configuration Scripts</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI </tag>
            
            <tag> DSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zsh</title>
      <link href="2020/12/13/zsh/"/>
      <url>2020/12/13/zsh/</url>
      
        <content type="html"><![CDATA[<p><a href="https://alphahinex.github.io/2020/10/11/macos-catalina/">macOS Catalina 飞起来了</a> 之后，发现打开终端时会提示 <code>The default interactive shell is now zsh.</code><br><a href="https://support.apple.com/zh-cn/HT208050" target="_blank" rel="noopener">从 macOS Catalina 版开始，Mac 将使用 zsh 作为默认登录 Shell 和交互式 Shell。</a></p><p>默认情况下，Mac 使用 zsh 或 bash 作为登录 Shell 和交互式 Shell 的命令行解释器：</p><ul><li>从 macOS Catalina 版开始，zsh (Z shell) 是所有新建用户帐户的默认 Shell。</li><li>bash 是 macOS Mojave 及更低版本中的默认 Shell。</li></ul><h2 id="那么，zsh-是什么？"><a href="#那么，zsh-是什么？" class="headerlink" title="那么，zsh 是什么？"></a>那么，zsh 是什么？</h2><p><a href="http://zsh.sourceforge.net/" target="_blank" rel="noopener">zsh - the Z shell</a>，初版由 Paul Falstad 于 <a href="https://groups.google.com/group/alt.sources/msg/936c7876941058ed" target="_blank" rel="noopener">1990 年 12 月</a> 在 <a href="https://en.wikipedia.org/wiki/Princeton_University" target="_blank" rel="noopener">普林斯顿大学</a> 求学时发布，<a href="http://www.guckes.net/zsh/lover.html" target="_blank" rel="noopener">据说</a> 之所以使用这个名字，是因为当时在普林斯顿做助教的邵中（<a href="http://www.cs.yale.edu/homes/shao/" target="_blank" rel="noopener">Zhong Shao</a>，现任耶鲁大学教授）的登录名是 <code>zsh</code>，Paul 认为这是一个用于 shell 的好名字。</p><p>所以 zsh 是 shell 的一种，被设计用来与操作系统进行交互，同时也是一个强大的脚本语言。</p><p>目前 zsh 由 <code>&lt;zsh-workers@zsh.org&gt;</code> 邮件列表中的成员所维护，当前的开发工作主要由 Peter Stephenson <code>&lt;pws@zsh.org&gt;</code> 进行协调，目前最新的发布版是 <a href="http://zsh.sourceforge.net/News/" target="_blank" rel="noopener">2020 年 2 月 15 日发布的 5.8 版</a>。</p><h2 id="还有哪些-shell？"><a href="#还有哪些-shell？" class="headerlink" title="还有哪些 shell？"></a>还有哪些 shell？</h2><p>引用阮一峰老师 <a href="https://wangdoc.com/bash/index.html" target="_blank" rel="noopener">Bash 脚本教程</a> 中对 <a href="https://wangdoc.com/bash/intro.html#shell-%E5%92%8C-bash-%E7%9A%84%E5%8E%86%E5%8F%B2" target="_blank" rel="noopener">Shell 和 Bash 的历史</a> 的介绍：</p><blockquote><p>Shell 伴随着 Unix 系统的诞生而诞生。</p><p>1969年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。</p><p>1971年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是sh，方便用户使用 Unix。</p><p>1973年至1975年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。</p><p>1976年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。</p><p>1978年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是csh。它是第一个真正替代sh的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。</p><p>1979年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是sh。对于用户来说，它们是同一个东西，只是底层代码不同而已。</p><p>1983年，David Korn 开发了Korn shell，程序名是ksh。</p><p>1985年，Richard Stallman 成立了自由软件基金会（FSF），由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。</p><p>1988年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为bash，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。</p></blockquote><p>zsh 与 Bourne Shell (sh) 高度兼容，并且与 <a href="http://www.gnu.org/software/bash/" target="_blank" rel="noopener">Bash</a> 基本兼容，但存在一些差别。</p><p>关于 zsh 与 Bash 的差别，可参考 <a href="http://zsh.sourceforge.net/Doc/Release/Shell-Builtin-Commands.html#Shell-Builtin-Commands" target="_blank" rel="noopener">zsh 的内建指令</a> 与 <a href="http://www.gnu.org/software/bash/manual/bash.html#Shell-Builtin-Commands" target="_blank" rel="noopener">Bash 的内建指令</a>，以及 <a href="http://zsh.sourceforge.net/Guide/zshguide01.html#l2" target="_blank" rel="noopener">zsh 与其他 shell 的比较</a>。</p><p>另可参考 <a href="http://www.gnu.org/software/bash/manual/bash.html#Introduction" target="_blank" rel="noopener">Bash 的介绍</a> 等内容。</p><p>想知道你的系统里有几种 shell，可以通过以下命令查看：</p><pre><code class="bash">$ cat /etc/shells/bin/bash/bin/csh/bin/dash/bin/ksh/bin/sh/bin/tcsh/bin/zsh</code></pre><p>临时使用其他 shell，可以直接输入 shell 名，比如 <code>tcsh</code>。</p><p>修改默认 shell，可以使用 <code>chsh -s /bin/zsh</code>。</p><h2 id="为什么要用-zsh？"><a href="#为什么要用-zsh？" class="headerlink" title="为什么要用 zsh？"></a>为什么要用 zsh？</h2><p>简单总结几个吸引我的点：</p><ol><li>强大的 Tab 补全功能</li><li>活跃的社区、丰富的插件，比如下面要提到的跳转路径插件 autojump</li><li>苹果强推</li></ol><p>zsh 也是一把双刃剑，在享受便利的同时，也会有一些不便：</p><ol><li>与 Bash 并非完全兼容，所以进行脚本开发时需时刻注意</li><li>配置繁琐</li></ol><h2 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh My Zsh"></a>Oh My Zsh</h2><p>提到 zsh，就不得不提 <a href="https://ohmyz.sh/" target="_blank" rel="noopener">Oh My Zsh</a>，依靠强大的社区（<a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener">with 1700+ contributors</a>），可以抹平 zsh 的上手门槛，开箱即用，入门之后还有广阔的折腾空间。</p><p>比如 <a href="https://www.zhihu.com/question/21418449" target="_blank" rel="noopener">为什么说 zsh 是 shell 中的极品？</a> 这里提到的各种功能，大多是通过 zsh 的插件实现的，zsh 及 Oh My Zsh 的默认配置中并不包含。</p><h2 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h2><p>墙裂推荐的一个插件就是 <a href="https://github.com/wting/autojump" target="_blank" rel="noopener">autojump</a>，在命令行里切换路径是一个很低效的事，安装并配置此插件后，即可直接 <code>j</code> 到包含后面录入的关键字的目录，或使用 Tab 列出所有包含关键字的目录，再按 Tab 进行选择，如：</p><p><img src="/contents/zsh/autojump.png" alt="autojump"></p>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何确定装载了哪个类</title>
      <link href="2020/12/06/which-class-is-loaded/"/>
      <url>2020/12/06/which-class-is-loaded/</url>
      
        <content type="html"><![CDATA[<p>某些时候，我们可能希望知道 ClassLoader 里到底装载的是哪个 class，比如当两个 jar 包中存在 package 和 Class 名完全相同的两个类时。</p><h2 id="java-verbose"><a href="#java-verbose" class="headerlink" title="java -verbose"></a>java -verbose</h2><p>在 java 命令的帮助信息中，有如下内容（部分）：</p><pre><code class="bash">$ java -help用法: java [-options] class [args...]           (执行类)   或  java [-options] -jar jarfile [args...]           (执行 jar 文件)其中选项包括:    -d32      使用 32 位数据模型 (如果可用)    -d64      使用 64 位数据模型 (如果可用)    -server      选择 &quot;server&quot; VM                  默认 VM 是 server,                  因为您是在服务器类计算机上运行。    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;                  用 : 分隔的目录, JAR 档案                  和 ZIP 档案列表, 用于搜索类文件。    -D&lt;名称&gt;=&lt;值&gt;                  设置系统属性    -verbose:[class|gc|jni]                  启用详细输出</code></pre><p>可以直接使用 <code>java -verbose</code> 来查看运行此命令时装载了哪些类（部分）：</p><pre><code class="bash">$ java -verbose...[Loaded java.lang.CharSequence from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.String from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.reflect.AnnotatedElement from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.reflect.GenericDeclaration from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.reflect.Type from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.Class from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.Cloneable from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.ClassLoader from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.System from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.Throwable from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.Error from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.ThreadDeath from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar][Loaded java.lang.Exception from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar]...</code></pre><p>也可以限定详细输出的类型，比如 <code>java -verbose:jni</code>，或组合使用 <code>java -verbose:class -verbose:jni</code>。</p><p>在运行一个 Spring Boot 应用时，可以通过此参数观察类的装载情况，以确定装载的 class 的来源是哪个 jar 包，进而解决上面提到的问题：</p><pre><code class="bash">$ java -verbose -jar app.jar...[Loaded org.springframework.cglib.core.EmitUtils$5 from jar:file:/Users/alphahinex/github/origin/spring-roll/app.jar!/BOOT-INF/lib/spring-core-5.2.2.RELEASE.jar!/][Loaded java.util.DualPivotQuicksort from /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/jre/lib/rt.jar][Loaded org.springframework.cglib.core.EmitUtils$6 from jar:file:/Users/alphahinex/github/origin/spring-roll/app.jar!/BOOT-INF/lib/spring-core-5.2.2.RELEASE.jar!/][Loaded io.github.springroll.RollWebApplication$$EnhancerBySpringCGLIB$$d2db2c71 from jar:file:/Users/alphahinex/github/origin/spring-roll/app.jar!/BOOT-INF/classes!/][Loaded org.springframework.cglib.proxy.MethodProxy from jar:file:/Users/alphahinex/github/origin/spring-roll/app.jar!/BOOT-INF/lib/spring-core-5.2.2.RELEASE.jar!/][Loaded org.springframework.cglib.proxy.MethodProxy$CreateInfo from jar:file:/Users/alphahinex/github/origin/spring-roll/app.jar!/BOOT-INF/lib/spring-core-5.2.2.RELEASE.jar!/][Loaded org.springframework.cglib.proxy.Enhancer$EnhancerFactoryData from jar:file:/Users/alphahinex/github/origin/spring-roll/app.jar!/BOOT-INF/lib/spring-core-5.2.2.RELEASE.jar!/][Loaded io.github.springroll.swagger.ApplicationSwaggerConfiguration$$EnhancerBySpringCGLIB$$8e0e540e from jar:file:/Users/alphahinex/github/origin/spring-roll/app.jar!/BOOT-INF/lib/roll-swagger-0.0.9-SNAPSHOT.jar!/][Loaded io.github.springroll.export.excel.ExportExcelConfiguration$$EnhancerBySpringCGLIB$$d150201a from jar:file:/Users/alphahinex/github/origin/spring-roll/app.jar!/BOOT-INF/lib/roll-export-0.0.9-SNAPSHOT.jar!/]...</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云架构高级工程师</title>
      <link href="2020/11/29/tencent-cloud-tcp/"/>
      <url>2020/11/29/tencent-cloud-tcp/</url>
      
        <content type="html"><![CDATA[<h2 id="考试形式"><a href="#考试形式" class="headerlink" title="考试形式"></a>考试形式</h2><p>疫情期间采用线上考试的方式。考试时间 120 分钟，总分 100 分，共 65 题（30 单选 + 15 多选 + 20 案例分析），均为单选及多选形式，多选不提示选项个数。<br>通过条件 70 分以上。<br>线上考试可提前进入考场，开始考试 30 分钟后不得登录系统。</p><p>考试过程中浏览器会进入全屏，离开作答界面或退出全屏可能将引发疑似作弊告警。各类违规行为累计出现5次及以上，将视为作弊，取消考试成绩。</p><p>考试结束后当场显示成绩，考后7个工作日内将发放考试结果通知。</p><p>可提前在 <a href="https://tx.weicewang.com/login/p/209100" target="_blank" rel="noopener">这里</a> 进行试考，检查设备是否满足考试要求。</p><p>考试过程中，如意外中断/系统设备崩溃，请重新登录并回到中断前页面作答，如需延时请拨打客服热线：400-8006213/13810321135，监考老师会依据后台实际记录作为是否延时的判断依据。</p><blockquote><p>提示1：考试前请关闭其电脑上可能会弹窗以及会导致浏览器退出全屏的应用，避免被警告。iPhone 在 Mac 边上时注意将手机飞行，以免来电话导致切屏被警告 囧rz</p></blockquote><blockquote><p>提示2：考试时间比较紧张，需抓紧时间作答</p></blockquote><blockquote><p>吐槽1：考试中有大量带图片的试题，尤其后面案例题基本都是带图片的，考试中竟然出现了图片显示的是 “此图片未经允许不可引用” 的替代图，返回试题列表重新进入答题问题依旧，幸好对试题本身影响不是很大。</p></blockquote><blockquote><p>吐槽2：在检查过程中，倒计时系统出现问题，原本只剩 30 分钟左右时间，倒计时竟突然回退至 60 分钟左右开始重新计时，但之前不显示的图片突然又正常显示了。莫非是系统检测到之前的图片问题自动给延长考试时间了？</p></blockquote><h2 id="官方备考资料"><a href="#官方备考资料" class="headerlink" title="官方备考资料"></a>官方备考资料</h2><ul><li><a href="https://main.qcloudimg.com/raw/e58c0b73b4d9274b68946e8ba229215e/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9E%B6%E6%9E%84%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88TCP%EF%BC%89%E8%AE%A4%E8%AF%81-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%88%97%E8%A1%A8v1.0.pdf" target="_blank" rel="noopener">腾讯云架构高级工程师（TCP）认证-知识点列表v1.0.pdf</a></li><li><a href="https://main.qcloudimg.com/raw/6f2b978563ed3db36a8e7c2150be13e6/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9E%B6%E6%9E%84%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88TCP%EF%BC%89%E8%AE%A4%E8%AF%81-%E8%80%83%E8%AF%95%E6%A0%B7%E9%A2%98V1.1.pdf" target="_blank" rel="noopener">腾讯云架构高级工程师（TCP）认证-考试样题V1.1.pdf</a></li></ul><blockquote><p>注意：考试中有出现样题里的原题</p></blockquote><h2 id="某场考点总结"><a href="#某场考点总结" class="headerlink" title="某场考点总结"></a>某场考点总结</h2><p>总结一些考试中考到的点。</p><ol><li>Oceanus</li><li>TAPD</li><li>TCE 解决方案：行业版、大数据版、AI 版、敏捷版</li><li>标准直播 LVB、慢直播 LCB、快直播 LEB、云点播 VOD、TRTC、CSS、直播时移、直播鉴黄</li><li>优图天眼</li><li>智能钛机器学习平台、智能钛工业 AI 平台、智能钛弹性模型服务</li><li>游戏多媒体引擎 GME、手游安全测试 SR、全球应用加速 GAAP、智营网优 INO、蓝鲸</li><li>腾讯知识图谱 TKG、腾讯智能对话平台 TBP</li><li>人脸核身</li><li>云联网、对等连接、CIDR、NAT、VPN、专线、VPC、子网</li><li>缓存雪崩</li><li>EMR、SaasBI、RayData</li><li>企业画像（Enterprise Profile，EP）</li><li>TencentDB 同步方式：强同步复制、同步复制、半同步复制、异步复制</li><li>平滑迁移、DTS</li><li>IKE、L2TP、GRE、PPTP、IPSec</li><li>数据加密服务</li><li>Tstack、Tstack-VPC 部署、TCE、黑石服务器</li><li>存储网关 CSG</li><li>CBS 全量快照、增量快照</li><li>COS 异地容灾</li></ol><h2 id="面授培训笔记"><a href="#面授培训笔记" class="headerlink" title="面授培训笔记"></a>面授培训笔记</h2><h3 id="云架构设计"><a href="#云架构设计" class="headerlink" title="云架构设计"></a>云架构设计</h3><ul><li>采用合理的成本，不要使用本地的产品思维，不需要超量采购及配置，更多的考虑弹性，而不是一步到位</li><li>高可用性是一个概率：可用时间/总时间*100%，严格来讲不能进位（四舍五入），通常业界适用的是2个9到5个9的可用性</li><li>扩展性主要指业务模块的扩展，不是把所有模块全部进行扩展。最基本要实现的是“解耦”，而不是单靠服务器的堆叠。</li><li>安全性：不需要考虑物理安全</li><li>上云迁移场景应该考虑哪些内容：容量设计（网络规划）、目标用户群体（地域）、可行性分析（什么系统要上云）</li><li>本地网络规划：24位掩码可用 ip 地址为 2^(32-24)-2，在腾讯云上要减掉3，平台通讯需要网络地址。容量规划时至少要保留 30% 剩余。但也不要使用类似8位掩码，因为网络足够大，性能就会受损</li><li>云上不同机房的专线是免费的</li><li>高可用设计：尽可能的使用云服务而不是基于开源自建</li><li>高峰流量处理：应对高并发带来的问题，尽量考虑自动化扩容等方式去解决</li><li>免费 2Gbps 的 DDOS 抵御，可购买基础防护加弹性防护，比如先购买10G，弹性防护按实际产生按天付费</li><li>混合云专线的部署：需要有备用线路，备线不要用同一个运营商以增加可用性</li><li>COS 在线迁移是指时间可控的场景，数据量也可控</li><li>CDM 离线迁移，CDM 是硬件，通过卡车的方式迁移数据，只适合非结构化迁移</li><li>云安全合规产品包括：网络安全、数据安全、应用安全、业务安全</li><li>存储网关：可理解为软件，需要存储时通过存储网关进行挂载，接入腾讯云存储</li></ul><h3 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h3><ul><li>podman 解决了 docker 守护进程安全性问题，可以在普通用户权限下运行，实现更安全的容器化</li><li>微服务的设计原则：去中心化、全维度可视化、全流程自动化</li><li>TSF 相当于腾讯云提供的 k8s</li><li>Serverless —— 食堂饭卡消费系统就是一个很适合的场景，需要有一个触发操作</li><li>remove.bg 在线抠图</li></ul><hr><ul><li>针对不同阶段客户推荐不同的容灾方案</li><li>腾讯云 BGP 大概捆绑了 20 个运营商 —— HttpDNS 和云解析（基于 DNSPod）</li><li>DNS 解析是使用 UDP 53 号端口，速度快但不可靠，可以使用 HttpDNS 改为使用 TCP 协议获取</li><li>HttpDNS 只适用移动开发，可优先使用 HttpDNS，fallback DNS UDP</li><li>多级 CDN 可通过中间源减少对源站请求的压力</li><li>CDN 应用实践：CDN+COS（对象存储）</li><li>将 VIP 多地发布，实现用户就近接入</li><li>Anycast IP 就近接入 pop，内网高速连到源站</li><li>BGP 高防 IP 地址可以解决服务不上云，但在云上完成清洗，只要有公网 ip</li><li>BGP 高防包是防护云内资源的</li><li>AS 弹性伸缩</li><li>CLB 负载均衡最大的边界是城市，城市之间负载均衡需要使用云解析</li><li>专线平均需要一个月的时间实施；VPN 会比专线快</li><li>漏洞扫描按次计费</li><li>CMQ 基于 RocketMQ，CKafka 基于 Kafka</li><li>CMQ 承诺消息可以无上限的堆积</li><li>本地组建分布式文件系统：HDFS、ceph</li><li>云上对单个主机没必要做快照，但是需要对磁盘做快照</li><li>文件存储 CFS 应用：NFS + sabar？</li><li>外层网络、接入层网络、应用层、中间件层、数据层高可用架构设计</li><li>调度算法：加权轮询、加权最小连接数、源地址散列调度算法</li><li>将 SSL 证书部署在负载均衡上，可以减少后面应用节点的 CPU 消耗</li><li>COS 默认情况下就是三份存储</li></ul><hr><ul><li>数据库升配时，业务不会中断，但会有一个秒级的闪断，所以业务端需设计重连机制</li><li>信息的安全合规</li><li>安全目标CIA：机密性（Confidentiality）、完整性（Integrity）、可用性（Availability）</li><li>从哪些方面构建自己的数据安全能力：数据创建、存储、传输、访问、使用、销毁</li><li>HSM 是基于硬件的数据加密服务</li><li>分布式存储支持自动加密</li><li>对数据安全要求非常苛刻时，必须使用专线；要求不是特别高时，可使用 VPN</li><li>量子传输可使用量子加密，理论上不可能被破解</li><li>ABAC：基于属性的权限控制。比如对象存储就会使用这种权限控制方式</li><li>混合云还可以是公有云+公有云，公有云之间也可以申请专线完成对接</li><li>云联网（CNN）解决大型企业多地数据中心组建内网问题</li><li>云存储网关提供的类型：卷网关、文件网关、磁带网关</li><li>TStack 是 OpenStack + k8s，也是部署到自己机房，可以理解为免费</li><li>TCE 是腾讯云所有产品私有化部署到私有机房，费用高</li><li>自动化运维平台 —— 蓝鲸，已开源</li><li>腾讯云 redis 连接数限制为 10000</li><li>set 化部署：单元化，相当于自己的应用连自己的数据库</li></ul>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud </tag>
            
            <tag> Certification </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s ConfigMap</title>
      <link href="2020/11/22/k8s-config-map/"/>
      <url>2020/11/22/k8s-config-map/</url>
      
        <content type="html"><![CDATA[<p><a href="https://alphahinex.github.io/2020/10/18/deploy-first-app-in-k8s/">在 k8s 集群中部署第一个应用</a> 中，完成了一个基本的 NGINX 服务的部署，但在真实环境中使用 NGINX 时，一般都需要定制其配置文件，使满足实际代理需求。K8s 提供了一个 <a href="https://kubernetes.io/docs/concepts/configuration/configmap/" target="_blank" rel="noopener">ConfigMap</a> 的概念，允许将配置文件与镜像文件分离，以使容器化的应用程序具有可移植性。</p><h2 id="什么是-ConfigMap"><a href="#什么是-ConfigMap" class="headerlink" title="什么是 ConfigMap"></a>什么是 ConfigMap</h2><p>可以按字面方式，将 ConfigMap，理解为一个 Config 的 Map：</p><ul><li>Map 的 Key 为配置标识，可以是文件名等</li><li>Map 的 Value 为配置内容，可以是字符串、文本内容等</li></ul><p>一个 ConfigMap 中可以包含多个 Key / Value 对。</p><h2 id="怎么创建-ConfigMap"><a href="#怎么创建-ConfigMap" class="headerlink" title="怎么创建 ConfigMap"></a>怎么创建 ConfigMap</h2><p>可以使用 <code>kubectl create configmap</code> 命令基于 目录、文件 或字符串来创建 ConfigMap，也可以直接编写 yaml 文件进行定义：</p><pre><code class="yaml"># nginx-config.ymlapiVersion: v1kind: ConfigMapmetadata:  name: nginx-configdata:  nginx_conf: |    user  nginx;    worker_processes  2;    error_log  /var/log/nginx/error.log warn;    pid        /var/run/nginx.pid;    events {        worker_connections  1024;    }    http {        include       /etc/nginx/mime.types;        default_type  application/octet-stream;        log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                          &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                          &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;        access_log  /var/log/nginx/access.log  main;        sendfile        on;        #tcp_nopush     on;        keepalive_timeout  65;        #gzip  on;        include /etc/nginx/conf.d/*.conf;    }---apiVersion: v1kind: ConfigMapmetadata:  name: confd-configdata:  file_server.conf: |    server {        listen       2020;        server_name  file_server;        location / {            autoindex on;            root /usr/share/nginx;            charset utf-8;        }    }  another.conf: |    server {        listen       8000;        server_name  another;        location / {            root /usr/share/nginx/html;        }    }</code></pre><p>之后可使用 <code>kubectl apply -f nginx-config.yml</code> 完成 ConfigMap 的创建。</p><h2 id="怎么使用-ConfigMap"><a href="#怎么使用-ConfigMap" class="headerlink" title="怎么使用 ConfigMap"></a>怎么使用 ConfigMap</h2><p>ConfigMap 有多种定义形式，也有多种使用形式，详细情况可以查阅 <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/" target="_blank" rel="noopener">官方文档</a>。本文仍以 NGINX 配置文件为例，说明一下 ConfigMap 中定义的配置文件的使用方式。</p><p>上面的 <code>nginx-config.yml</code> 定义了两个 ConfigMap，目标是放到 NGINX 容器中的如下两个位置：</p><ul><li>nginx-config =&gt; /etc/nginx/nginx.conf</li><li>confd-config =&gt; /etc/nginx/conf.d</li></ul><p>可以将 ConfigMap 添加到 Volume 中，再进行挂载以使用，如：</p><pre><code class="yaml">apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx  labels:    app: nginxspec:  selector:    matchLabels:      app: nginx  replicas: 1  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: nginx:1.17.9        resources:          requests:            cpu: 100m            memory: 100Mi        volumeMounts:        - name: nginx-config-vol          mountPath: /etc/nginx/nginx.conf # 也可挂载到文件          subPath: nginx.conf # 挂载到文件时，需设置子路径        - name: confd-vol # 与 volumes 中的 name 对应          mountPath: /etc/nginx/conf.d # 配置文件要挂载的路径      volumes:      - name: nginx-config-vol # 对应 ConfigMap 的 name        configMap:          name: nginx-config          items:          - key: nginx_conf            path: nginx.conf      - name: confd-vol        configMap:          name: confd-config          # 此时会将此 ConfigMap 中的所有配置以文件形式挂载          # 如果只需挂载一个文件（如 file_server.conf），可以按如下方式指定：          # items:          # - key: file_server.conf          #   path: file_server.conf</code></pre><p>有两个地方需要说明一下：</p><h3 id="使用-mountPath-挂载路径时"><a href="#使用-mountPath-挂载路径时" class="headerlink" title="使用 mountPath 挂载路径时"></a>使用 mountPath 挂载路径时</h3><p>比如上例中的 <code>mountPath: /etc/nginx/conf.d</code>，此时可指定挂载 ConfigMap 中的某个配置到该路径下的具体文件，也可将整个 ConfigMap 中的所有配置以多个文件的形式挂载到指定路径下。</p><p>不论哪种方式，都会将容器中原路径下所有先前的文件清除，需注意。</p><h3 id="使用-mountPath-挂载文件时"><a href="#使用-mountPath-挂载文件时" class="headerlink" title="使用 mountPath 挂载文件时"></a>使用 mountPath 挂载文件时</h3><p>若想将配置文件挂载至容器中某个具体文件处，不影响该文件所在路径的其他文件，可按上例中的 <code>nginx.conf</code> 文件方式：</p><pre><code class="yaml">mountPath: /etc/nginx/nginx.conf # 也可挂载到文件subPath: nginx.conf # 挂载到文件时，需设置子路径</code></pre><p>即 <code>mountPath</code> 直接指定到具体文件，并通过 <code>subPath</code> 表明文件名。</p><h2 id="挂载的-ConfigMap-自动更新"><a href="#挂载的-ConfigMap-自动更新" class="headerlink" title="挂载的 ConfigMap 自动更新"></a>挂载的 ConfigMap 自动更新</h2><p>更新已经在数据卷中使用的 ConfigMap 时，已映射的配置内容最终也会被自动更新。<code>kubelet</code> 在每次定期同步时都会检查已挂载的 ConfigMap 是否是最新的。但是，它使用其本地的基于 TTL 的缓存来获取 ConfigMap 的当前值。因此，从更新 ConfigMap 到将新值映射到 Pod 的总延迟，可能与 kubelet 同步周期 + ConfigMap 在 kuelet 中缓存的 TTL 一样长。</p><p>另外，使用 ConfigMap 作为 <code>subPath</code> 的数据卷将不会收到 ConfigMap 更新。</p><p>以上面配置为例，当更新 ConfigMap 中 NGINX 配置文件内容并 apply 到集群之后，可以稍等一会，然后进入到容器中观察配置文件，<code>nginx.conf</code> 文件的内容不会随 ConfigMap 文件更新同步，但 <code>/etc/nginx/conf.d</code> 路径下内容，会按更新周期，自动同步 <code>confd-config</code> 中的所有变更，包括配置文件内容，以及配置文件个数。</p><h2 id="完整的-K8s-配置"><a href="#完整的-K8s-配置" class="headerlink" title="完整的 K8s 配置"></a>完整的 K8s 配置</h2><p>本文中完整的 K8s 配置如下：</p><pre><code class="yaml"># nginx-test.ymlapiVersion: v1kind: ConfigMapmetadata:  name: nginx-configdata:  nginx_conf: |    user  nginx;    worker_processes  2;    error_log  /var/log/nginx/error.log warn;    pid        /var/run/nginx.pid;    events {        worker_connections  1024;    }    http {        include       /etc/nginx/mime.types;        default_type  application/octet-stream;        log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                          &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                          &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;        access_log  /var/log/nginx/access.log  main;        sendfile        on;        #tcp_nopush     on;        keepalive_timeout  65;        #gzip  on;        include /etc/nginx/conf.d/*.conf;    }---apiVersion: v1kind: ConfigMapmetadata:  name: confd-configdata:  file_server.conf: |    server {        listen       2020;        server_name  file_server;        location / {            autoindex on;            root /usr/share/nginx;            charset utf-8;        }    }  another.conf: |    server {        listen       8000;        server_name  another;        location / {            root /usr/share/nginx/html;        }    }---apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx  labels:    app: nginxspec:  selector:    matchLabels:      app: nginx  replicas: 1  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: nginx:1.17.9        resources:          requests:            cpu: 100m            memory: 100Mi        volumeMounts:        - name: nginx-config-vol          mountPath: /etc/nginx/nginx.conf # 也可挂载到文件          subPath: nginx.conf # 挂载到文件时，需设置子路径        - name: confd-vol # 与 volumes 中的 name 对应          mountPath: /etc/nginx/conf.d # 配置文件要挂载的路径      volumes:      - name: nginx-config-vol # 对应 ConfigMap 的 name        configMap:          name: nginx-config          items:          - key: nginx_conf            path: nginx.conf      - name: confd-vol        configMap:          name: confd-config          # 此时会将此 ConfigMap 中的所有配置以文件形式挂载---apiVersion: v1kind: Servicemetadata:  name: nginx  labels:    app: nginxspec:  type: NodePort  ports:  - name: file    port: 2020    nodePort: 30081  - name: fb    port: 8000    nodePort: 30082  selector:    app: nginx</code></pre><p><code>kubectl apply -f nginx-test.yml</code> 完成部署之后，可通过集群的 <code>30081</code> 端口访问容器内 <code>2020</code> 端口的服务，并可以修改 ConfigMap 中内容，进入到容器中观察 NGINX 对应配置文件的变化。</p>]]></content>
      
      
      <categories>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s 命名空间</title>
      <link href="2020/11/15/k8s-namespace/"/>
      <url>2020/11/15/k8s-namespace/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes 支持在一个物理集群上划分多个虚拟集群，这些虚拟集群即 <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" target="_blank" rel="noopener">命名空间</a>。</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul><li>在同一个命名空间中，资源名称须保持唯一。但在不同命名空间中，可以存在相同名称的资源。</li><li>每一个资源只能隶属于一个命名空间。</li><li>但命名空间本身不能属于另一个命名空间。</li></ul><p>可以通过如下命令查看哪些资源在或不在命名空间中：</p><pre><code class="bash"># In a namespace$ kubectl api-resources --namespaced=true# Not in a namespace$ kubectl api-resources --namespaced=false</code></pre><h2 id="创建命名空间"><a href="#创建命名空间" class="headerlink" title="创建命名空间"></a>创建命名空间</h2><p>可参照如下配置文件创建命名空间（注意修改其中的 <code>alpha</code> 为想创建的命名空间名称）：</p><pre><code class="yaml"># namespace-alpha.ymlapiVersion: v1kind: Namespacemetadata:  name: alpha</code></pre><p>之后使用 <code>kubectl apply -f namespace-alpha.yml</code> 进行创建。</p><p>K8s 初始状态下包含了四个命名空间：</p><ul><li><code>default</code>：默认命名空间。资源未指定命名空间时，均创建在此命名空间下</li><li><code>kube-system</code>：K8s 系统创建的对象在此命名空间下</li><li><code>kube-public</code>：这个命名空间对所有用户可见（包括未授权用户），通常作为保留资源为集群所使用</li><li><code>kube-node-lease</code>：此命名空间用于与各个节点相关的租期（Lease）对象；此对象的设计使得集群规模很大时节点心跳检测性能得到提升</li></ul><blockquote><p>注意：创建命名空间时，应避免使用 <code>kube-</code> 作为前缀。</p></blockquote><h2 id="查看命名空间"><a href="#查看命名空间" class="headerlink" title="查看命名空间"></a>查看命名空间</h2><pre><code class="bash">$ kubectl get namespaceNAME              STATUS   AGEdefault           Active   1dkube-node-lease   Active   1dkube-public       Active   1dkube-system       Active   1d</code></pre><h2 id="指定命名空间"><a href="#指定命名空间" class="headerlink" title="指定命名空间"></a>指定命名空间</h2><p>在 Deployment 等配置文件中，可在 <code>metadata</code> 里指定所属的 <code>namespace</code>，如：</p><pre><code class="yaml">apiVersion: v1kind: Servicemetadata:  name: nginx  namespace: alpha  labels:    app: nginxspec:  type: NodePort  ports:  - name: nginx    port: 80    nodePort: 30080  selector:    app: nginx</code></pre><h2 id="查询命名空间中资源"><a href="#查询命名空间中资源" class="headerlink" title="查询命名空间中资源"></a>查询命名空间中资源</h2><p>在设定了 namespace 后，进行查询等操作时，均需指定命名空间，如：</p><pre><code class="bash">$ kubectl get pods -n alpha$ kubectl get pods --namespace=alpha</code></pre><h2 id="设定命名空间偏好"><a href="#设定命名空间偏好" class="headerlink" title="设定命名空间偏好"></a>设定命名空间偏好</h2><p>可在当前上下文中，设定命名空间偏好，使后续的 <code>kubectl</code> 命令不再需要特殊指定命名空间：</p><pre><code class="bash">$ kubectl config set-context --current --namespace=alpha# Validate itkubectl config view --minify | grep namespace:</code></pre><h2 id="跨命名空间服务访问"><a href="#跨命名空间服务访问" class="headerlink" title="跨命名空间服务访问"></a>跨命名空间服务访问</h2><p>默认情况下，使用服务名可以直接访问相同命名空间内的服务。如果需要访问其他命名空间里的服务，可使用 <code>服务名.命名空间</code> 的形式，如 <code>nginx.alpha</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Mac 的 Docker Desktop 中运行 K8s</title>
      <link href="2020/11/08/run-k8s-in-mac-docker-desktop/"/>
      <url>2020/11/08/run-k8s-in-mac-docker-desktop/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker Desktop for Mac</a> 从 <a href="https://docs.docker.com/docker-for-mac/release-notes/#docker-community-edition-18060-ce-mac70-2018-07-25" target="_blank" rel="noopener">Docker Community Edition 18.06.0-ce-mac70 2018-07-25</a> 版本起，添加了对 Kubernetes 的支持，可以方便的在 Mac 上运行一个单节点的 K8s 集群。</p><p>在 Docker Desktop 的 <code>Preferences</code> 中的 <code>Kubernetes</code> 页面里，提供了一个 <code>Enable Kubernetes</code> 选框，点击之后即可在 Mac 上启动 K8s。</p><p>然而点击之后，就没有然后了，一直是下图这个状态：</p><p><img src="/contents/k8s-starting/starting.jpg" alt="starting"></p><p>此问题的主要原因，是 K8s 运行所需的一些 <code>k8s.gcr.io</code> 下的镜像，无法直接下载得到。</p><h2 id="准备镜像"><a href="#准备镜像" class="headerlink" title="准备镜像"></a>准备镜像</h2><h3 id="配置镜像服务"><a href="#配置镜像服务" class="headerlink" title="配置镜像服务"></a>配置镜像服务</h3><p>在 <code>Preferences</code> =&gt; <code>Docker Engine</code> 里，可以配置 <code>registry-mirrors</code>，国内可用的一些镜像服务有：</p><ul><li>中国科大：<a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a> / <a href="https://ustc-edu-cn.mirror.aliyuncs.com" target="_blank" rel="noopener">https://ustc-edu-cn.mirror.aliyuncs.com</a></li><li>阿里云：https://&lt;xxxxx&gt;.mirror.aliyuncs.com，可使用阿里云账号在 <a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">这里</a> 获得</li><li>网易云：<a href="https://hub-mirror.c.163.com" target="_blank" rel="noopener">https://hub-mirror.c.163.com</a></li><li>DaoCloud：<a href="http://f1361db2.m.daocloud.io" target="_blank" rel="noopener">http://f1361db2.m.daocloud.io</a></li></ul><blockquote><p>另外，中国科大还有 <a href="https://github.com/ustclug/mirrorrequest/issues/91" target="_blank" rel="noopener">GCR</a> 和 <a href="https://github.com/ustclug/mirrorrequest/issues/135" target="_blank" rel="noopener">Quay</a> 的镜像。</p></blockquote><p>可添加多个镜像，如：</p><pre><code class="json">{  &quot;registry-mirrors&quot;: [    &quot;https://xxxxx.mirror.aliyuncs.com&quot;,    &quot;https://docker.mirrors.ustc.edu.cn&quot;,    &quot;https://hub-mirror.c.163.com&quot;,    &quot;http://f1361db2.m.daocloud.io&quot;  ],  &quot;debug&quot;: true,  &quot;experimental&quot;: true}</code></pre><p>之后点击 <code>Apply &amp; Restart</code> 应用配置。</p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>在 <a href="https://github.com/AliyunContainerService" target="_blank" rel="noopener">阿里云容器服务的 GitHub 组织</a> 下，有个 <a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop" target="_blank" rel="noopener">k8s-for-docker-desktop</a> 仓库即为解决此问题而存在。解决的方式为：先从阿里云下载所需的镜像副本至本地，再将镜像 tag 修改至 <code>k8s.gcr.io</code> 下。</p><p>以如下软件版本为例：</p><p><img src="/contents/k8s-starting/versions.png" alt="versions"></p><p>可使用 <a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop/tree/28caeb743b4f1e7b0c70ce24469a7d735de81efc" target="_blank" rel="noopener">当前</a> master 分支最新的内容，直接执行 <code>load_images.sh</code> 完成镜像的下载及 tag 修改。</p><p>下载之后的镜像包括如下 8 个，与 <a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop/blob/28caeb743b4f1e7b0c70ce24469a7d735de81efc/images.properties" target="_blank" rel="noopener">images.properties</a> 中内容一一对应：</p><pre><code class="bash">$ docker imagesREPOSITORY                                                       TAG                                              IMAGE ID            CREATED             SIZEk8s.gcr.io/kube-proxy                                            v1.19.3                                          cdef7632a242        3 weeks ago         118MBk8s.gcr.io/kube-apiserver                                        v1.19.3                                          a301be0cd44b        3 weeks ago         119MBk8s.gcr.io/kube-controller-manager                               v1.19.3                                          9b60aca1d818        3 weeks ago         111MBk8s.gcr.io/kube-scheduler                                        v1.19.3                                          aaefbfa906bd        3 weeks ago         45.7MBk8s.gcr.io/etcd                                                  3.4.13-0                                         0369cf4303ff        2 months ago        253MBk8s.gcr.io/coredns                                               1.7.0                                            bfe3a36ebd25        4 months ago        45.2MBk8s.gcr.io/pause                                                 3.2                                              80d28bedfe5d        8 months ago        683kBquay.io/kubernetes-ingress-controller/nginx-ingress-controller   0.26.1                                           29024c9c6e70        13 months ago       483MB</code></pre><h3 id="其他版本？"><a href="#其他版本？" class="headerlink" title="其他版本？"></a>其他版本？</h3><p>如果使用的不是上图中的版本，且 <code>k8s-for-docker-desktop</code> 仓库还没有支持该版本时，可根据 K8s 版本通过如下方式获得 <code>images.properties</code> 中对应版本信息：</p><p>安装 K8s 对应版本的 <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">kubeadm</a> ，之后运行：</p><pre><code class="bash"># 替换 ${KUBERNETES_VERSION} 为所使用的 K8s 版本$ ./kubeadm config images list --kubernetes-version=${KUBERNETES_VERSION}</code></pre><p>可得到类似如下信息：</p><pre><code class="text">k8s.gcr.io/kube-apiserver:v1.19.3k8s.gcr.io/kube-controller-manager:v1.19.3k8s.gcr.io/kube-scheduler:v1.19.3k8s.gcr.io/kube-proxy:v1.19.3k8s.gcr.io/pause:3.2k8s.gcr.io/etcd:3.4.13-0k8s.gcr.io/coredns:1.7.0</code></pre><p>也可参照这个 <a href="https://github.com/maguowei/actions/blob/master/k8s-image-sync/entrypoint.sh" target="_blank" rel="noopener">entrypoint.sh</a> 中的 <a href="https://github.com/maguowei/actions/blob/master/k8s-image-sync/entrypoint.sh#L3-L10" target="_blank" rel="noopener">内容</a> ，或直接从 <a href="https://github.com/gotok8s/gotok8s/actions" target="_blank" rel="noopener">这个</a> 定期执行的 GitHub Actions 记录中找到对应版本执行时的输出信息，如 <a href="https://github.com/gotok8s/gotok8s/runs/1367596287?check_suite_focus=true#step:3:15" target="_blank" rel="noopener">v1.19.3 记录</a>。</p><p>根据所得到的对应版本镜像信息，修改 <code>images.properties</code> 文件中内容，再执行 <code>load_images.sh</code> 即可。</p><h2 id="依旧-Starting-？"><a href="#依旧-Starting-？" class="headerlink" title="依旧 Starting ？"></a>依旧 Starting ？</h2><p>在完成镜像下载并重启 Docker Desktop 之后，K8s 依旧停留在 Starting 状态。</p><p>通过</p><pre><code class="bash">$ pred=&#39;process matches &quot;.*(ocker|vpnkit).*&quot;  || (process in {&quot;taskgated-helper&quot;, &quot;launchservicesd&quot;, &quot;kernel&quot;} &amp;&amp; eventMessage contains[c] &quot;docker&quot;)&#39;/usr/bin/log stream --style syslog --level=debug --color=always --predicate &quot;$pred&quot;</code></pre><p>查看日志，发现不断输出如下内容：</p><pre><code class="log">2020-11-07 01:01:48.307809+0800  localhost com.docker.driver.amd64-linux[2646]: cannot get lease for master node: an error on the server (&quot;&quot;) has prevented the request from succeeding (get leases.coordination.k8s.io docker-desktop)2020-11-07 01:01:48.308417+0800  localhost com.docker.backend[1833]: external: POST /events 200 &quot;DockerDesktopGo&quot; &quot;&quot;2020-11-07 01:01:49.231052+0800  localhost com.docker.driver.amd64-linux[2646]: (libsystem_info.dylib) [com.apple.network.libinfo:getaddrinfo] nat64_v4_requires_synthesis(127.0.0.1) == false</code></pre><p>按照 <a href="https://github.com/docker/for-win/issues/3769#issuecomment-486046718" target="_blank" rel="noopener">这里</a> 及 <a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop/issues/78#issuecomment-661802062" target="_blank" rel="noopener">这里</a> 提到的方式，删除掉 <code>pki</code> 文件夹：</p><pre><code class="bash">$ rm -rf ~/Library/Group\ Containers/group.com.docker/pki/</code></pre><p>之后再重启并观察日志，上述问题不再出现，并且新下载了 3 个 desktop 相关的镜像：</p><pre><code class="bash">$ docker images | grep desktopdocker/desktop-kubernetes                                        kubernetes-v1.19.3-cni-v0.8.5-critools-v1.17.0   7f85afe431d8        3 weeks ago         285MBdocker/desktop-storage-provisioner                               v1.1                                             e704287ce753        7 months ago        41.8MBdocker/desktop-vpnkit-controller                                 v1.0                                             79da37e5a3aa        8 months ago        36.6MB</code></pre><p>等待一会之后，终于变成 Running 状态了！</p><p><img src="/contents/k8s-starting/running.png" alt="running"></p><blockquote><p>Tips: 如果还是 Starting 状态，可以尝试将当前安装的 Docker Desktop 环境都清理掉，全新安装一个稳定版本，可能就不会有奇怪的问题了。</p></blockquote><blockquote><p>另外，在没开启 <code>Preferences</code> =&gt; <code>Kubernetes</code> 中的 <code>Show system containers (advanced)</code> 选项时，<code>docker ps</code> 是看不到 K8s 相关的容器的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8s </tag>
            
            <tag> Docker Desktop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>危险！不要打开！</title>
      <link href="2020/11/01/this-is-unsafe/"/>
      <url>2020/11/01/this-is-unsafe/</url>
      
        <content type="html"><![CDATA[<p><img src="/contents/this-is-unsafe/cover.jpg" alt="隐私设置错误"></p><p>使用 Chrome 访问某些网站时可能会遇到上面的情况。</p><p>点击 <code>高级</code> 按钮，有些场景下会有继续访问该网站的链接，点击后即可继续访问；但有些时候会出现如下界面，无法继续访问：</p><p><img src="/contents/this-is-unsafe/adv.jpg" alt="高级"></p><h2 id="安全提示"><a href="#安全提示" class="headerlink" title="安全提示"></a>安全提示</h2><p><strong>除非你知道自己要访问的网站里面都包含什么，也清楚进去之后会产生什么后果，否则请立刻关闭此页面。</strong></p><p><strong>除非你知道自己要访问的网站里面都包含什么，也清楚进去之后会产生什么后果，否则请立刻关闭此页面。</strong></p><p><strong>除非你知道自己要访问的网站里面都包含什么，也清楚进去之后会产生什么后果，否则请立刻关闭此页面。</strong></p><h2 id="如何绕过"><a href="#如何绕过" class="headerlink" title="如何绕过"></a>如何绕过</h2><p>当出现如上图所示情况时，可在此页面中（点击页面空白处），录入 <code>thisisunsafe</code>，过程中不会有任何反馈，输入完毕，页面即可跳过 Chrome 的警告页，访问到网站页面。</p><h2 id="怎么不好用"><a href="#怎么不好用" class="headerlink" title="怎么不好用"></a>怎么不好用</h2><p>因为这是一个危险的行为，随时都有可能被废弃掉。</p><p>此行为包含在当前 <a href="https://github.com/chromium/chromium/tree/master" target="_blank" rel="noopener">Chromium master</a> 分支的 <a href="https://github.com/chromium/chromium/blob/master/components/security_interstitials/core/browser/resources/interstitial_large.js#L11-L29" target="_blank" rel="noopener">interstitial_large.js</a> 文件中：</p><pre><code class="js">/** * This allows errors to be skippped by typing a secret phrase into the page. * @param {string} e The key that was just pressed. */function handleKeypress(e) {  // HTTPS errors are serious and should not be ignored. For testing purposes,  // other approaches are both safer and have fewer side-effects.  // See https://goo.gl/ZcZixP for more details.  const BYPASS_SEQUENCE = window.atob(&#39;dGhpc2lzdW5zYWZl&#39;);  if (BYPASS_SEQUENCE.charCodeAt(keyPressState) === e.keyCode) {    keyPressState++;    if (keyPressState === BYPASS_SEQUENCE.length) {      sendCommand(SecurityInterstitialCommandId.CMD_PROCEED);      keyPressState = 0;    }  } else {    keyPressState = 0;  }}</code></pre><p><code>BYPASS_SEQUENCE</code> 即注释中提到的 <code>secret phrase</code>，从 console 中直接执行 <code>window.atob(&#39;dGhpc2lzdW5zYWZl&#39;)</code> 即可看到 Base64 解码后的明文：</p><pre><code class="js">&gt; window.atob(&#39;dGhpc2lzdW5zYWZl&#39;)&lt; &quot;thisisunsafe&quot;</code></pre><p>从 Chromium 的提交记录中，我们也可以看到开发人员对此方式被滥用而感到的担忧：</p><p>2014 年这个 <code>BYPASS_SEQUENCE</code> 第一次被 <a href="https://github.com/chromium/chromium/commit/476d5156284adc4958807d7db6d8b74f990e6844#diff-01324c494c7d2692f9b3d23af31da6dcf2b7dd8ca8b9b1a491bbda3b4a6736f4R25" target="_blank" rel="noopener">提交</a> 时：</p><pre><code class="js">var BYPASS_SEQUENCE = &#39;danger&#39;;</code></pre><p>2015 年专门针对此关键字进行了一次修改 <a href="https://github.com/chromium/chromium/commit/90b6605758feea9d4f2a56ad3f6992e1e868b445" target="_blank" rel="noopener">Change the interstitial bypass keyword</a>：</p><pre><code class="diff">- var BYPASS_SEQUENCE = &#39;danger&#39;;+ var BYPASS_SEQUENCE = &#39;badidea&#39;;</code></pre><p>2018 年 1 月 3 日 <a href="https://github.com/chromium/chromium/commit/cb8501aaf28904ff1e39962aaed380a1618a6222" target="_blank" rel="noopener">Change the interstitial bypass keyword</a>：</p><pre><code class="diff">- var BYPASS_SEQUENCE = &#39;badidea&#39;;+ var BYPASS_SEQUENCE = &#39;thisisnotsafe&#39;;</code></pre><p>并在提交说明中描述了这么做的意义：</p><pre><code class="text">The security interstitial bypass keyword hasn&#39;t changed in two years andawareness of the bypass has been increased in blogs and social media.Rotate the keyword to help prevent misuse.</code></pre><p>在 8 天之后再次 <a href="https://github.com/chromium/chromium/commit/d8fc089b62cd4f8d907acff6fb3f5ff58f168697" target="_blank" rel="noopener">调整</a> 此部分代码，将这个 keyword 进行了 Base64 编码以增加干扰：</p><pre><code class="diff">- var BYPASS_SEQUENCE = &#39;thisisnotsafe&#39;;+ // HTTPS errors are serious and should not be ignored. For testing purposes,+ // other approaches are both safer and have fewer side-effects.+ // See https://goo.gl/ZcZixP for more details.+ var BYPASS_SEQUENCE = window.atob(&#39;dGhpc2lzdW5zYWZl&#39;);</code></pre><p>随着时间的流逝，再次修改这个关键字也是很有可能的，所以当你看到这段文字时，上面的方法很有可能已经失效了。</p><p>如果你有不得已的苦衷，一定要绕过这个安全提示，可以尝试在安全提示页面，打开 console 直接输入：</p><pre><code class="js">&gt; sendCommand(SecurityInterstitialCommandId.CMD_PROCEED)</code></pre><h2 id="如何恢复"><a href="#如何恢复" class="headerlink" title="如何恢复"></a>如何恢复</h2><p>通过上述方式绕过安全提示之后，以后再次访问此网站时即可直接访问了。如果想恢复安全提示界面，可点击地址栏前面的 <code>不安全</code> 图标，并点击 <code>重新启用警告功能</code>，如下图：</p><p><img src="/contents/this-is-unsafe/reset.jpg" alt="重新启用警告功能"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://stackoverflow.com/questions/35274659/does-using-badidea-or-thisisunsafe-to-bypass-a-chrome-certificate-hsts-error/35275060#35275060" target="_blank" rel="noopener">Does using ‘badidea’ or ‘thisisunsafe’ to bypass a Chrome certificate/HSTS error only apply for the current site? [closed]</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Telnet 调用 Dubbo 服务</title>
      <link href="2020/10/25/dubbo-telnet/"/>
      <url>2020/10/25/dubbo-telnet/</url>
      
        <content type="html"><![CDATA[<p>当使用 <a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">Dubbo</a> 作为 RPC 框架时，有时会希望验证 provider 提供的服务是否好用，比起开发一个 consumer，可以使用自带工具来进行更快速的验证。</p><p>本文以使用 <a href="https://github.com/apache/zookeeper/tree/release-3.6.1" target="_blank" rel="noopener">ZooKeeper v3.6.1</a> 为注册中心，<a href="https://github.com/apache/dubbo-samples/tree/master/java/dubbo-samples-zookeeper" target="_blank" rel="noopener">dubbo-samples-zookeeper</a> 示例代码为例，介绍一下自 dubbo v2.0.5 版本开始支持的 telnet 命令用法。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="启动注册中心"><a href="#启动注册中心" class="headerlink" title="启动注册中心"></a>启动注册中心</h3><p>先在本地 <code>2181</code> 端口启动一个 ZooKeeper 服务，可使用示例中提供的 <a href="https://github.com/apache/dubbo-samples/blob/master/java/dubbo-samples-zookeeper/src/main/resources/docker/docker-compose.yml" target="_blank" rel="noopener">docker-compose.yml</a> 或如下内容：</p><pre><code class="yaml">version: &#39;3.3&#39;services:  zookeeper:    image: &quot;zookeeper:3.6.1&quot;    ports:      - &quot;2181:2181&quot;</code></pre><p>在 docker-compose.yml 文件所在路径执行 <code>docker-compose up -d</code> 完成服务启动，并可通过 <code>docker ps</code> 查看服务状态：</p><pre><code class="bash">$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                  NAMES651bded02416        zookeeper:3.6.1     &quot;/docker-entrypoint.…&quot;   36 minutes ago      Up 36 minutes       2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp   compose-docker_zookeeper_1</code></pre><h3 id="启动-Dubbo-Provider-服务"><a href="#启动-Dubbo-Provider-服务" class="headerlink" title="启动 Dubbo Provider 服务"></a>启动 Dubbo Provider 服务</h3><p>将 <code>dubbo-samples-zookeeper</code> 路径下内容导入 IDE，并运行 <code>ProviderBootstrap.java</code>，在 Console 中看到 <code>dubbo service started</code> 意味着服务完成启动。</p><h2 id="通过注册中心找到-provider-信息"><a href="#通过注册中心找到-provider-信息" class="headerlink" title="通过注册中心找到 provider 信息"></a>通过注册中心找到 provider 信息</h2><p>假定我们并不清楚服务发布在了哪，可以先通过注册中心，查找到所要调用的服务相关信息。</p><p>在 ZooKeeper 的运行路径中，包含了一个客户端可以查询 ZK 中信息。以前面环境为例，先进入到注册中心的容器中：</p><pre><code class="bash">$ docker exec -ti compose-docker_zookeeper_1 bash</code></pre><p>在容器内 <code>/apache-zookeeper-3.6.1-bin/bin</code> 路径下运行客户端脚本：</p><pre><code class="bash">$ ./zkCli.sh</code></pre><p>进入客户端后通过 <code>ls</code> 命令查询服务信息：</p><pre><code class="bash">[zk: localhost:2181(CONNECTED) 0] ls /dubbo/org.apache.dubbo.samples.api.GreetingService/providers[dubbo%3A%2F%2F127.0.0.1%3A20880%2Forg.apache.dubbo.samples.api.GreetingService%3Fanyhost%3Dtrue%26application%3Dzookeeper-demo-provider%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26group%3Dabc%26interface%3Dorg.apache.dubbo.samples.api.GreetingService%26methods%3DsayHello%26pid%3D10929%26release%3D2.7.7%26revision%3D1.0.0%26side%3Dprovider%26timestamp%3D1603525931278%26version%3D1.0.0]</code></pre><p>查询结果进行 URI decode 之后得到如下内容：</p><pre><code class="text">dubbo://127.0.0.1:20880/org.apache.dubbo.samples.api.GreetingService?anyhost=true&amp;application=zookeeper-demo-provider&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;group=abc&amp;interface=org.apache.dubbo.samples.api.GreetingService&amp;methods=sayHello&amp;pid=10929&amp;release=2.7.7&amp;revision=1.0.0&amp;side=provider&amp;timestamp=1603525931278&amp;version=1.0.0</code></pre><p>可以看到 dubbo 的服务运行在注册中心相同主机的 <code>20880</code> 端口。</p><h2 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h2><p>因本例中所有服务均在本地启动，可以 telnet 进 dubbo 服务中：</p><pre><code class="bash">$ telnet localhost 20880Trying ::1...Connected to localhost.Escape character is &#39;^]&#39;.dubbo&gt; helpPlease input &quot;help [command]&quot; show detail. status [-l]                      - Show status. shutdown [-t &lt;milliseconds&gt;]     - Shutdown Dubbo Application. pwd                              - Print working default service. trace [service] [method] [times] - Trace the service. exit                             - Exit the telnet. help [command]                   - Show help. invoke [service.]method(args)    - Invoke the service method. count [service] [method] [times] - Count the service. clear [lines]                    - Clear screen. ls [-l] [service]                - List services and methods. log level                        - Change log level or show log select [index]                   - Select the index of the method you want to invoke. ps [-l] [port]                   - Print server ports and connections. cd [service]                     - Change default service.</code></pre><p>查看提供的服务：</p><pre><code class="bash">dubbo&gt;lsPROVIDER:org.apache.dubbo.samples.api.GreetingService:1.0.0</code></pre><p>查看服务中方法信息：</p><pre><code class="bash">dubbo&gt;ls org.apache.dubbo.samples.api.GreetingService -lorg.apache.dubbo.samples.api.GreetingService:1.0.0 (as provider):    java.lang.String sayHello(java.lang.String)</code></pre><p>调用方法：</p><pre><code class="bash">dubbo&gt;invoke org.apache.dubbo.samples.api.GreetingService.sayHello(&#39;hinex&#39;)</code></pre><p>此时可能会遇到一个异常信息：</p><pre><code class="text">Invalid json argument, cause: com/alibaba/fastjson/JSON</code></pre><p>如果执行示例代码中的 <code>ConsumerBootstrap</code> 会发现 consumer 能正常的消费提供者的服务，并没有上述异常。此问题仅在通过 telnet 调用服务的时候出现。</p><p>可在 <a href="https://github.com/apache/dubbo-samples/blob/master/java/dubbo-samples-zookeeper/pom.xml" target="_blank" rel="noopener">pom.xml</a> 中添加 <a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">fastjson</a> 的依赖来解决此问题：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.73&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>重启 <code>ProviderBootstrap</code> 服务，并再次通过 telnet 进行调用，可得到正常的调用结果：</p><pre><code class="bash">dubbo&gt;invoke org.apache.dubbo.samples.api.GreetingService.sayHello(&#39;hinex&#39;)Use default service org.apache.dubbo.samples.api.GreetingService.result: &quot;hello, hinex&quot;elapsed: 1 ms.</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://dubbo.apache.org/zh-cn/docs/user/references/telnet.html" target="_blank" rel="noopener">Telnet 命令参考手册</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
          <category> DevOps </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Microservices </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 k8s 集群中部署第一个应用</title>
      <link href="2020/10/18/deploy-first-app-in-k8s/"/>
      <url>2020/10/18/deploy-first-app-in-k8s/</url>
      
        <content type="html"><![CDATA[<p>在 <a href="https://alphahinex.github.io/2020/10/04/install-k8s-cluster-offline-with-kubeasz/">使用 kubeasz 离线安装 k8s 集群</a> 中，我们完成了 k8s 集群的搭建，接下来，可以开始在集群中部署第一个应用了。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在集群中启动一个最简单的 nginx 服务，并能够通过 http 进行访问。</p><h2 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h2><p>回忆 docker 环境下，要实现这个目标，需要做的事情很简单，一行命令即可：</p><pre><code class="bash">$ docker run --name some-nginx -d -p 8080:80 nginx</code></pre><p>之后便可访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 看到 nginx 的欢迎页面。</p><p>也可以使用 docker-compose 配置文件来实现此目标：</p><pre><code class="yml">some-nginx:  image: nginx  ports:    - &quot;8080:80&quot;</code></pre><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>Kubernetes 官方提供了一个 <a href="https://kompose.io/" target="_blank" rel="noopener">Kompose</a> 工具，可以方便的将 Docker Compose 的配置文件转换成 k8s 所需的形式。让我们来看看官网上的例子：</p><blockquote><p>It’s as simple as 1-2-3</p></blockquote><ol><li><a href="https://raw.githubusercontent.com/kubernetes/kompose/master/examples/docker-compose-v3.yaml" target="_blank" rel="noopener">Use an example docker-compose.yaml file</a> or your own</li><li>Run kompose up</li><li>Check your Kubernetes cluster for your newly deployed containers!</li></ol><pre><code class="bash">$ wget https://raw.githubusercontent.com/kubernetes/kompose/master/examples/docker-compose-v3.yaml -O docker-compose.yaml$ kompose upWe are going to create Kubernetes Deployments, Services and PersistentVolumeClaims for your Dockerized application.If you need different kind of resources, use the &#39;kompose convert&#39; and &#39;kubectl create -f&#39; commands instead.INFO Successfully created Service: redis          INFO Successfully created Service: web            INFO Successfully created Deployment: redis       INFO Successfully created Deployment: web         Your application has been deployed to Kubernetes. You can run &#39;kubectl get deployment,svc,pods,pvc&#39; for details.$ kubectl get poNAME                            READY     STATUS              RESTARTS   AGEfrontend-591253677-5t038        1/1       Running             0          10sredis-master-2410703502-9hshf   1/1       Running             0          10sredis-slave-4049176185-hr1lr    1/1       Running             0          10s</code></pre><p>什嘛？这就结束啦？这也太快了啪？</p><p>我们还是慢慢来，自己掌握一下节奏吧。</p><p>看到 <code>kompose up</code> 下面的提示内容，我们可以通过 <code>kompose convert</code> 命令将 Docker Compose 的文件转换为 k8s 格式的内容：</p><pre><code class="bash">$ kompose convert -f docker-compose.yml</code></pre><p>转换后得到两个 yaml 文件：some-nginx-deployment.yaml 和 some-nginx-service.yaml 。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>kompose 将 docker-compose.yml 转换生成了两个 yaml 文件，一个 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Deployment</a> 和一个 <a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">Service</a>。</p><p><code>Deployment</code> 包含了创建一个容器所必须的信息，如镜像、端口、资源需求、副本数等。k8s 会依据 Deployment 中的 template 定义创建必需数量的容器。</p><p><code>Service</code> 用来将 k8s 集群中的服务暴露出来，供外部进行访问。类似在 docker 环境中映射端口至宿主机的操作。k8s 提供了四种 <a href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types" target="_blank" rel="noopener">ServiceTypes</a> 来发布服务，但实际在非云提供商大部分的 k8s 环境中，只能选择 <a href="https://kubernetes.io/docs/concepts/services-networking/service/#nodeport" target="_blank" rel="noopener">NodePort</a> 类型。指定了 <code>nodePort</code> 端口后，k8s 集群中每个节点都会将此端口代理至该 Service，不论这个 Serivce 部署在哪个节点上。Service 通过 <code>selector</code> 与 Deployment 进行关联。</p><p>查看 kompose 生成的文件内容，发现里面会包含一些 annotations 信息，以及并没有设定 ServiceType。所以在 kompose 的主页上有这样一段描述：</p><blockquote><p>Transformation of the Docker Compose format to Kubernetes resources manifest may not be exact, but it helps tremendously when first deploying an application on Kubernetes.</p></blockquote><p>可以基于 Docker Compose 文件通过转换工具自动生成基础版本，再基于基础版本进行调整，获得最终使用的版本，可参考如下配置文件 <code>nginx.yml</code>：</p><pre><code class="yaml">apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx  labels:    app: nginxspec:  selector:    matchLabels:      app: nginx  replicas: 1  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: nginx:1.17.9        resources:          requests:            cpu: 100m            memory: 100Mi        ports:        - containerPort: 80---apiVersion: v1kind: Servicemetadata:  name: nginx  labels:    app: nginxspec:  type: NodePort  ports:  - name: nginx    port: 80    nodePort: 30080  selector:    app: nginx</code></pre><p>将该配置文件应用至集群中：</p><pre><code class="bash">$ kubectl apply -f nginx.yml</code></pre><p>之后，即可通过集群中任意节点的 ip，加配置文件中 <code>nodePort</code> 指定的端口（30080），访问集群中的 nginx 服务。</p><p>配置文件参考手册可见 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/" target="_blank" rel="noopener">这里</a>。</p><h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>可对配置文件执行 delete 操作清理其中包括的资源，如：</p><pre><code class="bash">$ kubectl delete -f nginx.yml</code></pre><h2 id="可视化界面"><a href="#可视化界面" class="headerlink" title="可视化界面"></a>可视化界面</h2><p>使用 k8s 提供的命令行工具，可完成对集群的各项操作。同时也可借助可视化界面，更简便的操作集群，比如： <a href="https://kuboard.cn/" target="_blank" rel="noopener">Kuboard</a> 。</p><p><a href="http://demo.kuboard.cn/dashboard?k8sToken=eyJhbGciOiJSUzI1NiIsImtpZCI6InZ6SzVqZFNJOXZFMmxQSkhXamNBcFY4RU9FR0RvSUR5bzJIY0NwVG1zODQifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJrdWJvYXJkLXZpZXdlci10b2tlbi0yOW40cyIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJrdWJvYXJkLXZpZXdlciIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjQzMWMwNmYyLTNiNTAtNGEyMy1hYjM1LTkyNDQwNTQ2NzFkZCIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTprdWJvYXJkLXZpZXdlciJ9.kgwTa6t00gNC0vgr6HOvCqkDghPcW-jVDg-_K6WLy97ppb9jvaqVz-AxXzF7mJqXnNetbJw-8-x_L3ogSsDlTKmRucao96VA2tPKxel8pM04J8MU0ZmYgWhTJelibbxmQK3jwGM4x32bckOOvmtumcXdsBRN0z1SZ1iu4H0VoaswhfoFS4ZJKoe61xyqoDhQx4RLCVJh_-Uctd5RCcPLWFEk-BHqC8vUTy8QcRst6RIIozQdTqsv7Xs6bH6dHrHFS--eVVTH2orQdm8znuUFhlqFOOjmCIMzIlaUQC_SO9URIGYOs0jrk27N9KC0HvQ5dLgFmwyNJ0Gu7cYi23NP1A" target="_blank" rel="noopener">Kuboard 在线演示</a></p><p>Kuboard 提供了 <a href="https://hub.docker.com/r/eipwork/kuboard" target="_blank" rel="noopener">Docker 镜像</a>，可使用官方提供的 <a href="https://kuboard.cn/install/install-dashboard-offline.html#%E5%87%86%E5%A4%87kuboard-yaml%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">kuboard.yaml</a> 方便的将其部署到 k8s 集群中，进行使用。</p>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
          <category> DevOps </category>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> DevOps </tag>
            
            <tag> Cloud </tag>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS Catalina 飞不起来了？</title>
      <link href="2020/10/11/macos-catalina/"/>
      <url>2020/10/11/macos-catalina/</url>
      
        <content type="html"><![CDATA[<p>自 macOS Catalina（10.15）发布之日（2019.10.08）起，便听到了不少负面反馈，迟迟没敢进行升级。</p><p>一年之后 Catalina 已经迎来了 <code>10.15.7</code> 版本，心想也差不多稳定了，就趁国庆假期更新了一下，没想到还是</p><h2 id="翻车了！"><a href="#翻车了！" class="headerlink" title="翻车了！"></a>翻车了！</h2><p>升级过程还算顺利，但升级完之后，明显的感到了系统的卡顿，不再有起飞的感觉了，仿佛眼前的 Mac 已不再是 Mac ……</p><p>虽然我的 Mac 已经服役了五年，中间经历了电池鼓包不在召回范围，MagSafe 2 磁性接口烫得能退毛，风扇声音戴耳机都盖不住，连 U 口时 iPhone 像钟摆一样连上又断开、断开又连上无法充电，但在使用 macOS Mojave 时，起码还是不用我等它的。</p><p>升级个系统就把飞机改成在地上开有点不能接受，折腾起来。</p><h2 id="Round-1"><a href="#Round-1" class="headerlink" title="Round 1"></a>Round 1</h2><p>先通过系统自带的活动监视器（Activity monitor）查看 CPU 使用情况，占用 CPU 最多的是一个叫做 mdworker 的进程，有的时候是 mds 或 mds_stores 等，从进程后面的用户可以发现，mdworker 的用户是 <code>_spotlight</code>，也就是系统自带的 <code>聚焦搜索</code>。这些进程就是在为聚焦搜索进行索引，这个过程可能会持续几小时甚至一天半天，等索引完毕后，进程的 CPU 使用率会下降，卡顿现象也会有所缓解。对待此问题，采取的对策就是：死等！</p><h2 id="Round-2"><a href="#Round-2" class="headerlink" title="Round 2"></a>Round 2</h2><p>另外一个明显的不适来自 <a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a>，首先是不能通过 Alfred 直接打开日历、计算器等系统应用了，其次是打开应用时特别慢。开始以为是我用的 Alfred 版本比较旧，不适应新系统，更新到最新的 v4 版之后问题依旧。查看 Alfred 的 Preferences，发现在 <code>Search Scope</code> 中没有系统应用所在路径了，添加进去就可以找到了。</p><p><img src="/contents/macos-catalina/alfred.jpg" alt="alfred"></p><p>但是打开应用慢的问题依旧存在，现象是选择应用后在 Dock 中应用图标跳啊跳，跳啊跳，跳啊跳，等它跳够了心情好了的时候才会打开界面 ……</p><h2 id="Round-3"><a href="#Round-3" class="headerlink" title="Round 3"></a>Round 3</h2><p>偶然发现在不联网的时候，打开应用并不慢，在代理软件中也发现了应用在 Dock 里跳动时会有一些奇怪的请求发往 ocsp.apple.com 。在 <code>/etc/hosts</code> 里增加一条：</p><pre><code class="hosts">0.0.0.0 ocsp.apple.com</code></pre><p>之后再打开应用，迅雷不及掩耳盗铃之势！至此，Mac 又恢复了昔日指哪打哪飞一般的感觉。</p><h2 id="Round-4"><a href="#Round-4" class="headerlink" title="Round 4"></a>Round 4</h2><p>除了上述问题之外，新系统还带来了一些变化，比如：</p><ul><li>打开终端时会提示 <code>The default interactive shell is now zsh.</code></li><li>之前连接 Windows 远程桌面的应用 Remote Desktop Connection 已无法使用，可使用 Microsoft Remote Desktop 替代</li><li>Catalina 的亮点 <code>随航</code> 需要 <a href="https://support.apple.com/en-us/HT210380#systemrequirements" target="_blank" rel="noopener">2016 年以后的 MBP</a>，洗洗睡吧</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://codechina.org/2020/05/mac-update-slow/" target="_blank" rel="noopener">Mac刚升级以后会变慢是正常现象</a></li><li><a href="https://v2ex.com/t/622672" target="_blank" rel="noopener">终于解决 Catalina 打开 app 缓慢的问题</a></li><li><a href="http://macshuo.com/?p=676" target="_blank" rel="noopener">终极 Shell</a></li><li><a href="https://zhuanlan.zhihu.com/p/87527750" target="_blank" rel="noopener">老款的macbook 如何使用随航（sidecar)</a></li><li><a href="https://www.maczd.com/post/microsoft-remote-desktop-mac.html" target="_blank" rel="noopener">「Microsoft Remote Desktop 10 」适用于 Mac 的 Windows 远程桌面连接客户端</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 kubeasz 离线安装 k8s 集群</title>
      <link href="2020/10/04/install-k8s-cluster-offline-with-kubeasz/"/>
      <url>2020/10/04/install-k8s-cluster-offline-with-kubeasz/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/easzlab/kubeasz" target="_blank" rel="noopener">kubeasz</a> 将 k8s 集群的部署难度降低到了傻瓜相机的级别。<br>本文以 <a href="https://github.com/easzlab/kubeasz/tree/2.2.1" target="_blank" rel="noopener">kubeasz v2.2.1</a> 为例，介绍一下使用 kubeasz 离线安装 k8s 集群的方式。</p><h2 id="下载离线安装所需内容"><a href="#下载离线安装所需内容" class="headerlink" title="下载离线安装所需内容"></a>下载离线安装所需内容</h2><p>在一个可联网的环境，按 <a href="https://github.com/easzlab/kubeasz/blob/master/docs/setup/offline_install.md" target="_blank" rel="noopener">离线安装集群</a> 文档中内容，将所需文件都下载到本地：</p><pre><code class="bash"># 下载工具脚本 easzup，举例使用 kubeasz 版本 2.2.1$ export release=2.2.1$ curl -C- -fLO --retry 3 https://github.com/easzlab/kubeasz/releases/download/${release}/easzup$ chmod +x ./easzup# kubeasz v2.2.1 默认使用 docker 版本 `19.03.8`，k8s 版本 `1.18.3`# 如需更换版本，可使用 ./easzup -D -d 19.03.5 -k v1.18.2# 下载默认版本离线安装包$ ./easzup -D# 下载离线系统软件包$ ./easzup -P</code></pre><p>执行成功后，所有文件均已整理好放入目录 <code>/etc/ansible</code> 。</p><p>离线文件包括：</p><ul><li><code>/etc/ansible</code> 包含 kubeasz 版本为 ${release} 的发布代码</li><li><code>/etc/ansible/bin</code> 包含 k8s/etcd/docker/cni 等二进制文件</li><li><code>/etc/ansible/down</code> 包含集群安装时需要的离线容器镜像</li><li><code>/etc/ansible/down/packages</code> 包含集群安装时需要的系统基础软件</li></ul><p>离线文件不包括：</p><ul><li>管理端 ansible 安装，但可以使用 kubeasz 容器运行 ansible 脚本</li><li>其他更多 kubernetes 插件镜像</li></ul><p>为防止出现在 kubeasz 容器无法 ping 通集群中其他主机的情况，也可以考虑打包个离线安装版本的 <a href="https://www.ansible.com/" target="_blank" rel="noopener">ansible</a>，可参考如下路径组织离线安装包内容：</p><pre><code class="tree">├── ansible│   ├── PyYAML-3.10-11.el7.x86_64.rpm│   ├── ansible-2.6.18-1.el7.ans.noarch.rpm│   ├── install.sh│   ├── libyaml-0.1.4-11.el7_0.x86_64.rpm│   ├── python-babel-0.9.6-8.el7.noarch.rpm│   ├── python-backports-1.0-8.el7.x86_64.rpm│   ├── python-backports-ssl_match_hostname-3.5.0.1-1.el7.noarch.rpm│   ├── python-cffi-1.6.0-5.el7.x86_64.rpm│   ├── python-enum34-1.0.4-1.el7.noarch.rpm│   ├── python-httplib2-0.9.2-1.el7.noarch.rpm│   ├── python-idna-2.4-1.el7.noarch.rpm│   ├── python-ipaddress-1.0.16-2.el7.noarch.rpm│   ├── python-jinja2-2.7.2-4.el7.noarch.rpm│   ├── python-markupsafe-0.11-10.el7.x86_64.rpm│   ├── python-netaddr-0.7.5-9.el7.noarch.rpm│   ├── python-paramiko-2.1.1-9.el7.noarch.rpm│   ├── python-ply-3.4-11.el7.noarch.rpm│   ├── python-pycparser-2.14-1.el7.noarch.rpm│   ├── python-setuptools-0.9.8-7.el7.noarch.rpm│   ├── python-six-1.9.0-2.el7.noarch.rpm│   ├── python2-cryptography-1.7.2-2.el7.x86_64.rpm│   ├── python2-jmespath-0.9.0-3.el7.noarch.rpm│   ├── python2-pyasn1-0.1.9-7.el7.noarch.rpm│   └── sshpass-1.06-2.el7.x86_64.rpm├── easzup└── k8s-1.18.3-offline.tar</code></pre><ul><li><code>ansible/install.sh</code> 中内容为 <code>ls *.rpm |xargs -n1 rpm -ivh --nodeps</code>，可安装该路径下所有 rpm 文件</li><li><code>easzup</code> 为基于 kubeasz 2.2.1 版本内容，将安装调整为离线安装的版本，可参照 <a href="https://github.com/AlphaHinex/kubeasz" target="_blank" rel="noopener">fork 仓库</a> offline 分支内容</li><li><code>k8s-1.18.3-offline.tar</code> 为 <code>/etc/ansible</code> 内容打包</li></ul><p>以上内容打包进 <code>kubeasz-2.2.1-offline.tar</code>，作为本次安装使用的离线包。</p><p>可从百度网盘获得此离线安装包：</p><p>链接: <a href="https://pan.baidu.com/s/1xtL9EYldFrpUrANB9tBlpQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1xtL9EYldFrpUrANB9tBlpQ</a> 提取码: <code>xx2r</code></p><h2 id="部署环境准备"><a href="#部署环境准备" class="headerlink" title="部署环境准备"></a>部署环境准备</h2><p>本文使用 <a href="https://www.virtualbox.org/" target="_blank" rel="noopener">VirtualBox</a> 创建虚拟机，系统使用 <a href="http://isoredirect.centos.org/centos/7/isos/x86_64/" target="_blank" rel="noopener">CentOS 7 x86_64</a> <code>Minimal</code> 版本，1核1G 配置，网络连接方式选用 <code>桥接网卡</code>。</p><p>完成第一个虚拟机的安装后，启动并进入系统，开启网络服务：</p><pre><code class="bash"># 修改配置文件$ vi /etc/sysconfig/network-scripts/ifcfg-enp0s3</code></pre><p>找到选项 ONBOOT，默认为 <code>no</code>，将其设置为 <code>yes</code>，之后使用 <code>reboot</code> 重启。</p><p>重启后可通过 <code>ip addr</code> 命令查看 IP 地址。</p><p>完成上述配置后，可将此虚拟机作为模板，快速复制出部署集群环境所需的虚拟机。</p><h2 id="设置-hostname"><a href="#设置-hostname" class="headerlink" title="设置 hostname"></a>设置 hostname</h2><p>为方便起见，可先为每台虚拟机设置 hostname：</p><pre><code class="bash"># 设置 hostname 为 k8s-m1$ hostnamectl set-hostname k8s-m1</code></pre><h2 id="集群规划及安装"><a href="#集群规划及安装" class="headerlink" title="集群规划及安装"></a>集群规划及安装</h2><p>假设准备了四个主机：</p><ul><li>192.168.1.2</li><li>192.168.1.3</li><li>192.168.1.4</li><li>192.168.1.5</li></ul><p>选取一个主机作为安装节点，解压初始化：</p><pre><code class="bash">$ tar zxvf kubeasz-2.2.1-offline.tar &amp;&amp; cd kubeasz-2.2.1-offline$ ./easzup -S</code></pre><blockquote><p>以上命令执行完毕后，离线安装包及解压出来的路径均可以清理掉，因为所有内容已经被复制到 <code>/etc/ansible</code> 路径下了，之后使用的也是 <code>/etc/ansible</code> 路径下内容。</p></blockquote><p>安装节点执行以下命令，依次分发安装节点公钥至 k8s 集群节点（<strong><em>含安装节点</em></strong>，<strong>部署时需换为实际IP</strong>） 根据提示输入 <code>yes</code> 与节点 root 口令：</p><pre><code class="bash">$ ssh-copy-id root@192.168.1.2$ ssh-copy-id root@192.168.1.3$ ssh-copy-id root@192.168.1.4$ ssh-copy-id root@192.168.1.5</code></pre><blockquote><p>注意：ssh-copy-id 操作 <em>必须</em> 也包含安装节点本身！</p></blockquote><h3 id="AIO-All-in-One"><a href="#AIO-All-in-One" class="headerlink" title="AIO (All in One)"></a>AIO (All in One)</h3><p>单节点集群模式将主节点安装在安装节点上，可先使用此模式快速开始，之后再通过增加节点的方式扩展集群。</p><p>在确保在安装节点执行过 <code>./easzup -S</code> 及 <code>ssh-copy-id</code> 后，可使用下面命令安装单节点集群</p><pre><code class="bash">$ docker exec -it kubeasz easzctl start-aio</code></pre><h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>预先对集群进行了规划时，可按下述方式直接部署好 k8s 集群。</p><p>先复制并调整多节点配置文件：</p><pre><code class="bash">$ cp /etc/ansible/example/hosts.multi-node /etc/ansible/hosts</code></pre><p>调整配置文件内容，<code>etcd</code> 一般为奇数（建议三个，存储 k8s 节点信息及元数据）</p><pre><code class="text">[etcd]192.168.1.2 NODE_NAME=etcd1192.168.1.3 NODE_NAME=etcd2192.168.1.4 NODE_NAME=etcd3# master node(s)[kube-master]192.168.1.2# work node(s)[kube-node]192.168.1.3192.168.1.4192.168.1.5# [optional] ntp server for the cluster[chrony]192.168.1.2</code></pre><p>分发及安装各节点（在安装节点执行）</p><pre><code class="bash">$ ansible-playbook /etc/ansible/90.setup.yml</code></pre><p>等待安装完成。。。</p><blockquote><p>注意：以上所有操作均在安装节点执行即可。</p></blockquote><p>如果一切顺利，上述命令均可正常执行。之后可在集群各节点查看集群状态：</p><pre><code class="bash">$ kubectl get node</code></pre><blockquote><p>注意：非安装节点使用 <code>kubectl</code> 等命令若提示不存在，重新 ssh 登录一下即可。</p></blockquote><h3 id="管理-MASTER-节点"><a href="#管理-MASTER-节点" class="headerlink" title="管理 MASTER 节点"></a><a href="https://github.com/easzlab/kubeasz/blob/master/docs/op/op-master.md" target="_blank" rel="noopener">管理 MASTER 节点</a></h3><h4 id="增加-master-节点"><a href="#增加-master-节点" class="headerlink" title="增加 master 节点"></a>增加 master 节点</h4><p>首先配置 ssh 免密码登录新增节点，然后执行 (假设待增加节点为 192.168.1.11)：</p><pre><code class="bash"># dir: /etc/ansible/tools$ easzctl add-master 192.168.1.11</code></pre><p>之后可使用 <code>kubectl get node</code> 进行验证</p><h4 id="删除-master-节点"><a href="#删除-master-节点" class="headerlink" title="删除 master 节点"></a>删除 master 节点</h4><pre><code class="bash"># dir: /etc/ansible/tools$ easzctl del-master 192.168.1.11 # 假设待删除节点 192.168.1.11</code></pre><h3 id="管理-NODE-节点"><a href="#管理-NODE-节点" class="headerlink" title="管理 NODE 节点"></a><a href="https://github.com/easzlab/kubeasz/blob/master/docs/op/op-node.md" target="_blank" rel="noopener">管理 NODE 节点</a></h3><h4 id="增加-node-节点"><a href="#增加-node-节点" class="headerlink" title="增加 node 节点"></a>增加 node 节点</h4><p>首先配置 ssh 免密码登录新增节点，然后执行 (假设待增加节点为 192.168.1.11)：</p><pre><code class="bash"># dir: /etc/ansible/tools$ easzctl add-node 192.168.1.11</code></pre><h4 id="删除-node-节点"><a href="#删除-node-节点" class="headerlink" title="删除 node 节点"></a>删除 node 节点</h4><pre><code class="bash"># dir: /etc/ansible/tools$ easzctl del-node 192.168.1.11 # 假设待删除节点 192.168.1.11</code></pre><h3 id="管理-ETCD-节点"><a href="#管理-ETCD-节点" class="headerlink" title="管理 ETCD 节点"></a><a href="https://github.com/easzlab/kubeasz/blob/master/docs/op/op-etcd.md" target="_blank" rel="noopener">管理 ETCD 节点</a></h3><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><h3 id="master-节点重启后状态始终为-NotReady"><a href="#master-节点重启后状态始终为-NotReady" class="headerlink" title="master 节点重启后状态始终为 NotReady"></a>master 节点重启后状态始终为 NotReady</h3><p>查看 <code>journalctl -f -u kubelet</code> 提示 /etc/cni/net.d 没初始化，到路径下查看，发现内容为空，其他 Ready 的 work node 中，该路径下有 <code>10-flannel.conflist</code> 文件，且文件内容相同。<br>将此文件内容复制到 master 节点相同路径下，稍等一会后再使用 <code>kubectl get node</code> 查看节点状态就都 Ready 了。</p><h3 id="启动-kube-apiserver-服务报错"><a href="#启动-kube-apiserver-服务报错" class="headerlink" title="启动 kube-apiserver 服务报错"></a>启动 kube-apiserver 服务报错</h3><p>安装过程中遇到报错</p><pre><code class="error">fatal: [192.168.174.72]: FAILED! =&gt; {&quot;changed&quot;: true, &quot;cmd&quot;: &quot;systemctl daemon-reload &amp;&amp; systemctl restart kube-apiserver &amp;&amp; systemctl restart kube-controller-manager &amp;&amp; systemctl restart kube-scheduler&quot;, &quot;delta&quot;: &quot;0:00:00.221579&quot;, &quot;end&quot;: &quot;2020-09-28 15:21:21.710485&quot;, &quot;msg&quot;: &quot;non-zero return code&quot;, &quot;rc&quot;: 1, &quot;start&quot;: &quot;2020-09-28 15:21:21.488906&quot;, &quot;stderr&quot;: &quot;Job for kube-apiserver.service failed because the control process exited with error code. See \&quot;systemctl status kube-apiserver.service\&quot; and \&quot;journalctl -xe\&quot; for details.&quot;, &quot;stderr_lines&quot;: [&quot;Job for kube-apiserver.service failed because the control process exited with error code. See \&quot;systemctl status kube-apiserver.service\&quot; and \&quot;journalctl -xe\&quot; for details.&quot;], &quot;stdout&quot;: &quot;&quot;, &quot;stdout_lines&quot;: []}</code></pre><p>按提示通过 <code>systemctl status kube-apiserver.service</code> 看到服务启动报错时执行的命令，将命令在终端中直接执行，有具体的报错信息：</p><pre><code class="error">Error: failed to create listener: failed to listen on 127.0.0.1:8080: listen tcp 127.0.0.1:8080: bind: address already in use</code></pre><p>因为 <code>kube-apiserver</code> 默认启用 http 服务，且端口为 <code>8080</code>。可修改服务配置的命令（需修改 ansible 里的 .j2 模板 <code>/etc/ansible/roles/kube-master/templates/kube-apiserver.service.j2</code>），在 <code>ExeccStart</code> 中增加 –insecure-port 参数，指定其他端口或直接禁用（=0），如：</p><pre><code class="j2">[Unit]Description=Kubernetes API ServerDocumentation=https://github.com/GoogleCloudPlatform/kubernetesAfter=network.target[Service]ExecStart={{ bin_dir }}/kube-apiserver \  --advertise-address={{ inventory_hostname }} \  --allow-privileged=true \  --anonymous-auth=false \  --authorization-mode=Node,RBAC \{% if BASIC_AUTH_ENABLE == "yes" %}  --basic-auth-file={{ ca_dir }}/basic-auth.csv \{% endif %}  --bind-address={{ inventory_hostname }} \  --insecure-port=0 \  --client-ca-file={{ ca_dir }}/ca.pem \  --endpoint-reconciler-type=lease \  --etcd-cafile={{ ca_dir }}/ca.pem \  --etcd-certfile={{ ca_dir }}/kubernetes.pem \  --etcd-keyfile={{ ca_dir }}/kubernetes-key.pem \  --etcd-servers={{ ETCD_ENDPOINTS }} \  --kubelet-certificate-authority={{ ca_dir }}/ca.pem \  --kubelet-client-certificate={{ ca_dir }}/admin.pem \  --kubelet-client-key={{ ca_dir }}/admin-key.pem \  --kubelet-https=true \  --service-account-key-file={{ ca_dir }}/ca.pem \  --service-cluster-ip-range={{ SERVICE_CIDR }} \  --service-node-port-range={{ NODE_PORT_RANGE }} \  --tls-cert-file={{ ca_dir }}/kubernetes.pem \  --tls-private-key-file={{ ca_dir }}/kubernetes-key.pem \  --requestheader-client-ca-file={{ ca_dir }}/ca.pem \  --requestheader-allowed-names= \  --requestheader-extra-headers-prefix=X-Remote-Extra- \  --requestheader-group-headers=X-Remote-Group \  --requestheader-username-headers=X-Remote-User \  --proxy-client-cert-file={{ ca_dir }}/aggregator-proxy.pem \  --proxy-client-key-file={{ ca_dir }}/aggregator-proxy-key.pem \  --enable-aggregator-routing=true \  --v=2Restart=alwaysRestartSec=5Type=notifyLimitNOFILE=65536[Install]WantedBy=multi-user.target</code></pre><p>之后重新执行报错步骤即可。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://www.kubernetes.org.cn/7315.html" target="_blank" rel="noopener">手把手从零搭建与运营生产级的 Kubernetes 集群与 KubeSphere</a></li><li><a href="https://yuerblog.cc/2019/02/25/flannel-and-calico/" target="_blank" rel="noopener">白话 flannel 和 calico 网络原理</a></li><li><a href="http://www.dockone.io/article/4884" target="_blank" rel="noopener">Kubernetes 的三种外部访问方式：NodePort、LoadBalancer 和 Ingress</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
          <category> DevOps </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> DevOps </tag>
            
            <tag> Cloud </tag>
            
            <tag> K8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code Remote - SSH 插件</title>
      <link href="2020/09/26/vscode-remote-ssh/"/>
      <url>2020/09/26/vscode-remote-ssh/</url>
      
        <content type="html"><![CDATA[<p>在需要到服务器上编辑文件的时候，如果遇到有较多文件分散在不同目录时，使用终端工具其实挺繁琐的。</p><p>在 VS Code 中，有一个插件 <a href="https://github.com/Microsoft/vscode-remote-release" target="_blank" rel="noopener">Remote - SSH</a>，可以配置好 SSH 连接后，打开远程主机上的任意路径，之后就像使用 VS Code 操作本地文件夹一样。</p><p>官方对此插件的简介为：</p><blockquote><p>Open any folder on a remote machine using SSH and take advantage of VS Code’s full feature set.</p></blockquote><p>但实际使用时，有些场景跟操作本地文件还是有点区别的，比如全文检索时，通过 Remote - SSH 插件只能搜索已经打开过的文件。</p><p>不过总体来说还是很方便的。</p><p><img src="/contents/vscode/ssh-readme.gif" alt="ssh readme"></p><p>在 Visual Studio Code Remote Development 中，除 Remote - SSH 之外，还提供了 Remote - Containers 和 Remote - WSL，分别用来使用 VS Code 直接操作 docker 容器或 WSL (Windows Subsystem for Linux) 中的文件夹。</p><h2 id="遇上-Arm64-时"><a href="#遇上-Arm64-时" class="headerlink" title="遇上 Arm64 时"></a>遇上 Arm64 时</h2><p>当远程主机是 Arm64 架构时，也可以使用此插件，不过需要在 <a href="https://code.visualstudio.com/insiders/" target="_blank" rel="noopener">VS Code - Insiders</a> 中使用。</p><p>Insiders 版本相当于 VS Code 的内部预览版，能够更早的体验到一些新特性，更多信息可看此 <a href="https://code.visualstudio.com/blogs/2016/05/23/evolution-of-insiders" target="_blank" rel="noopener">博客</a> 内容。</p>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纳尼？休眠不能？！</title>
      <link href="2020/09/20/unable-to-hibernate/"/>
      <url>2020/09/20/unable-to-hibernate/</url>
      
        <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>CentOS 7，<code>systemctl hibernate</code> 休眠失败，按照提示使用 <code>journalctl -xe</code> 查看具体原因，得到类似如下内容的日志：</p><pre><code class="log">Feb 09 14:18:14 pike systemd[1]: Starting Sleep.Feb 09 14:18:14 pike systemd[1]: Reached target Sleep.Feb 09 14:18:14 pike systemd[1]: Starting Hibernate...Feb 09 14:18:14 pike systemd-sleep[2284]: Failed to write mode to /sys/power/disk: Operation not permittedFeb 09 14:18:14 pike systemd[1]: systemd-hibernate.service: main process exited, code=exited, status=1/FAILUREFeb 09 14:18:14 pike systemd[1]: Failed to start Hibernate.Feb 09 14:18:14 pike systemd[1]: Dependency failed for Hibernate.Feb 09 14:18:14 pike systemd[1]: Service sleep.target is not needed anymore. Stopping.Feb 09 14:18:14 pike systemd[1]: Unit systemd-hibernate.service entered failed state.Feb 09 14:18:14 pike systemd[1]: Stopping Sleep.Feb 09 14:18:14 pike systemd[1]: Stopped target Sleep.</code></pre><p>查看 <code>/sys/power/disk</code> 提示不可使用。</p><pre><code class="bash">$ cat /sys/power/disk[disabled]</code></pre><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>查找了一些资料（详见参考资料），发现是设备启用了 <code>Secure Boot</code> 导致的。</p><p>在 BIOS 设置中，进入 <code>Security</code> 或 <code>Boot</code> 等分类下，将 <code>Secure Boot</code> 关闭（<code>Enabled</code> 改为 <code>Disabled</code>）即可。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>从参考资料中了解到，<code>休眠</code>是将系统内存状态进行快照并保存到磁盘中，之后切断系统电源；在唤醒时，再将磁盘中的内存快照恢复到内存中，以恢复休眠时的状态。</p><p>而当前缺乏一种手段保证唤醒时磁盘中保存的内容跟休眠时存入的内容一致，这就产生了一定的安全隐患。</p><p>Linux 内核中包含了一种锁定（<code>lockdown</code>）模式，当内核版本支持该特性，并且检测到系统启用了 <code>Secure Boot</code> 时，会自动进入锁定模式，进而导致无法进行休眠。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://unix.stackexchange.com/questions/114889/f20-unable-to-hibernate-sys-power-disk-disabled" target="_blank" rel="noopener">F20 Unable to hibernate, /sys/power/disk disabled</a></li><li><a href="http://www.dnxtc.net/zixun/zhuangjijiaocheng/2019-08-27/4003.html" target="_blank" rel="noopener">secure boot是什么意思？secure boot功能详解和关闭secure boot方法</a></li><li><a href="https://askubuntu.com/questions/1106105/18-04-hibernate-with-uefi-and-secure-boot-enabled" target="_blank" rel="noopener">18.04 hibernate with UEFI and secure boot enabled</a></li><li><a href="https://lwn.net/Articles/750730/" target="_blank" rel="noopener">Kernel lockdown in 4.17?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH 免密登录</title>
      <link href="2020/09/13/ssh-authorized-keys/"/>
      <url>2020/09/13/ssh-authorized-keys/</url>
      
        <content type="html"><![CDATA[<p>假设 local 需要 ssh 连接到 remote，且不希望每次连接的时候都输入密码（比如从服务器 A 连到 服务器 B）。</p><h2 id="本地生成公钥私钥对"><a href="#本地生成公钥私钥对" class="headerlink" title="本地生成公钥私钥对"></a>本地生成公钥私钥对</h2><pre><code class="bash"># 在本地（local 主机）.ssh 路径生成公钥和私钥文件$ ssh-keygen -t rsa# 一路回车即可</code></pre><h2 id="将公钥复制到远程主机"><a href="#将公钥复制到远程主机" class="headerlink" title="将公钥复制到远程主机"></a>将公钥复制到远程主机</h2><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>local</p><pre><code class="bash">$ cd ~/.ssh# 查看该路径下是否有 authorized_keys 文件，如果没有：$ cp id_rsa.pub authorized_keys# 如果有：$ cat id_rsa.pub &gt;&gt; authorized_keys# 将公钥传输到 remote$ scp id_rsa.pub user@remote:/path/to/a.pub</code></pre><p>remote</p><pre><code class="bash"># 将公钥文件追加至 authorized_keys$ cat /paht/to/a.pub &gt;&gt; ~/.ssh/authorized_keys</code></pre><h3 id="或-ssh-copy-id"><a href="#或-ssh-copy-id" class="headerlink" title="或 ssh-copy-id"></a>或 ssh-copy-id</h3><pre><code class="bash">$ ssh-copy-id -i ~/.ssh/id_rsa.pub user@remote</code></pre>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为鲲鹏下可用的 Redis docker 镜像</title>
      <link href="2020/09/06/huawei-kunpeng-redis-docker-image/"/>
      <url>2020/09/06/huawei-kunpeng-redis-docker-image/</url>
      
        <content type="html"><![CDATA[<p>在华为鲲鹏服务器下，使用 Docker 时，因鲲鹏服务器使用的芯片为 ARM 架构，镜像也需要使用 ARM 版本的。</p><p>从 x86 架构拉取的镜像直接导出导入到鲲鹏服务器上是不可以直接使用的。</p><p>可以通过 <code>docker inspect IMAGE_NAME</code> 查看镜像的架构类型。</p><p>在鲲鹏服务器上重新拉取镜像，会自动下载 ARM 架构的镜像，前提是需要有提供 ARM 架构的版本，如：</p><p><img src="/contents/redis-arm-image/redis-image.png" alt="Redis Official Image"></p><p>但在鲲鹏服务器上，使用官方提供的 ARM64 版本的 Redis 镜像，启动时会报如下异常：</p><pre><code class="bash">&lt;jemalloc&gt;: Unsupported system page size</code></pre><p>从 Docker Hub 上试了一些有提供 ARM 版本的 Redis 镜像，基本都是相同的问题。唯一一个好用的镜像好像只有 Redis 4.x 的版本。</p><p>查找了一些资料，在华为云论坛上也有提到类似的问题：</p><ul><li><a href="https://bbs.huaweicloud.com/forum/thread-64268-1-1.html" target="_blank" rel="noopener">在鲲鹏上通过docker上部署redis5.0.9时报错</a></li><li><a href="https://bbs.huaweicloud.com/forum/thread-47123-1-1.html" target="_blank" rel="noopener">Centos下启动redis官方容器报错处理办法</a></li></ul><p>解决办法是需要在目标服务器上自行构建一个镜像。</p><p>为了给懒人提供一个方便，这里先提供一个已经构建好的，鲲鹏服务器上可用的 Redis 5.0.9 版本的镜像文件：<a href="https://gitee.com/AlphaHinex/trunk/blob/master/docker-library/redis/5.0/redis-kunpeng-5.0.9.tar.gz" target="_blank" rel="noopener">https://gitee.com/AlphaHinex/trunk/blob/master/docker-library/redis/5.0/redis-kunpeng-5.0.9.tar.gz</a></p><p>如需自行构建，可参考如下构建步骤。</p><h2 id="获取官方镜像的-Dockerfile"><a href="#获取官方镜像的-Dockerfile" class="headerlink" title="获取官方镜像的 Dockerfile"></a>获取官方镜像的 Dockerfile</h2><p>如：<a href="https://github.com/docker-library/redis/tree/master/5.0" target="_blank" rel="noopener">https://github.com/docker-library/redis/tree/master/5.0</a></p><h2 id="根据实际情况进行调整"><a href="#根据实际情况进行调整" class="headerlink" title="根据实际情况进行调整"></a>根据实际情况进行调整</h2><p>比如更换国内更快的 apt-get 数据源</p><pre><code class="dockerfile">RUN sed -i s@/deb.debian.org/@/mirrors.163.com/@g /etc/apt/sources.listRUN apt-get clean</code></pre><blockquote><p>阿里云的 debian 镜像中 arm 相关的包不全，可使用 163 的镜像</p></blockquote><p>如果在代理网络环境下，可以添加代理相关配置，以及网络不稳定时可提前下载好所需资源，<code>COPY</code> 到镜像中，如：</p><pre><code class="diff">10a14,17&gt;         echo &quot;Acquire::http::Proxy \&quot;http://user:pwd@proxy.com:8080\&quot;;&quot; &gt;/etc/apt/apt.conf; \&gt;         echo &quot;Acquire::https::Proxy \&quot;http://user:pwd@proxy.com:8080\&quot;;&quot; &gt;&gt;/etc/apt/apt.conf; \&gt;         export http_proxy=http://user:pwd@proxy.com:8080; \&gt;         export https_proxy=http://user:pwd@proxy.com:8080; \14,17c21,26&lt;     dpkgArch=&quot;$(dpkg --print-architecture | awk -F- &#39;{ print $NF }&#39;)&quot;; \&lt;     wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch&quot;; \&lt;     wget -O /usr/local/bin/gosu.asc &quot;https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch.asc&quot;; \&lt;     export GNUPGHOME=&quot;$(mktemp -d)&quot;; \---&gt;     dpkgArch=&quot;$(dpkg --print-architecture | awk -F- &#39;{ print $NF }&#39;)&quot;&gt;&gt; COPY gosu-arm64 /usr/local/bin/gosu&gt; COPY gosu-arm64.asc /usr/local/bin/gosu.asc&gt;&gt; RUN export GNUPGHOME=&quot;$(mktemp -d)&quot;; \35a45,48&gt;         echo &quot;Acquire::http::Proxy \&quot;http://user:pwd@proxy.com:8080\&quot;;&quot; &gt;/etc/apt/apt.conf; \&gt;         echo &quot;Acquire::https::Proxy \&quot;http://user:pwd@proxy.com:8080\&quot;;&quot; &gt;&gt;/etc/apt/apt.conf; \&gt;         export http_proxy=http://user:pwd@proxy.com:8080; \&gt;         export https_proxy=http://user:pwd@proxy.com:8080; \47c60&lt;     wget -O redis.tar.gz &quot;$REDIS_DOWNLOAD_URL&quot;; \---&gt;     wget -O redis.tar.gz &quot;$REDIS_DOWNLOAD_URL&quot; --no-check-certificate; \</code></pre><p>调整后完整的 Dockerfile 文件可见：<a href="https://gitee.com/AlphaHinex/trunk/blob/master/docker-library/redis/5.0/Dockerfile" target="_blank" rel="noopener">https://gitee.com/AlphaHinex/trunk/blob/master/docker-library/redis/5.0/Dockerfile</a></p><h2 id="执行构建"><a href="#执行构建" class="headerlink" title="执行构建"></a>执行构建</h2><p>在 Dockerfile 所在路径执行 <code>docker build -t redis-kunpeng:5.0.9 .</code>，即可构建出新的镜像。</p><blockquote><p>导出镜像为离线文件时，可使用 <code>docker save &gt; redis-kunpeng-5.0.9.tar redis-kunpeng:5.0.9</code></p></blockquote><blockquote><p>将离线镜像文件导入，可使用 <code>docker load &lt; redis-kunpeng-5.0.9.tar</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Redis </tag>
            
            <tag> Arm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联通 4G 访问 GitHub Pages 受阻肿么办？</title>
      <link href="2020/08/30/gitee-pages/"/>
      <url>2020/08/30/gitee-pages/</url>
      
        <content type="html"><![CDATA[<p>联通 4G 抽风性的无法正常访问 GitHub Pages，GitHub 有时候也抽，哥俩抽的频率还不同步。</p><p>这时候有域名和主机的朋友可以考虑架个 Nginx 反向代理一下，那没有条件的朋友们如何创造条件也要上呢？</p><p>Gitee（<a href="https://gitee.com/），是一个不错的选择，可以同步" target="_blank" rel="noopener">https://gitee.com/），是一个不错的选择，可以同步</a> GitHub Pages 仓库，并提供 Gitee Pages 功能。</p><p>注册账号后新建仓库，选择 <code>导入已有仓库</code>，点击创建，即可将 GitHub Pages 的仓库迁移到 Gitee 上来。</p><p>导入仓库之后，在服务下拉栏下选择 <code>Gitee Pages</code> 可进行相关配置。完成后即可访问 Gitee Pages 对应地址，如：<a href="https://alphahinex.gitee.io/acp" target="_blank" rel="noopener">https://alphahinex.gitee.io/acp</a></p><p><img src="/contents/gitee-pages/service.png" alt="service"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>Gitee 上的仓库若要与 GitHub 上的仓库内容保持一致，需 <strong>手动</strong> 点击 Gitee 仓库首页上的强制同步按钮</li><li>不同于 GitHub，Gitee Pages 的发布过程没找到可以查询的地方，只能跟着感觉走，页面手动刷到天长地久。经验证，在手动更新代码仓库内容之后，<strong>会</strong> 自动触发 Gitee Pages 的刷新。</li></ol><p><img src="/contents/gitee-pages/github-pages-deployments.png" alt="GitHub Pages Deployments"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子网掩码是神马</title>
      <link href="2020/08/23/subnet-mask/"/>
      <url>2020/08/23/subnet-mask/</url>
      
        <content type="html"><![CDATA[<p>在手动配置 IPv4 地址时，需要配置子网掩码，一般会是 <code>255.255.255.0</code> 这样的形式，或者在 <code>ifconfig</code> 中表示为 <code>netmask 0xffffff00</code>。那么什么是子网掩码？子网掩码为什么一般都是这样的呢？</p><h2 id="先来说说-IP-地址"><a href="#先来说说-IP-地址" class="headerlink" title="先来说说 IP 地址"></a>先来说说 IP 地址</h2><p>目前所说的 IP 地址，一般还是指 IPv4 地址。IPv4 是指长度为 32 位（4个字节）的一组数字，为方便记忆及描述，使用十进制表示，并在每个字节之间使用 <code>.</code> 间隔（点分十进制，Dotted decimal notation）。</p><p>比如 <code>127.0.0.1</code> 为 IP 地址的十进制表示，可使用二进制表示为：</p><pre><code>0111 1111 0000 0000 0000 0000 0000 0001</code></pre><p>也可使用十六进制表示为：</p><pre><code>0x7f000001</code></pre><p>为方便管理，IP 地址被进行了分类：</p><table><thead><tr><th align="left">类别</th><th align="left">High Order Bits</th><th align="left">格式</th><th align="left">主机地址范围</th></tr></thead><tbody><tr><td align="left">A类地址</td><td align="left">0</td><td align="left">网络号（7位）+ 主机号（24位）</td><td align="left">1.0.0.0 ~ 127.255.255.255</td></tr><tr><td align="left">B类地址</td><td align="left">10</td><td align="left">网络号（14位）+ 主机号（16位）</td><td align="left">128.0.0.0 ~ 191.255.255.255</td></tr><tr><td align="left">C类地址</td><td align="left">110</td><td align="left">网络号（21位）+ 主机号（8位）</td><td align="left">192.0.0.0 ~ 223.255.255.255</td></tr><tr><td align="left">D类地址</td><td align="left">1110</td><td align="left">组播地址（28位）</td><td align="left">224.0.0.0 ~ 239.255.255.255</td></tr><tr><td align="left">E类地址</td><td align="left">11110</td><td align="left">保留地址</td><td align="left">240.0.0.0 ~ 247.255.255.255</td></tr></tbody></table><p>其中 ABC 三类地址用于 TCP/IP 节点，DE 两类被用于特殊用途。</p><p>比如 <code>127.0.0.1</code> 的二进制表示首位为 <code>0</code>，所以其属于 A 类地址。</p><h2 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h2><p>为了解决标准分类的 IP 地址的有效利用率和路由器工作效率问题，子网（subnet）的概念被提出。</p><p>子网的基本思想是：允许将网络划分成多个部分供内部使用，但是对于外部网络仍然像一个网络一样。</p><p>标准的 ABC 类将 IP 地址划分为了网络号和主机号两级的层次结构。子网概念的引入，将 IP 地址划分为了三级：网络号 - 子网号 - 主机号。</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>IP 地址被划分为三级之后，一个很现实的问题就是如何从一个 IP 地址中提取出子网号，子网掩码（subnet mask）的概念顺势而生。子网掩码需与 IP 地址结合使用，根据子网掩码判断 IP 地址所在子网号。</p><p>子网掩码由连续的 1 和连续的 0 组成，比如 C 类网络地址默认的子网掩码为 <code>1111 1111 1111 1111 1111 1111 0000 0000</code>，即我们在 IP 配置中经常使用的 <code>255.255.255.0</code>。</p><p>Mask 这个词有遮罩的意思，可以将子网掩码也理解为一个遮罩。将二进制的子网掩码遮挡在二进制的 IP 地址上面，子网掩码为 <code>1</code> 的位置理解为透明的，可直接看到实际 IP 地址的二进制值，子网掩码为 <code>0</code> 的位置不透明，看到的即为子网掩码处的 <code>0</code>，得到的新的二进制的值，就代表这个 IP 地址所处的子网。前面这个过程，在二进制运算中被称为 <code>按位与</code>。</p><p>子网掩码二进制表示的特性，决定可以直接使用 <code>1</code> 的位数来描述，比如 <code>255.255.255.0</code> 中包含 24 位 <code>1</code>，一个 C 类 IP 地址加子网号的信息，可以通过 <code>192.168.31.192/24</code> 来表示。</p><p>使用子网掩码划分子网后，子网内可以通信，跨子网不能通信，子网间通信应该使用路由器，并正确配置静态路由信息。</p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alibaba Cloud Certified Expert</title>
      <link href="2020/08/16/ace/"/>
      <url>2020/08/16/ace/</url>
      
        <content type="html"><![CDATA[<p><img src="/contents/covers/ace.jpg" alt="证书"></p><p><a href="https://github.com/AlphaHinex/ACP/tree/gh-pages/raw-materials/ACE-2020%E5%B9%B47%E6%9C%88-105%E5%88%86" target="_blank" rel="noopener">2020年7月 105分 截屏</a></p><p><a href="https://alphahinex.github.io/ACP">在线练习</a></p><p><a href="https://github.com/AlphaHinex/ACP" target="_blank" rel="noopener">在线练习代码仓库</a></p><p>Base on <a href="https://github.com/BobbyBLACK/JavaScript_QUIZ" target="_blank" rel="noopener">Bobby Black’s Fork</a> of <a href="https://github.com/jrue/JavaScript-Quiz" target="_blank" rel="noopener">jrue’s JavaScript-Quiz</a></p><p>做了如下改动：</p><ol><li>支持多选题</li><li>对已掌握的题可以去除，循环答题是不会再次出现。刷新页面时题库重置</li><li>每次刷新页面随机出题顺序</li><li>增加不蒜子统计</li><li>将题目内容抽取为了单独的 js 文件，方便切换</li></ol><p>当前在线版本为 ACE 内容，可在 <a href="https://github.com/AlphaHinex/ACP/blob/gh-pages/index.html#L13" target="_blank" rel="noopener">index.html</a> 中切换 ACP（<a href="https://github.com/AlphaHinex/ACP/blob/gh-pages/quiz.js" target="_blank" rel="noopener">quiz.js</a>） 及 ACE（<a href="https://github.com/AlphaHinex/ACP/blob/gh-pages/ace.js" target="_blank" rel="noopener">ace.js</a>)。</p>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 rsync 和 cron 实现日志文件的准实时同步</title>
      <link href="2020/08/09/rsync-and-cron/"/>
      <url>2020/08/09/rsync-and-cron/</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>服务器中日志文件希望即时同步到另一个服务器中，并且能够 tail。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>通过 rsync 进行文件的同步</li><li>通过计划任务完成准实时的同步</li></ol><h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><p><a href="https://rsync.samba.org/" target="_blank" rel="noopener">rsync</a> 是一个 <a href="https://github.com/WayneD/rsync" target="_blank" rel="noopener">开源</a> 的工具，提供了快速的增量文件同步功能。包含在了 Linux 各主流发行版中。</p><p>基本用法为：<code>rsync [options] src dest</code>，支持本地及远程文件的拷贝（但不支持 src 和 dest 同时为远程地址）。</p><p>详细用法可以参考 <a href="https://rsync.samba.org/documentation.html" target="_blank" rel="noopener">官方文档</a> 或网上其他资料，如 <a href="https://cloud.tencent.com/developer/article/1114056" target="_blank" rel="noopener">rsync - Linux下进行文件同步命令</a>。</p><h3 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h3><p>cron 是 Linux 中的计划任务工具，包括 cron 守护进程和 crontab 配置文件。且 cron 的计划表达式，基本成为了各类计划任务工具的通用标准。有一个在线网站 <a href="https://crontab.guru/" target="_blank" rel="noopener">crontab guru</a> 可以清晰的了解到 cron 计划表达式的含义。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>以在本地环境同步两个文件夹为例，源文件夹为 <code>/Users/alphahinex/Desktop/app</code>，目标文件夹为 <code>/Users/alphahinex/Desktop/sync</code>。</p><p>可通过如下命令完成一次两个文件夹的同步。</p><pre><code class="bash">$ rsync -r /Users/alphahinex/Desktop/app /Users/alphahinex/Desktop/sync</code></pre><p>假设在 app 路径下有一个持续输出的日志文件 <code>app.log</code>，通过执行上述命令，<code>app.log</code> 文件被同步到了目标路径下，Well Done！</p><p>不过等一下，我们 <code>tail -f /Users/alphahinex/Desktop/sync/app.log</code> 时，会发现，目标路径下的日志文件并没有持续刷新，即使我们不停的手动执行上面的 rsync 命令也不行。</p><p>在 rsync 命令后面增加 <code>-v</code> 参数，可以看到每次同步时，整个日志文件都被进行了传输。默认情况下，rsync 在发现文件发生变化时，会将目标位置的旧文件删除掉，并将源位置的新文件发送过去。</p><p>这就会导致我们的 tail 始终是一个内容不变的文件。那么想让目标路径的日志文件也能被 tail 时该怎么办呢？</p><h3 id="tail-目标路径日志文件，内容不变"><a href="#tail-目标路径日志文件，内容不变" class="headerlink" title="tail 目标路径日志文件，内容不变"></a>tail 目标路径日志文件，内容不变</h3><p>查看 <a href="https://rsync.samba.org/documentation.html" target="_blank" rel="noopener">官方文档</a>，我们发现这样一组参数：</p><pre><code class="text">--append  This special copy mode only works to efficiently update files that are known to be growing larger where any existing content on the receiving side is also known to be the same as the content on the sender. The use of --append can be dangerous if you aren&#39;t 100% sure that all the files in the transfer are shared, growing files. You should thus use filter rules to ensure that you weed out any files that do not fit this criteria.  Rsync updates these growing file in-place without verifying any of the existing content in the file (it only verifies the content that it is appending). Rsync skips any files that exist on the receiving side that are not shorter than the associated file on the sending side (which means that new files are trasnferred).  This does not interfere with the updating of a file&#39;s non-content attributes (e.g. permissions, ownership, etc.) when the file does not need to be transferred, nor does it affect the updating of any directories or non-regular files.--append-verify  This special copy mode works like --append except that all the data in the file is included in the checksum verification (making it much less efficient but also potentially safer). This option can be dangerous if you aren&#39;t 100% sure that all the files in the transfer are shared, growing files. See the --append option for more details.  Note: prior to rsync 3.0.0, the --append option worked like --append-verify, so if you are interacting with an older rsync (or the transfer is using a protocol prior to 30), specifying either append option will initiate an --append-verify transfer.</code></pre><p>大意就是，可以通过增加 <code>--append</code> 参数来实现文件的增量传输。当需要验证所有文件内容（未传输部分）时，可以使用 <code>--append-verify</code> 参数。</p><p>对于我们的场景，<code>--append</code> 参数即可满足需求，调整后的同步命令变为了：</p><pre><code class="bash">$ rsync -r --append /Users/alphahinex/Desktop/app /Users/alphahinex/Desktop/sync</code></pre><p>此时再去 tail 目标路径日志文件，发现在执行同步命令后，更新的日志文件内容会显示到 tail 中。</p><p>由于对实时性要求不是很高，所以每秒同步一次就可以了。让计划任务每秒执行一次上述命令不就好了吗？</p><h3 id="cron-表达式的最小粒度是分钟-orz"><a href="#cron-表达式的最小粒度是分钟-orz" class="headerlink" title="cron 表达式的最小粒度是分钟 orz"></a>cron 表达式的最小粒度是分钟 orz</h3><p>理想总是很丰满。cron 表达式 <code>* * * * *</code> 是 <code>分钟 小时 日 月 星期几</code>，也就是说最快也只能每分钟执行一次。</p><p>这个时候可以采用一些变通方案，来使得 cron 支持每秒执行一次，比如写一个简单的脚本 <code>sync.sh</code></p><pre><code class="bash">#!/bin/bashfor((i=0;i&lt;60;i++));dorsync -r --append /Users/alphahinex/Desktop/app/ /Users/alphahinex/Desktop/sync/sleep 1done</code></pre><p>这个脚本的作用是，每次执行一次同步命令后，休眠 1 秒，执行 60 次。这样就变相实现了每秒执行一次同步指令。再通过 <code>crontab -e</code> 进行计划任务的配置，如：</p><pre><code class="crontab">* * * * * /Users/alphahinex/Desktop/app/sync.sh</code></pre><p>即实现了本次的需求。</p><blockquote><p>注意 crontab 调整过后不会马上生效，稍等一会即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat 是怎么找到用来处理请求的 Servlet 的？</title>
      <link href="2020/08/02/how-request-find-servlet/"/>
      <url>2020/08/02/how-request-find-servlet/</url>
      
        <content type="html"><![CDATA[<p>在 <a href="https://alphahinex.github.io/2020/04/30/where-are-servlets/">Servlet 注册到了哪？</a> 中，我们找到了配置的 Servlet 被包装成了一个 <code>StandardWrapper</code>，以注册的 Servlet name 为 key 放入了其父容器（Context）一个 HashMap 里。那么当 Tomcat 收到一个请求的时候，是怎么找到对应的 Servlet 以对请求进行处理的呢？</p><p>先放一张图：</p><p><img src="/contents/how-request-find-servlet/tomcat-server.png" alt="Tomcat Server"></p><p>总的来说，这个过程分为两部分：</p><ol><li>读取所有 Servlet 的配置，放入 Mapper 中；</li><li>将请求匹配到具体的 Servlet 上。</li></ol><blockquote><p>注：本文以 <a href="https://github.com/apache/tomcat/tree/9.0.35" target="_blank" rel="noopener">Tomcat v9.0.35</a> 版本源码为例进行说明。</p></blockquote><h2 id="读取所有-Servlet-的配置，放入-Mapper-中"><a href="#读取所有-Servlet-的配置，放入-Mapper-中" class="headerlink" title="读取所有 Servlet 的配置，放入 Mapper 中"></a>读取所有 Servlet 的配置，放入 Mapper 中</h2><p>在 Tomcat <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/Server.java" target="_blank" rel="noopener">Server</a> 启动时，会将其所包含的所有 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/Service.java" target="_blank" rel="noopener">Service</a> 也一同启动。</p><p><a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/core/StandardServer.java#L927-L932" target="_blank" rel="noopener">StandardServer.java#L927-L932</a>：</p><pre><code class="java">// Start our defined Servicessynchronized (servicesLock) {    for (Service service : services) {        service.start();    }}</code></pre><p>每个 Service <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/Service.java#L151" target="_blank" rel="noopener">对应一个 Mapper</a>，<a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java" target="_blank" rel="noopener">Mapper</a> 是本文的主角，包含了 Servlet 的映射信息。在 Service 启动时，会同时启动一个 mapperListener。</p><p><a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/core/StandardService.java#L431" target="_blank" rel="noopener">StandardService.java#L431</a>：</p><pre><code class="java">mapperListener.start();</code></pre><p><a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/MapperListener.java" target="_blank" rel="noopener">MapperListener</a> 可以 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/core/StandardService.java#L105" target="_blank" rel="noopener">通过 Service 来构造</a>，里面包含了这个 Service 以及 Service 中的 Mapper。</p><p>MapperListener 在 start 时，会获取 Service 对应的 Engine，并将 Engine 中的所有 Host 进行注册。</p><p><a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/MapperListener.java#L94-L116" target="_blank" rel="noopener">MapperListener.java#L94-L116</a>：</p><pre><code class="java">@Overridepublic void startInternal() throws LifecycleException {    setState(LifecycleState.STARTING);    Engine engine = service.getContainer();    if (engine == null) {        return;    }    findDefaultHost();    addListeners(engine);    Container[] conHosts = engine.findChildren();    for (Container conHost : conHosts) {        Host host = (Host) conHost;        if (!LifecycleState.NEW.equals(host.getState())) {            // Registering the host will register the context and wrappers            registerHost(host);        }    }}</code></pre><p>registerHost 中会注册其中的 Context。</p><p><a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/MapperListener.java#L305-L309" target="_blank" rel="noopener">MapperListener.java#L305-L309</a>：</p><pre><code class="java">for (Container container : host.findChildren()) {    if (container.getState().isAvailable()) {        registerContext((Context) container);    }}</code></pre><p>registerContext 时，将 Context 中的 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/Wrapper.java" target="_blank" rel="noopener">Wrapper</a>（包含一个 Servlet） 包装成 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/WrapperMappingInfo.java" target="_blank" rel="noopener">WrapperMappingInfo</a>，</p><p><a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/MapperListener.java#L381-L390" target="_blank" rel="noopener">MapperListener.java#L381-L390</a>：</p><pre><code class="java">List&lt;WrapperMappingInfo&gt; wrappers = new ArrayList&lt;&gt;();for (Container container : context.findChildren()) {    prepareWrapperMappingInfo(context, (Wrapper) container, wrappers);    if(log.isDebugEnabled()) {        log.debug(sm.getString(&quot;mapperListener.registerWrapper&quot;,                container.getName(), contextPath, service));    }}</code></pre><p>并进行了如下操作。</p><p><a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/MapperListener.java#L392-L394" target="_blank" rel="noopener">MapperListener.java#L392-L394</a>：</p><pre><code class="java">mapper.addContextVersion(host.getName(), host, contextPath,        context.getWebappVersion(), context, welcomeFiles, resources,        wrappers);</code></pre><p><a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L262" target="_blank" rel="noopener">addContextVersion</a> 方法根据 Context 创建了一个 ContextVersion 对象，并通过 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L443" target="_blank" rel="noopener">addWrappers</a> 及 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L463" target="_blank" rel="noopener">addWrapper</a> 方法将 WrapperMappingInfo 中的 Wrapper 及相关信息，添加进 ContextVersion 里。</p><p><a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L1709" target="_blank" rel="noopener">ContextVersion</a> 是 Mapper 中定义的内部类，包含了如下属性：</p><p><a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L1714-L1717" target="_blank" rel="noopener">Mapper.java#L1714-L1717</a>：</p><pre><code class="java">public MappedWrapper defaultWrapper = null;public MappedWrapper[] exactWrappers = new MappedWrapper[0];public MappedWrapper[] wildcardWrappers = new MappedWrapper[0];public MappedWrapper[] extensionWrappers = new MappedWrapper[0];</code></pre><p>分别对应按 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L467-L514" target="_blank" rel="noopener">如下方式</a> 匹配的 Servlet：</p><table><thead><tr><th align="left">prop</th><th align="left">url mapping</th></tr></thead><tbody><tr><td align="left">defaultWrapper</td><td align="left"><code>/</code></td></tr><tr><td align="left">exactWrappers</td><td align="left">完全匹配</td></tr><tr><td align="left">wildcardWrappers</td><td align="left">以 <code>/*</code> 结尾</td></tr><tr><td align="left">extensionWrappers</td><td align="left">以 <code>*.</code> 开头</td></tr></tbody></table><p><code>addContextVersion</code> 方法将构造好的 ContextVersion 对象，放入 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L76" target="_blank" rel="noopener">contextObjectToContextVersionMap</a> 中备用。</p><pre><code class="java">contextObjectToContextVersionMap.put(context, newContextVersion);</code></pre><p><a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L72-L77" target="_blank" rel="noopener">Mapper.java#L72-L77</a>：</p><pre><code class="java">/** * Mapping from Context object to Context version to support * RequestDispatcher mappings. */private final Map&lt;Context, ContextVersion&gt; contextObjectToContextVersionMap =        new ConcurrentHashMap&lt;&gt;();</code></pre><p>并同时将 ContextVersion 放入 Mapper 里的 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L62" target="_blank" rel="noopener">MappedHost[] hosts</a> 的 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L1586" target="_blank" rel="noopener">ContextList contextList</a> 的 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L1661" target="_blank" rel="noopener">MappedContext[] contexts</a> 里。</p><p><a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L289-L315" target="_blank" rel="noopener">Mapper.java#L289-L315</a></p><pre><code class="java">ContextList contextList = mappedHost.contextList;MappedContext mappedContext = exactFind(contextList.contexts, path);if (mappedContext == null) {    mappedContext = new MappedContext(path, newContextVersion);    ContextList newContextList = contextList.addContext(            mappedContext, slashCount);    if (newContextList != null) {        updateContextList(mappedHost, newContextList);        contextObjectToContextVersionMap.put(context, newContextVersion);    }} else {    ContextVersion[] contextVersions = mappedContext.versions;    ContextVersion[] newContextVersions = new ContextVersion[contextVersions.length + 1];    if (insertMap(contextVersions, newContextVersions,            newContextVersion)) {        mappedContext.versions = newContextVersions;        contextObjectToContextVersionMap.put(context, newContextVersion);    } else {        // Re-registration after Context.reload()        // Replace ContextVersion with the new one        int pos = find(contextVersions, version);        if (pos &gt;= 0 &amp;&amp; contextVersions[pos].name.equals(version)) {            contextVersions[pos] = newContextVersion;            contextObjectToContextVersionMap.put(context, newContextVersion);        }    }}</code></pre><p><strong>至此，所有根据请求匹配到具体 Servlet 的准备工作都已完成。</strong></p><h2 id="将请求匹配到具体的-Servlet-上"><a href="#将请求匹配到具体的-Servlet-上" class="headerlink" title="将请求匹配到具体的 Servlet 上"></a>将请求匹配到具体的 Servlet 上</h2><p>先放一张官网的 <a href="http://tomcat.apache.org/tomcat-9.0-doc/architecture/requestProcess/request-process.png" target="_blank" rel="noopener">图片</a></p><p><img src="/contents/how-request-find-servlet/request-process.png" alt="Apache Tomcat 9 Architecture Request Process Flow"></p><p>链接虽然是在 Tomcat 9.0 的文档中，但图片中的内容有些已经过时了，比如 <a href="https://github.com/apache/tomcat/blob/8.5.x/java/org/apache/coyote/http11/Http11Protocol.java#L24" target="_blank" rel="noopener">Http11Protocol 在 9.0 中已经移除了</a>。</p><p>对上面流程简单分下组：</p><p><img src="/contents/how-request-find-servlet/request-process-pkg.jpg" alt="Apache Tomcat 9 Architecture Request Process Flow with group"></p><p>可以看到，整个流程涉及到的类大致分布在 <code>tomcat</code>、<code>coyote</code> 和 <code>catalina</code> 三个包下。</p><p>在 tomcat 9.0.35 版本中，org.apache 包下面共有 <a href="https://github.com/apache/tomcat/tree/9.0.35/java/org/apache" target="_blank" rel="noopener">七个包</a>：</p><pre><code class="text">├── catalina├── coyote├── el├── jasper├── juli├── naming└── tomcat</code></pre><p><code>org.apache.tomcat</code> 包下为网络、线程、连接池、WebSocket 及一些工具类。其余各包作用可见下图：</p><p><img src="/contents/how-request-find-servlet/components.png" alt="Components"></p><p>CoyoteAdapter 的 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/connector/CoyoteAdapter.java#L567" target="_blank" rel="noopener">postParseRequest</a> 方法中，根据 connector 找到了其对应的 Service，进而找到 Service 对应的 Mapper，并进行了 map 操作。</p><pre><code class="java">// This will map the the latest version by defaultconnector.getService().getMapper().map(serverName, decodedURI,        version, request.getMappingData());</code></pre><p>map 方法根据请求找到对应的 MappedHost 的 MappedConext，进而找到之前放入的 ContextVersion，详细过程可见 Mapper 中的 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L736" target="_blank" rel="noopener">internalMap</a> 方法。</p><p>在 <code>internalMap</code> 方法中，会调用 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L862" target="_blank" rel="noopener">internalMapWrapper</a> 方法进行 Wrapper 的 Mapping，会根据不同的规则，匹配 ContextVersion 中不同的 MappedWrapper，并将匹配到的 Wrapper 放入 request 的 MappingData 中。比如 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L1093" target="_blank" rel="noopener">internalMapWildcardWrapper</a> 里 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/mapper/Mapper.java#L1134" target="_blank" rel="noopener">1134</a> 行：</p><pre><code class="java">mappingData.wrapper = wrappers[pos].object;</code></pre><p>随后在 StandardContextValve 的 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/core/StandardContextValve.java#L62" target="_blank" rel="noopener">invoke</a> 方法中，便可通过 <a href="https://github.com/apache/tomcat/blob/9.0.35/java/org/apache/catalina/core/StandardContextValve.java#L76" target="_blank" rel="noopener">request.getWrapper()</a> 获取到请求对应的 Wrapper。之后的流程与上面时序图中的过程就基本一致了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/17a236e1b04a" target="_blank" rel="noopener">Tomcat请求处理流程</a></li><li><a href="https://blog.csdn.net/wangchengsi/article/details/2973012" target="_blank" rel="noopener">Tomcat连接器：Coyote框架</a></li><li><a href="https://www.cnblogs.com/earendil/p/6834738.html" target="_blank" rel="noopener">Tomcat 组件介绍</a></li><li><a href="https://www.cnblogs.com/cenyu/p/11072543.html" target="_blank" rel="noopener">Tomcat组件梳理–Catalina</a></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>附两张手稿</p><p><img src="/contents/how-request-find-servlet/init.jpg" alt="初始化"></p><p><img src="/contents/how-request-find-servlet/map.jpg" alt="匹配"></p>]]></content>
      
      
      <categories>
          
          <category> Tomcat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> Java </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么应该设置 com.sun.management.jmxremote.rmi.port？</title>
      <link href="2020/07/26/why-should-set-jmxremote-rmi-port/"/>
      <url>2020/07/26/why-should-set-jmxremote-rmi-port/</url>
      
        <content type="html"><![CDATA[<p>在使用 JMX 对 Java 应用进行监控时，一般会在启动时添加如下参数：</p><pre><code class="bash">java \-Djava.rmi.server.hostname=192.168.16.237 \-Dcom.sun.management.jmxremote.rmi.port=2909 \-Dcom.sun.management.jmxremote.port=9009 \-Dcom.sun.management.jmxremote.authenticate=false \-Dcom.sun.management.jmxremote.ssl=false \-jar test.jar</code></pre><p>后三个参数在 Oracle 官方文档 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html" target="_blank" rel="noopener">Monitoring and Management Using JMX Technology</a> 中均有描述，但前两个参数直到 <a href="https://docs.oracle.com/javase/9/management/monitoring-and-management-using-jmx-technology.htm#JSMGM-GUID-805517EC-2D33-4D61-81D8-4D0FA770D1B8" target="_blank" rel="noopener">JDK9 版本的文档</a> 中才有所提及。</p><p><code>java.rmi.server.hostname</code> 为需要远程连接时必须设置的参数，否则只能从本地对应用进行监控，无法从远程机器进行连接。</p><p>那么 <code>com.sun.management.jmxremote.rmi.port</code> 这个参数指定的端口是干什么用的呢？</p><p>按上面启动命令所示，使用 jmx 进行连接的时候使用的是 <code>com.sun.management.jmxremote.port</code> 参数指定的端口，<code>com.sun.management.jmxremote.rmi.port</code> 这个参数去掉好像也没什么影响，依然能够进行远程连接，那么为什么还要设置这个参数呢？</p><p>先来看一下 <a href="https://docs.oracle.com/javase/9/management/monitoring-and-management-using-jmx-technology.htm#JSMGM-GUID-805517EC-2D33-4D61-81D8-4D0FA770D1B8" target="_blank" rel="noopener">官方文档</a> 中关于这个参数为数不多的描述：</p><blockquote><p>To enable monitoring and management from remote systems, you must set the following system property when you start the Java VM:</p><pre><code>com.sun.management.jmxremote.port=portNum</code></pre><p>Where, portNum is the port number to enable JMX RMI connections. Ensure that you specify an unused port number. In addition to publishing an RMI connector for local access, setting this property publishes an additional RMI connector in a private read-only registry at the specified port using the name, jmxrmi. The port number to which the RMI connector will be bound using the system property:</p><pre><code>com.sun.management.jmxremote.rmi.port</code></pre><p>Ensure to use an unused port number.</p></blockquote><p>大意为，使用 <code>com.sun.management.jmxremote.port</code> 指定端口后，除了在这个端口上会创建一个 RMI 连接器之外，还会额外创建另一个连接器，而这个额外创建的连接器的端口，就可以通过 <code>com.sun.management.jmxremote.rmi.port</code> 参数来指定。</p><p>这个额外连接器的端口，在我们进行监控的时候并没有使用到，而且不进行指定也会随机使用一个端口，那为什么还要指定呢？</p><h2 id="一探究竟"><a href="#一探究竟" class="headerlink" title="一探究竟"></a>一探究竟</h2><p>让我们使用 docker 来模拟一个网络访问受限的环境，看一看这个参数的影响。</p><h3 id="准备-Java-应用"><a href="#准备-Java-应用" class="headerlink" title="准备 Java 应用"></a>准备 Java 应用</h3><p>先准备一个用来监控的 Java 应用。比如可以从 <a href="https://github.com/AlphaHinex/spring-roll" target="_blank" rel="noopener">https://github.com/AlphaHinex/spring-roll</a> 通过 <code>./gradlew bootJar</code>，在 <code>modules/roll-application/build/libs</code> 路径获得一个 Spring Boot 的 Fat Jar。</p><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>然后在 Java 应用路径，创建一个 <code>docker-compose.yml</code> 文件，内容参考如下：</p><pre><code class="yml">jmx:  image: openjdk:8u171-jre  volumes:    - ./roll.jar:/opt/jmx/roll.jar  command: java -Djava.rmi.server.hostname=192.168.16.237 -Dcom.sun.management.jmxremote.port=9009 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -jar /opt/jmx/roll.jar  ports:    - &quot;9009:9009&quot;</code></pre><h3 id="仅指定及开放-jmxremote-port"><a href="#仅指定及开放-jmxremote-port" class="headerlink" title="仅指定及开放 jmxremote.port"></a>仅指定及开放 jmxremote.port</h3><p>按照上述 <code>docker-compose.yml</code> 内容，执行 <code>docker-compose up jmx</code>，之后使用 <code>jvisualvm</code>、<code>jconsole</code> 等工具，连接 9009 端口，会发现无法正常进行连接。</p><h3 id="指定并开放-rmi-port"><a href="#指定并开放-rmi-port" class="headerlink" title="指定并开放 rmi.port"></a>指定并开放 rmi.port</h3><p>将 <code>docker-compose.yml</code> 调整为如下内容：</p><pre><code class="yml">jmx:  image: openjdk:8u171-jre  volumes:    - ./roll.jar:/opt/jmx/roll.jar  command: java -Djava.rmi.server.hostname=192.168.16.237 -Dcom.sun.management.jmxremote.rmi.port=2909 -Dcom.sun.management.jmxremote.port=9009 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -jar /opt/jmx/roll.jar  ports:    - &quot;9009:9009&quot;    - &quot;2909:2909&quot;</code></pre><p>此时在通过 JMX 连接 9009 端口，会发现可以正常的进行监控了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当存在防火墙等网络访问限制时，可通过 <code>com.sun.management.jmxremote.rmi.port</code> 参数指定 RMI 连接器所使用的端口并进行开放。<strong>在这种场景下，必须设置此参数。</strong></p><p>另外，<code>com.sun.management.jmxremote.rmi.port</code> 使用的端口，可以与 <code>com.sun.management.jmxremote.port</code> 指定的端口相同，这样仅开放一个端口就可以了，比如：</p><pre><code class="yml">jmx:  image: openjdk:8u171-jre  volumes:    - ./roll.jar:/opt/jmx/roll.jar  command: java -Djava.rmi.server.hostname=192.168.16.237 -Dcom.sun.management.jmxremote.rmi.port=9009 -Dcom.sun.management.jmxremote.port=9009 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -jar /opt/jmx/roll.jar  ports:    - &quot;9009:9009&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谁动了我的异常 Plus</title>
      <link href="2020/07/19/undeclared-throwable-exception-plus/"/>
      <url>2020/07/19/undeclared-throwable-exception-plus/</url>
      
        <content type="html"><![CDATA[<p>书接上文，在 <a href="https://alphahinex.github.io/2020/06/26/undeclared-throwable-exception/">谁动了我的异常？</a> 中，有几个问题没说清楚，本文将继续进行说明。<br>为了方便，相关示例代码上传至了 <a href="https://github.com/AlphaHinex/proxy-in-spring" target="_blank" rel="noopener">https://github.com/AlphaHinex/proxy-in-spring</a> 。</p><h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h2><p>示例代码中，定义了如下内容：</p><ul><li>一个检查型异常：<a href="https://github.com/AlphaHinex/proxy-in-spring/blob/master/src/main/java/io/github/alphahinex/proxyinspring/CheckedException.java" target="_blank" rel="noopener">CheckedException</a></li><li>一个统一的异常处理：<a href="https://github.com/AlphaHinex/proxy-in-spring/blob/master/src/main/java/io/github/alphahinex/proxyinspring/UnifyHandlerExceptionResolver.java" target="_blank" rel="noopener">UnifyHandlerExceptionResolver</a></li><li>一个切面 <a href="https://github.com/AlphaHinex/proxy-in-spring/blob/master/src/main/java/io/github/alphahinex/proxyinspring/ControllerAspect.java" target="_blank" rel="noopener">ControllerAspect</a>，在切面中固定抛出检查型异常</li></ul><p>在 <a href="https://github.com/AlphaHinex/proxy-in-spring/blob/master/src/main/java/io/github/alphahinex/proxyinspring/ClassController.java" target="_blank" rel="noopener">ClassController</a> 中定义了一个没有声明异常的方法 <code>post</code>。</p><p>在 <a href="https://github.com/AlphaHinex/proxy-in-spring/blob/master/src/test/groovy/io/github/alphahinex/proxyinspring/ProxyTest.groovy#L16" target="_blank" rel="noopener">ProxyTest</a> 中调用此方法时，会得到一个 <a href="https://github.com/AlphaHinex/proxy-in-spring/blob/master/src/test/groovy/io/github/alphahinex/proxyinspring/ProxyTest.groovy#L16" target="_blank" rel="noopener">UndeclaredThrowableException</a>。</p><h2 id="Puzzle-1"><a href="#Puzzle-1" class="headerlink" title="Puzzle 1"></a>Puzzle 1</h2><p>那么在上述情况下，如果在 post 方法上声明了抛出检查型异常时，会怎么样？</p><pre><code class="java">@PostMapping(&quot;/throws&quot;)public ResponseEntity&lt;String&gt; postWithThrows() throws CheckedException {    return new ResponseEntity&lt;&gt;(&quot;success from class controller with throws&quot;, HttpStatus.CREATED);}</code></pre><p>此时在 <code>ProxyTest</code> 中进行调用时，可以看到正常捕获到了 <a href="https://github.com/AlphaHinex/proxy-in-spring/blob/master/src/test/groovy/io/github/alphahinex/proxyinspring/ProxyTest.groovy#L22" target="_blank" rel="noopener">CheckedException</a>。</p><p>这是为什么呢？</p><p>在 DefaultGeneratorStrategy.java#L26 处加断点，可以获得到此时的字节码，使用 IDEA 反编译之后，可得到如下内容：</p><pre><code class="java">public final ResponseEntity postWithThrows() throws CheckedException {    try {        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;        if (var10000 == null) {            CGLIB$BIND_CALLBACKS(this);            var10000 = this.CGLIB$CALLBACK_0;        }        return var10000 != null ? (ResponseEntity)var10000.intercept(this, CGLIB$postWithThrows$1$Method, CGLIB$emptyArgs, CGLIB$postWithThrows$1$Proxy) : super.postWithThrows();    } catch (Error | CheckedException | RuntimeException var1) {        throw var1;    } catch (Throwable var2) {        throw new UndeclaredThrowableException(var2);    }}</code></pre><p>可以看到，声明了的异常，在被捕获之后又被抛了出去。其余的 Throwable，会被封装到 UndeclaredThrowableException 中再被抛出。</p><h2 id="Puzzle-2"><a href="#Puzzle-2" class="headerlink" title="Puzzle 2"></a>Puzzle 2</h2><p>相同情况下，如果代理类是通过 JDK 动态代理创建的，又会是怎么样的呢？</p><p>首先，如果希望使用 JDK 动态代理，需要使被代理类实现接口，如 <a href="https://github.com/AlphaHinex/proxy-in-spring/blob/master/src/main/java/io/github/alphahinex/proxyinspring/InterfaceOfController.java" target="_blank" rel="noopener">InterfaceOfController</a> 和 <a href="https://github.com/AlphaHinex/proxy-in-spring/blob/master/src/main/java/io/github/alphahinex/proxyinspring/InterfaceController.java" target="_blank" rel="noopener">InterfaceController</a>。</p><pre><code class="java">@RestController@RequestMapping(&quot;/interface&quot;)public class InterfaceController implements InterfaceOfController {    @Override    @PostMapping    public ResponseEntity post() {        return new ResponseEntity&lt;&gt;(&quot;success from interface controller&quot;, HttpStatus.CREATED);    }    @Override    @PostMapping(&quot;/throws&quot;)    public ResponseEntity&lt;String&gt; postWithThrows() throws CheckedException {        return new ResponseEntity&lt;&gt;(&quot;success from interface controller with throws&quot;, HttpStatus.CREATED);    }}</code></pre><blockquote><p>注意：此时需要将 spring web 的注解（@RequestMapping 等）同时写在接口及实现上，否则会找不到对应的接口。</p></blockquote><p>然后在 Spring Boot 应用下，要注意指定 <a href="https://github.com/AlphaHinex/proxy-in-spring/blob/master/src/test/resources/application.properties#L1" target="_blank" rel="noopener">如下参数</a>，否则会强制使用 Cglib：</p><pre><code class="properties">spring.aop.proxy-target-class=false</code></pre><p>可参照 <a href="https://github.com/AlphaHinex/proxy-in-spring/blob/master/src/test/groovy/io/github/alphahinex/proxyinspring/ProxyTest.groovy#L39" target="_blank" rel="noopener">这里</a> 基于接口创建 JDK 动态代理，并输出字节码，观察代理类中相应方法情况。其中关键部分如下：</p><pre><code class="java">public final ResponseEntity post() throws  {    try {        return (ResponseEntity)super.h.invoke(this, m3, (Object[])null);    } catch (RuntimeException | Error var2) {        throw var2;    } catch (Throwable var3) {        throw new UndeclaredThrowableException(var3);    }}</code></pre><pre><code class="java">public final ResponseEntity postWithThrows() throws CheckedException {    try {        return (ResponseEntity)super.h.invoke(this, m4, (Object[])null);    } catch (RuntimeException | CheckedException | Error var2) {        throw var2;    } catch (Throwable var3) {        throw new UndeclaredThrowableException(var3);    }}</code></pre><p>可以看到情况与使用 Cglib 时基本一致：</p><ul><li>未声明异常时，除 <code>RuntimeException</code> 和 <code>Error</code> 外，其余 <code>Throwable</code> 都被封装进了 <code>UndeclaredThrowableException</code> 再抛出；</li><li>当声明异常时，声明了的异常也会被直接抛出，不进行封装。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么不建议使用双括号初始化？</title>
      <link href="2020/07/12/why-does-not-suggest-to-use-double-brace-initialization/"/>
      <url>2020/07/12/why-does-not-suggest-to-use-double-brace-initialization/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是双括号初始化？"><a href="#什么是双括号初始化？" class="headerlink" title="什么是双括号初始化？"></a>什么是双括号初始化？</h2><pre><code class="java">Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;() {{    put("name", "Alpha");    put("age", 8);}};</code></pre><h2 id="为什么能这样写？"><a href="#为什么能这样写？" class="headerlink" title="为什么能这样写？"></a>为什么能这样写？</h2><p>以下内容引自 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html" target="_blank" rel="noopener">The Java™ Tutorials - Initializing Fields</a>：</p><blockquote><p>Initializing Instance Members</p><p>Normally, you would put code to initialize an instance variable in a constructor. There are two alternatives to using a constructor to initialize instance variables: initializer blocks and final methods.</p><p>Initializer blocks for instance variables look just like static initializer blocks, but without the static keyword:</p><pre><code>{   // whatever code is needed for initialization goes here}</code></pre><p>The Java compiler copies initializer blocks into every constructor. Therefore, this approach can be used to share a block of code between multiple constructors.</p></blockquote><h2 id="为什么不建议使用？"><a href="#为什么不建议使用？" class="headerlink" title="为什么不建议使用？"></a>为什么不建议使用？</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.baeldung.com/java-initialize-hashmap" target="_blank" rel="noopener">Initialize a HashMap in Java</a></li><li><a href="https://blog.csdn.net/wuxianjiezh/article/details/90267142" target="_blank" rel="noopener">Java 隐藏特性：双括号初始化（Double Brace Initialization）</a></li><li><a href="https://stackoverflow.com/questions/924285/efficiency-of-java-double-brace-initialization" target="_blank" rel="noopener">Efficiency of Java “Double Brace Initialization”?</a></li><li><a href="https://www.baeldung.com/java-double-brace-initialization" target="_blank" rel="noopener">Java Double Brace Initialization</a></li></ul><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><ul><li>不支持钻石操作符，即不可以这样写：<code>Map&lt;String, Object&gt; map = new HashMap&lt;&gt;() { {  } };</code></li><li>因为相当于是通过内部类实现的，每次使用这种写法都会新创建一个内部类，如：<code>MainClass$InnerClass.class</code></li><li>存在性能问题，可能会导致内存溢出。</li></ul><h2 id="难道只能从了？"><a href="#难道只能从了？" class="headerlink" title="难道只能从了？"></a>难道只能从了？</h2><p>虽然双括号初始化看上去还算美，但却不建议使用。<br>Java 8、9 也提供了一些其他的初始化方式，还有各种三方类库也提供了很多其他方式（详见上节中的参考资料）。</p><p>什么？还不满意？</p><p>忍一时风平浪静，退一步海阔天空。</p><p>有能耐你别用 Java 啊！</p><p>比如 Groovy 了解一下：</p><pre><code class="groovy">Map emptyMap = [:]Map map = [name: &#39;Alpha&#39;, age: 8]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JitPack 真香 Plus</title>
      <link href="2020/07/04/jitpack-plus/"/>
      <url>2020/07/04/jitpack-plus/</url>
      
        <content type="html"><![CDATA[<p>在 <a href="https://alphahinex.github.io/2020/05/29/jitpack-in-action/">JitPack 真香</a> 中，介绍了 JitPack 的基本用法。</p><p>当一个仓库中对应多个模块，每个模块需发布成一个独立 jar 包时，依赖的坐标有略微调整：</p><table><thead><tr><th align="left"></th><th align="left">单模块</th><th align="left">多模块</th></tr></thead><tbody><tr><td align="left">groupId</td><td align="left">com.github.User</td><td align="left">com.github.User.Repo</td></tr><tr><td align="left">artifactId</td><td align="left">Repo</td><td align="left">Module</td></tr><tr><td align="left">version</td><td align="left">Tag</td><td align="left">Tag</td></tr></tbody></table><blockquote><p>多模块时，依然可以通过单模块的依赖语法形式，获得该项目的所有模块：</p><pre><code>implementation &#39;com.github.User:Repo:Tag&#39;</code></pre></blockquote><p>相关文档可见 <a href="https://jitpack.io/docs/BUILDING/#multi-module-projects" target="_blank" rel="noopener">Multi-module projects</a>。</p><p>在 <a href="https://jitpack.io/" target="_blank" rel="noopener">JitPack</a> 界面完成构建之后，可以直接从界面获得所有模块的依赖坐标：</p><p><img src="/contents/jitpack-in-action/modules.png" alt="modules"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谁动了我的异常？</title>
      <link href="2020/06/26/undeclared-throwable-exception/"/>
      <url>2020/06/26/undeclared-throwable-exception/</url>
      
        <content type="html"><![CDATA[<h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>通常来讲，为方便开发，我们会对异常进行统一的处理。会定义一个异常基类，针对基于这个基类的自定义异常进行统一处理。</p><p>当异常基类为检查型异常（Checked Exception）时，如果自定义异常是通过切面等代理抛出的，被代理的方法本身并未抛出且也未声明此异常时，就会遇到这个问题：</p><p>统一异常处理方法中，捕获到的异常，已不是代理类中抛出的自定义异常，而是一个将自定义异常包装在内的 <code>java.lang.reflect.UndeclaredThrowableException</code>。</p><p>那么为什么会这样呢？</p><h2 id="追根溯源"><a href="#追根溯源" class="headerlink" title="追根溯源"></a>追根溯源</h2><p>以使用 <a href="https://github.com/spring-projects/spring-framework/tree/v5.0.13.RELEASE" target="_blank" rel="noopener">Spring Framework v5.0.13.RELEASE</a> 及切面场景为例。</p><p>Spring 文档中关于 <a href="https://docs.spring.io/spring/docs/5.0.13.RELEASE/spring-framework-reference/core.html#aop-introduction-proxies" target="_blank" rel="noopener">AOP 代理</a> 的描述如下：</p><pre><code class="doc">5.1.3. AOP ProxiesSpring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied.Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than interfaces. CGLIB is used by default if a business object does not implement an interface. As it is good practice to program to interfaces rather than classes; business classes normally will implement one or more business interfaces. It is possible to force the use of CGLIB, in those (hopefully rare) cases where you need to advise a method that is not declared on an interface, or where you need to pass a proxied object to a method as a concrete type.It is important to grasp the fact that Spring AOP is proxy-based. See Understanding AOP proxies for a thorough examination of exactly what this implementation detail actually means.</code></pre><p>几个重点：</p><ol><li>Spring AOP 是基于代理来实现的。</li><li>Spring AOP 默认使用 JDK 动态代理来为切面创建代理。这使得所有接口的实现类都可以被代理。</li><li>Spring AOP 也可以使用 CGLIB 创建代理。当一个类未实现任何接口时，会默认使用 CGLIB 的方式创建代理。也可以强制使用 CGLIB 进行代理。</li></ol><p>在 <a href="https://github.com/spring-projects/spring-framework/blob/v5.0.13.RELEASE/spring-aop/src/main/java/org/springframework/aop/framework/DefaultAopProxyFactory.java" target="_blank" rel="noopener">DefaultAopProxyFactory</a> 中可以看到对应的逻辑：</p><pre><code class="javadoc">* &lt;p&gt;Creates a CGLIB proxy if one the following is true for a given* {@link AdvisedSupport} instance:* &lt;ul&gt;* &lt;li&gt;the {@code optimize} flag is set* &lt;li&gt;the {@code proxyTargetClass} flag is set* &lt;li&gt;no proxy interfaces have been specified* &lt;/ul&gt;** &lt;p&gt;In general, specify {@code proxyTargetClass} to enforce a CGLIB proxy,* or specify one or more interfaces to use a JDK dynamic proxy.</code></pre><pre><code class="java">@Overridepublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {  if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {    Class&lt;?&gt; targetClass = config.getTargetClass();    if (targetClass == null) {      throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +          &quot;Either an interface or a target is required for proxy creation.&quot;);    }    if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {      return new JdkDynamicAopProxy(config);    }    return new ObjenesisCglibAopProxy(config);  }  else {    return new JdkDynamicAopProxy(config);  }}</code></pre><p>使用 <code>ObjenesisCglibAopProxy</code> 创建代理时，会调用 <a href="https://github.com/spring-projects/spring-framework/blob/v5.0.13.RELEASE/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java#L159" target="_blank" rel="noopener">org.springframework.aop.framework.CglibAopProxy#getProxy(java.lang.ClassLoader)</a> 方法，其中 <a href="https://github.com/spring-projects/spring-framework/blob/v5.0.13.RELEASE/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java#L192" target="_blank" rel="noopener">192</a> 行配置了一个 <a href="https://github.com/spring-projects/spring-framework/blob/v5.0.13.RELEASE/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java#L973" target="_blank" rel="noopener">ClassLoaderAwareUndeclaredThrowableStrategy</a> 策略。</p><pre><code class="java">enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</code></pre><p>在 <code>ClassLoaderAwareUndeclaredThrowableStrategy</code> 策略的 <a href="https://github.com/spring-projects/spring-framework/blob/v5.0.13.RELEASE/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.java#L984" target="_blank" rel="noopener">generate</a> 方法调用父类 UndeclaredThrowableStrategy =&gt; DefaultGeneratorStrategy 的 generate 方法时，可以获得到增强后的字节码。</p><h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><p>说到这时会发现一个问题，在 Spring Framework 的代码仓库中，没有上面提到的 <code>UndeclaredThrowableStrategy</code> 和 <code>DefaultGeneratorStrategy</code> 的源码，而这两个类明明是包含在 <code>spring-core</code> 的 jar 包中的。</p><p>spring-core 模块的构建文件 <a href="https://github.com/spring-projects/spring-framework/blob/v5.0.13.RELEASE/spring-core/spring-core.gradle" target="_blank" rel="noopener">spring-core.gradle</a> 给我们揭晓了答案：</p><pre><code class="spring-core.gradle">...// spring-core includes asm and repackages cglib, inlining both into the spring-core jar.// cglib itself depends on asm and is therefore further transformed by the JarJar task to// depend on org.springframework.asm; this avoids including two different copies of asm.def cglibVersion = &quot;3.2.6&quot;...task cglibRepackJar(type: Jar) { repackJar -&gt;    repackJar.baseName = &quot;spring-cglib-repack&quot;    repackJar.version = cglibVersion    doLast() {        project.ant {            taskdef name: &quot;jarjar&quot;, classname: &quot;com.tonicsystems.jarjar.JarJarTask&quot;,                    classpath: configurations.jarjar.asPath            jarjar(destfile: repackJar.archivePath) {                configurations.cglib.each { originalJar -&gt;                    zipfileset(src: originalJar)                }                // Repackage net.sf.cglib =&gt; org.springframework.cglib                rule(pattern: &quot;net.sf.cglib.**&quot;, result: &quot;org.springframework.cglib.@1&quot;)                // As mentioned above, transform cglib&#39;s internal asm dependencies from                // org.objectweb.asm =&gt; org.springframework.asm. Doing this counts on the                // the fact that Spring and cglib depend on the same version of asm!                rule(pattern: &quot;org.objectweb.asm.**&quot;, result: &quot;org.springframework.asm.@1&quot;)            }        }    }}...</code></pre><p>所以在 <a href="https://github.com/cglib/cglib/tree/RELEASE_3_2_6" target="_blank" rel="noopener">cglib v3.2.6</a> 的仓库中，我们可以找到 <a href="https://github.com/cglib/cglib/blob/RELEASE_3_2_6/cglib/src/main/java/net/sf/cglib/transform/impl/UndeclaredThrowableStrategy.java" target="_blank" rel="noopener">UndeclaredThrowableStrategy</a> 和 <a href="https://github.com/cglib/cglib/blob/RELEASE_3_2_6/cglib/src/main/java/net/sf/cglib/core/DefaultGeneratorStrategy.java" target="_blank" rel="noopener">DefaultGeneratorStrategy</a>，以及 <a href="https://github.com/cglib/cglib/blob/RELEASE_3_2_6/cglib/src/main/java/net/sf/cglib/core/DefaultGeneratorStrategy.java#L23-L27" target="_blank" rel="noopener">可获取增强后字节码的地方</a>：</p><pre><code class="java">public byte[] generate(ClassGenerator cg) throws Exception {    DebuggingClassWriter cw = getClassVisitor();    transform(cg).generateClass(cw);    return transform(cw.toByteArray());}</code></pre><blockquote><p>断点加在 <code>cw.toByteArray()</code> 处，将其输出为 <code>.class</code> 文件，即可获得增强后的字节码，也就是 AOP 的代理类。</p></blockquote><h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><p>回到主线。反编译输出出来的 <code>.class</code> 文件，可与源码进行对比。</p><p>源码：</p><pre><code class="java">@PostMappingpublic ResponseEntity post() {    return responseOfPost(&quot;success&quot;);}</code></pre><p>反编译代理类：</p><pre><code class="java">public final ResponseEntity post() {    try {        MethodInterceptor cglib$CALLBACK_2;        MethodInterceptor cglib$CALLBACK_0;        if ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = this.CGLIB$CALLBACK_0)) == null) {            CGLIB$BIND_CALLBACKS(this);            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = this.CGLIB$CALLBACK_0);        }        if (cglib$CALLBACK_0 != null) {            return (ResponseEntity)cglib$CALLBACK_2.intercept((Object)this, TestController$$EnhancerBySpringCGLIB$$ef60194e.CGLIB$post$5$Method, TestController$$EnhancerBySpringCGLIB$$ef60194e.CGLIB$emptyArgs, TestController$$EnhancerBySpringCGLIB$$ef60194e.CGLIB$post$5$Proxy);        }        return super.post();    }    catch (RuntimeException | Error ex) {        throw;    }    catch (Throwable t) {        throw new UndeclaredThrowableException(t);    }}</code></pre><blockquote><p>顺便吐个槽：老牌反编译软件 <a href="https://github.com/java-decompiler/jd-gui" target="_blank" rel="noopener">jd-gui</a> 反编译上面这段时，内容明显不对。<a href="https://github.com/deathmarine/Luyten" target="_blank" rel="noopener">Luyten</a> 反编译出了上述结果，但 <a href="https://github.com/deathmarine/Luyten/releases/tag/v0.5.4_Rebuilt_with_Latest_depenencies" target="_blank" rel="noopener">Luyten v0.5.4 Rebuilt</a> 里的 <a href="https://github.com/deathmarine/Luyten/releases/download/v0.5.4_Rebuilt_with_Latest_depenencies/luyten-OSX-0.5.4.zip" target="_blank" rel="noopener">Mac 版</a> 无任何响应。上述结果为在 Windows 下编译得到。</p></blockquote><p>总结一下，扣个题：</p><p>代理类将被代理调用的方法整个使用 try/catch 包了起来，将除 RuntimeException 和 Error 之外的异常，都包装成了 <code>UndeclaredThrowableException</code> 再向外抛出。</p><h2 id="对症下药"><a href="#对症下药" class="headerlink" title="对症下药"></a>对症下药</h2><p>所以遇到这个问题的时候，可以通过如下方式处理：</p><ol><li>在被代理的方法上，显示抛出检查型异常</li><li>切面里抛出 RuntimeException，替代检查型异常</li><li>不能更改异常类型又不想在方法上定义方法本身未进行抛出的异常时，可以使用一些迂回策略，比如在切面中直接按照统一异常处理的规则，返回将异常处理好的封装类型</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/7edab536e4b9" target="_blank" rel="noopener">java.lang.reflect.UndeclaredThrowableException的解决</a></li><li><a href="https://msd.misuland.com/pd/3255817997595446638" target="_blank" rel="noopener">JDK动态代理UndeclaredThrowableException异常</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Proxy.html" target="_blank" rel="noopener">java.lang.reflect.Proxy</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/InvocationHandler.html" target="_blank" rel="noopener">java.lang.reflect.InvocationHandler</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/UndeclaredThrowableException.html" target="_blank" rel="noopener">java.lang.reflect.UndeclaredThrowableException</a></li><li><a href="https://docs.spring.io/spring/docs/5.0.13.RELEASE/spring-framework-reference/core.html#aop-introduction-proxies" target="_blank" rel="noopener">AOP Proxies</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradle HTTP 超时设置</title>
      <link href="2020/06/19/gradle-http-timeout-settings/"/>
      <url>2020/06/19/gradle-http-timeout-settings/</url>
      
        <content type="html"><![CDATA[<p>在使用 Nexus 时，很罕见的遇到了超时问题：</p><pre><code class="log">&gt; Unable to load Maven meta-data from http://localhost:8081/repository/test/io/github/alphahinex/example/0.1.2-SNAPSHOT/maven-metadata.xml.   &gt; Could not HEAD &#39;http://localhost:8081/repository/test/io/github/alphahinex/example/0.1.2-SNAPSHOT/maven-metadata.xml&#39;.      &gt; Read timed out</code></pre><p>经确认，<a href="http://localhost:8081/repository/test/io/github/alphahinex/example/0.1.2-SNAPSHOT/maven-metadata.xml" target="_blank" rel="noopener">http://localhost:8081/repository/test/io/github/alphahinex/example/0.1.2-SNAPSHOT/maven-metadata.xml</a> 是可以得到正确的响应的，但是响应时间比较长。</p><p>类似问题，在使用 <a href="https://alphahinex.github.io/2020/05/29/jitpack-in-action/">JitPack 真香</a> 中提到的，需要 JitPack 先进行构建才能下载的依赖时，也可能会遇到。</p><p>增加超时时间就可以解决这个问题了，但现在 Gradle 的 <a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="noopener">文档</a> 实在有点无力吐槽，啥也找不着。</p><p>下面就是缺失的 ——</p><h1 id="Gradle-HTTP-超时设置文档"><a href="#Gradle-HTTP-超时设置文档" class="headerlink" title="Gradle HTTP 超时设置文档"></a>Gradle HTTP 超时设置文档</h1><p>以 <a href="https://github.com/gradle/gradle/tree/v6.0.1" target="_blank" rel="noopener">Gradle v6.0.1</a> 为例：</p><p>超时属性及默认超时时间在 <a href="https://github.com/gradle/gradle/blob/v6.0.1/subprojects/resources-http/src/main/java/org/gradle/internal/resource/transport/http/JavaSystemPropertiesHttpTimeoutSettings.java#L26-L29" target="_blank" rel="noopener">JavaSystemPropertiesHttpTimeoutSettings.java#L26-L29</a> 中：</p><pre><code class="java">public static final String CONNECTION_TIMEOUT_SYSTEM_PROPERTY = &quot;org.gradle.internal.http.connectionTimeout&quot;;public static final String SOCKET_TIMEOUT_SYSTEM_PROPERTY = &quot;org.gradle.internal.http.socketTimeout&quot;;public static final int DEFAULT_CONNECTION_TIMEOUT = 30000;public static final int DEFAULT_SOCKET_TIMEOUT = 30000;</code></pre><p>设置方式为：</p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><pre><code class="bash">$ ./gradlew build -Dorg.gradle.internal.http.socketTimeout=200000 -Dorg.gradle.internal.http.connectionTimeout=200000</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>可在 <code>gradle.properties</code> 文件中，通过如下属性进行配置：</p><pre><code class="gradle.properties">systemProp.org.gradle.internal.http.socketTimeout=200000systemProp.org.gradle.internal.http.connectionTimeout=200000</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://stackoverflow.com/questions/37156568/increase-timeout-for-gradle-to-get-a-maven-dependency" target="_blank" rel="noopener">Increase timeout for gradle to get a maven dependency</a></li><li><a href="https://github.com/gradle/gradle/pull/3041" target="_blank" rel="noopener">#3041 Introduce HTTP timeout</a></li><li><a href="https://github.com/gradle/gradle/pull/3371" target="_blank" rel="noopener">#3371 Increase timeout for HTTP timeouts and assign system properties to internal namespace</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gradle </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH Port Forwarding, aka SSH Tunneling</title>
      <link href="2020/06/12/ssh-port-forwarding/"/>
      <url>2020/06/12/ssh-port-forwarding/</url>
      
        <content type="html"><![CDATA[<p>SSH（Secure Shell）端口转发（SSH Port Forwarding），也叫 SSH 隧道（SSH Tunneling），是 SSH 中的一种机制，可以在 SSH 客户端与服务端之间，建立一条隧道，将客户端端口转发至服务端，也可将服务端端口转发至客户端。利用这种机制，可以为老式应用，提供加密通讯的途径，以及其他一些更广泛的用途。</p><p><img src="/contents/ssh-port-forwarding/Securing_applications_with_ssh_tunneling___port_forwarding.png" alt="Securing applications with ssh tunneling/port forwarding"></p><h2 id="怎么端口转发-创建隧道？"><a href="#怎么端口转发-创建隧道？" class="headerlink" title="怎么端口转发/创建隧道？"></a>怎么端口转发/创建隧道？</h2><p>利用 SSH 客户端，即可完成隧道的创建，创建隧道时，需指定隧道两端的端口，故也叫端口转发。</p><p>端口转发分为两种：</p><ol><li>本地端口转发</li><li>远程端口转发</li></ol><p>下面以 <a href="https://en.wikipedia.org/wiki/OpenSSH" target="_blank" rel="noopener">OpenSSH</a> 为例，进行具体实例说明。</p><h3 id="本地端口转发（Local-Port-Forwarding）"><a href="#本地端口转发（Local-Port-Forwarding）" class="headerlink" title="本地端口转发（Local Port Forwarding）"></a>本地端口转发（Local Port Forwarding）</h3><p>假如有这样一个场景：</p><p>本地可以通过 <code>2426</code> 端口 ssh 连接到 <code>remote-host</code>。<br>在 remote-host 上的 <code>3306</code> 端口有一个 MySQL 服务。<br>受各种因素所限，本地无法连接 remote-host 的 3306 端口，但想要使用 remote-host 上的 MySQL 服务，且不能修改其端口号。</p><p>此时本地端口转发就可以派上用场了：</p><pre><code class="bash">$ ssh -L 4406:remote-host:3306 user@remote-host -p 2426</code></pre><p><code>-L</code> 意为使用本地端口转发。<code>4406</code> 为使用的本地端口。<code>remote-host:3306</code> 需为所登录的 SSH 服务端可访问的地址及端口。<br><code>user@remote-host</code> 为登录 SSH 服务端的用户和地址，<code>-p</code> 为指定 SSH 服务所在端口，如使用默认端口（<code>22</code>)，此部分内容可省略。</p><p>此例意为将对本地 4406 端口的访问，通过 SSH 客户端所创建的隧道，转发至 remote-host 的 3306 端口。此时便可通过访问本地 4406 端口，连接至 remote-host 中 3306 的 MySQL 了。</p><p>默认情况下，任何可以连接到本地（此 SSH 客户端所在）4406 端口的机器，都可以使用此隧道。需限定仅本机可使用此隧道时，可绑定具体地址，如：</p><pre><code class="bash">$ ssh -L 127.0.0.1:4406:remote-host:3306 user@remote-host -p 2426</code></pre><h3 id="远程端口转发（Remote-Port-Forwarding）"><a href="#远程端口转发（Remote-Port-Forwarding）" class="headerlink" title="远程端口转发（Remote Port Forwarding）"></a>远程端口转发（Remote Port Forwarding）</h3><p>远程端口转发，可适用于如下场景：</p><p>内网环境有一个 MySQL 服务，外网无法直接访问到此服务，但内网可连接至外网一 SSH 服务（remote-host）。<br>通过远程端口转发，可以在内网建立一条与 remote-host 的隧道，并将外网端口（如 5506）转发至内网 MySQL 的 3306 端口。<br>此时连接 remote-host 的 5506，即可访问内网 MySQL 3306 的服务。</p><p>在内网 MySQL 服务所在机器中执行：</p><pre><code class="bash">$ ssh -R 5506:localhost:3306 remote-host</code></pre><p>意为使用本地 SSH 客户端相同用户，默认端口（22）连接 remote-host，并将 remote-host 的 5506 端口，转发至本地 localhost 3306 端口。</p><p>默认情况下，此时仅可在 remote-host 服务器自身，通过 5506 端口访问到内网的 3306 服务。</p><p>在 SSH 服务端的 <code>sshd_config</code> 文件（<code>/etc/ssh/sshd_config</code>）中，可通过 <code>GatewayPorts</code> 参数控制此行为。</p><pre><code class="doc">GatewayPorts        是否允许远程主机连接本地的转发端口。默认值是&quot;no&quot;。        sshd(8) 默认将远程端口转发绑定到loopback地址。这样将阻止其它远程主机连接到转发端口。        GatewayPorts 指令可以让 sshd 将远程端口转发绑定到非loopback地址，这样就可以允许远程主机连接了。        &quot;no&quot;表示仅允许本地连接，&quot;yes&quot;表示强制将远程端口转发绑定到统配地址(wildcard address)，        &quot;clientspecified&quot;表示允许客户端选择将远程端口转发绑定到哪个地址。</code></pre><blockquote><p>—— 引自 <a href="http://www.jinbuguo.com/openssh/sshd_config.html" target="_blank" rel="noopener">sshd_config 中文手册</a></p></blockquote><p>在配置文件中进行 <code>GatewayPorts yes</code> 配置后，可通过 <code>systemctl restart sshd</code> 重启 ssh 服务使配置生效。</p><h2 id="如何保持会话？"><a href="#如何保持会话？" class="headerlink" title="如何保持会话？"></a>如何保持会话？</h2><p>按上述方式进行端口转发时，会通过 SSH 方式连接到服务端。但按默认设置，客户端在空闲一段时间后可能会中断，需保持会话时，可在 <code>~/.ssh/config</code> 中加入：</p><pre><code class="config">Host *  ServerAliveInterval 30</code></pre><ul><li><code>Host *</code> 表示连接任意地址均使用此配置。如果需要针对某个主机，可配置为指定 host 或者 IP；</li><li><code>ServerAliveInterval 30</code> 表示 SSH 客户端每隔 <code>30秒</code> 给远程主机发送一个 no-op 包，no-op 是无任何操作的意思，这样远程主机就不会关闭这个SSH会话。</li></ul><p>参数说明可通过 <code>man ssh_config</code> 进行查看，如：</p><pre><code class="man">ServerAliveInterval        Sets a timeout interval in seconds after which if no data has been received from the server, ssh(1) will send a message through the        encrypted channel to request a response from the server.  The default is 0, indicating that these messages will not be sent to the        server.</code></pre><h2 id="怎么后台运行"><a href="#怎么后台运行" class="headerlink" title="怎么后台运行"></a>怎么后台运行</h2><p>设置了超时时间后，在 SSH 客户端存在期间可以一直使用端口转发。但客户端关闭后就会失效。SSH 提供了后台运行的方式来解决这个问题。</p><p>以上面远程端口转发为例，可使用如下方式，使连接在后台运行。</p><pre><code class="bash">$ ssh -fNgR 5506:localhost:3306 remote-host</code></pre><p>各参数含义如下：</p><pre><code class="man">-f      Requests ssh to go to background just before command execution.  This is useful if ssh is going to ask for passwords or        passphrases, but the user wants it in the background.  This implies -n.  The recommended way to start X11 programs at a remote        site is with something like ssh -f host xterm.        If the ExitOnForwardFailure configuration option is set to ``yes&#39;&#39;, then a client started with -f will wait for all remote port        forwards to be successfully established before placing itself in the background.-N      Do not execute a remote command.  This is useful for just forwarding ports.-g      Allows remote hosts to connect to local forwarded ports.  If used on a multiplexed connection, then this option must be specified        on the master process.</code></pre><p>另外，后台运行时，同样也存在服务端断开连接的情况。此时若需保持会话，可通过 <code>-o</code> 参数指定客户端参数，如：</p><pre><code class="bash">$ ssh -fNgR 5506:localhost:3306 remote-host -o ServerAliveInterval=30</code></pre><h2 id="如何防止滥用-？"><a href="#如何防止滥用-？" class="headerlink" title="如何防止滥用 ？"></a>如何防止滥用 ？</h2><p>为防止端口转发被滥用，一般需要在服务器配置中（/etc/ssh/sshd_config）明确禁止此行为，如：</p><pre><code class="config">AllowTcpForwarding noAllowStreamLocalForwarding noGatewayPorts noPermitTunnel no</code></pre><blockquote><p>注意：即使禁用了端口转发，依然存在用户运行自己的 SSH 服务等其他可能，不能彻底避免安全性问题。</p></blockquote><p>各参数详细说明，可通过 <code>man sshd_config</code> 进行查看：</p><pre><code class="man">AllowTcpForwarding        Specifies whether TCP forwarding is permitted.  The available options are yes (the default) or all to allow TCP forwarding, no to        prevent all TCP forwarding, local to allow local (from the perspective of ssh(1)) forwarding only or remote to allow remote forward-        ing only.  Note that disabling TCP forwarding does not improve security unless users are also denied shell access, as they can        always install their own forwarders.AllowStreamLocalForwarding        Specifies whether StreamLocal (Unix-domain socket) forwarding is permitted.  The available options are yes (the default) or all to        allow StreamLocal forwarding, no to prevent all StreamLocal forwarding, local to allow local (from the perspective of ssh(1)) for-        warding only or remote to allow remote forwarding only.  Note that disabling StreamLocal forwarding does not improve security unless        users are also denied shell access, as they can always install their own forwarders.GatewayPorts        Specifies whether remote hosts are allowed to connect to ports forwarded for the client.  By default, sshd(8) binds remote port for-        wardings to the loopback address.  This prevents other remote hosts from connecting to forwarded ports.  GatewayPorts can be used to        specify that sshd should allow remote port forwardings to bind to non-loopback addresses, thus allowing other hosts to connect.  The        argument may be no to force remote port forwardings to be available to the local host only, yes to force remote port forwardings to        bind to the wildcard address, or clientspecified to allow the client to select the address to which the forwarding is bound.  The        default is no.PermitTunnel        Specifies whether tun(4) device forwarding is allowed.  The argument must be yes, point-to-point (layer 3), ethernet (layer 2), or        no.  Specifying yes permits both point-to-point and ethernet.  The default is no.        Independent of this setting, the permissions of the selected tun(4) device must allow access to the user.</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="bash"># 将本地 3426 端口映射至 remote 22 端口，此时可 ssh 到此机器的 3426 端口，以实现以此机器作为跳板 ssh 到 remote 主机的效果$ ssh -fNgL 3426:remote:22 root@remote -o ServerAliveInterval=30</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ssh.com/ssh/tunneling/example" target="_blank" rel="noopener">SSH Port Forwarding Example</a></li><li><a href="https://www.ssh.com/ssh/tunneling/" target="_blank" rel="noopener">SSH tunnel</a></li><li><a href="https://www.jianshu.com/p/c0f1ef1f01c2" target="_blank" rel="noopener">Iterm2 SSH保持连接方法</a></li><li><a href="http://www.jinbuguo.com/openssh/sshd_config.html" target="_blank" rel="noopener">sshd_config 中文手册</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Why was &#39;~&#39; chosen to represent the home directory?</title>
      <link href="2020/06/05/why-tilde-means-home/"/>
      <url>2020/06/05/why-tilde-means-home/</url>
      
        <content type="html"><![CDATA[<p><a href="https://unix.stackexchange.com/questions/34196/why-was-chosen-to-represent-the-home-directory" target="_blank" rel="noopener">Why was ‘~’ chosen to represent the home directory?</a></p><p><a href="https://en.wikipedia.org/wiki/Tilde#Directories_and_URLs" target="_blank" rel="noopener">Quoting Wikipedia</a>:</p><blockquote><p>On Unix-like operating systems (including BSD, GNU/Linux and Mac OS X), tilde often indicates the current user’s home directory: for example, if the current user’s home directory is <code>/home/bloggsj</code>, then <code>cd</code>, <code>cd ~</code>, <code>cd /home/bloggsj</code> or <code>cd $HOME</code> are equivalent. This practice derives from the Lear-Siegler ADM-3A terminal in common use during the 1970s, which happened to have the tilde symbol and the word “Home” (for moving the cursor to the upper left) on the same key.</p></blockquote><p><img src="/contents/why-tilde-means-home/KB_Terminal_ADM3A.svg" alt="KB_Terminal_ADM3A"></p><p>You can find photos of the Lear-Siegler <a href="https://en.wikipedia.org/wiki/ADM-3A" target="_blank" rel="noopener">ADM-3A</a> keyboard on <a href="https://rollmops.wordpress.com/2006/05/01/vintage-computer/" target="_blank" rel="noopener">this</a> site.</p><p><img src="/contents/why-tilde-means-home/ADM3A.png" alt="Lear Siegler - ADM3A Terminal (ca. 1976)"></p><p><img src="/contents/why-tilde-means-home/kb.png" alt="image of an ADM-3A keyboard"></p><p>This terminal is also the <a href="https://stackoverflow.com/a/6553850/499768" target="_blank" rel="noopener">source of the movement commands</a> used in the <code>vi</code> editor: <code>h</code>, <code>j</code>, <code>k</code>, <code>l</code> for left, down, up, right.</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JitPack 真香</title>
      <link href="2020/05/29/jitpack-in-action/"/>
      <url>2020/05/29/jitpack-in-action/</url>
      
        <content type="html"><![CDATA[<p>在 <a href="https://alphahinex.github.io/2020/01/17/github-packages-in-action/">GitHub Packages in Action</a> 中，我们介绍了 GitHub Packages Registry（GPR）的用法。GPR 有其应用场景，但也经常会有蹩手的感觉，尤其是在传错了包，需要邮件联系客服进行删除，而客服又迟迟没有回复的时候……</p><p>直到发现了 <a href="https://jitpack.io/" target="_blank" rel="noopener">JitPack</a>，除了真香，找不到别的词来形容了。</p><h2 id="如何接入-JitPack"><a href="#如何接入-JitPack" class="headerlink" title="如何接入 JitPack"></a>如何接入 JitPack</h2><p>只要代码仓库是使用 GitHub，或者 <a href="https://jitpack.io/docs/#other-git-hosts" target="_blank" rel="noopener">其他几种常见的 Git 仓库托管服务</a>，就可以立即接入 JitPack。</p><p>以 <a href="https://github.com/AlphaHinex/checkstyle-checkers" target="_blank" rel="noopener">https://github.com/AlphaHinex/checkstyle-checkers</a> 仓库为例，只需在 <a href="https://jitpack.io/" target="_blank" rel="noopener">https://jitpack.io/</a> 页面的输入框中，填写 <code>AlphaHinex/checkstyle-checkers</code> 并点击 <code>Look up</code> 按钮，即可完成接入。</p><p>在 JitPack 完成构建之后，可通过 <code>Release</code>、<code>Branch</code> 甚至 <code>Commit</code> 获得不同版本的 jar 包，页面上提供了各种构建工具的接入方式，照着一顿操作就好了。</p><h2 id="如何从-JitPack-下载依赖"><a href="#如何从-JitPack-下载依赖" class="headerlink" title="如何从 JitPack 下载依赖"></a>如何从 JitPack 下载依赖</h2><p>以 Gradle 为例，需要在 <code>build.gradle</code> 中添加 JitPack 的仓库地址即可。</p><pre><code class="build.gradle">allprojects {    repositories {        ...        maven { url &#39;https://jitpack.io&#39; }    }}</code></pre><h2 id="能否从没主动接入的-Git-库直接下载依赖"><a href="#能否从没主动接入的-Git-库直接下载依赖" class="headerlink" title="能否从没主动接入的 Git 库直接下载依赖"></a>能否从没主动接入的 Git 库直接下载依赖</h2><p>按照 JitPack 支持的版本规则（Release、Commit、Branch），可直接获得任意公开库的 jar 包，无论该仓库是否进行过主动接入。</p><h2 id="关于-tag-中的-v-前缀"><a href="#关于-tag-中的-v-前缀" class="headerlink" title="关于 tag 中的 v 前缀"></a>关于 tag 中的 <code>v</code> 前缀</h2><p>有一个需要注意的点是，在 GitHub 上，推荐使用的 tag 为使用 <code>v</code> 前缀的形式：</p><blockquote><p>Tagging suggestions</p><p>It’s common practice to prefix your version names with the letter v. Some good tag names might be v1.0 or v2.3.4.</p></blockquote><p>但在版本号中，一般都使用不带 <code>v</code> 的形式。</p><p>当未主动在 JitPack 网站上面点击过 Release 版本的 <code>Get it</code> 按钮之前，在依赖时，version 只能使用带 <code>v</code> 前缀的形式。</p><p><img src="/contents/jitpack-in-action/get-it.jpg" alt="get it"></p><p><strong>如果想要使用不带 v 前缀的格式作为 version，可以找到相应版本，并点击 <code>Get it</code> 按钮之后，等待 JitPack 的构建完成（可以从 <code>Log</code> 中查看构建日志）。</strong></p><h2 id="Nexus-能否代理-JitPack-仓库"><a href="#Nexus-能否代理-JitPack-仓库" class="headerlink" title="Nexus 能否代理 JitPack 仓库"></a>Nexus 能否代理 JitPack 仓库</h2><p>没问题，注意选择 <code>Mixed</code> 类型即可。</p><p><img src="/contents/jitpack-in-action/nexus-jitpack.png" alt="nexus"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 三招脱坑指南</title>
      <link href="2020/05/22/git-in-action/"/>
      <url>2020/05/22/git-in-action/</url>
      
        <content type="html"><![CDATA[<p><img src="/contents/git-in-action/cover.jpeg" alt="cover"></p><h2 id="第一招：六脉神剑-——-分支"><a href="#第一招：六脉神剑-——-分支" class="headerlink" title="第一招：六脉神剑 —— 分支"></a>第一招：六脉神剑 —— 分支</h2><p><img src="/contents/git-in-action/%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91.png" alt="p1"></p><h3 id="孔子云：知之为知之，不知为不知-——-用分支！"><a href="#孔子云：知之为知之，不知为不知-——-用分支！" class="headerlink" title="孔子云：知之为知之，不知为不知 —— 用分支！"></a>孔子云：知之为知之，不知为不知 —— 用分支！</h3><h3 id="分支的使用方针"><a href="#分支的使用方针" class="headerlink" title="分支的使用方针"></a>分支的使用方针</h3><ol><li>一次只做一件事</li><li>用后即弃</li><li>为分支起一个有意义的名字</li></ol><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p><code>~/.gitconfig</code></p><pre><code class="config">[alias]    st = status -sb    cm = commit -m    co = checkout    cam = commit -a -m    onelog = log -p -1    oneline = log --pretty=oneline --since=&#39;2 days ago&#39;    logs = log --all --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s%Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --date=relative    fl = ls-tree -r --name-only    undo = checkout -- .    stat = diff --stat    patch = diff --name-only    stlog = log --name-status    recm = commit --amend -m    br = branch    cp = cherry-pick</code></pre><h3 id="分支常用操作"><a href="#分支常用操作" class="headerlink" title="分支常用操作"></a>分支常用操作</h3><pre><code class="bash"># 创建分支$ git checkout -b new-branch [start point]# 查看分支$ git branch -a# 切换分支$ git checkout new-branch# 删除分支$ git branch -d new-branch# 改名$ git branch -m new-branch new-name</code></pre><h3 id="分支分类"><a href="#分支分类" class="headerlink" title="分支分类"></a>分支分类</h3><ul><li>local</li><li>remote</li></ul><h3 id="remote-分支存在的意义"><a href="#remote-分支存在的意义" class="headerlink" title="remote 分支存在的意义"></a>remote 分支存在的意义</h3><ul><li>一言不合就 fork</li><li>保持各自仓库的独立、整洁</li><li>方便的获取其他人 fork 的某个分支</li></ul><h3 id="remote-相关操作"><a href="#remote-相关操作" class="headerlink" title="remote 相关操作"></a>remote 相关操作</h3><pre><code class="bash"># 查看 remote$ git remote -v# 增加 remote$ git remote add rstoyanchev https://github.com/rstoyanchev/spring-framework.git# 改名$ git remote rename rstoyanchev rossen# fetch remote 中的某个分支$ git fetch rossen 24051# 基于 remote 中的分支创建本地分支$ git checkout -b 24051 rossen/24051# 解除与 remote 的关联$ git branch --unset-upstream# 与 remote 关联$ git branch --set-upstream-to=origin/master# 将本地分支，推送至远程不同名分支$ git push -u origin 24051:2046# 删除 remote 分支$ git branch -rd origin/2046# 删除远程分支$ git push origin --delete 2046# 删除 remote$ git remote remove rossen</code></pre><h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><pre><code class="bash"># 查看暂存列表$ git stash list# 暂存$ git stash# 暂存，并为暂存提供一些描述信息$ git stash save some message# 应用最近一次暂存内容（不会删除对应暂存）$ git stash apply# 应用某次暂存内容$ git stash apply 2# 应用最近一次暂存内容，并删除对应暂存$ git stash pop# 应用某次暂存内容，并删除对应暂存$ git stash pop 2# 清理所有暂存$ git stash clear</code></pre><h2 id="第二招：左右互搏-——-冲突处理"><a href="#第二招：左右互搏-——-冲突处理" class="headerlink" title="第二招：左右互搏 —— 冲突处理"></a>第二招：左右互搏 —— 冲突处理</h2><p><img src="/contents/git-in-action/%E5%B7%A6%E5%8F%B3%E4%BA%92%E6%90%8F.jpeg" alt="p2"></p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><pre><code class="bash"># 合并某分支至当前分支$ git merge a# 终止合并状态$ git merge --abort</code></pre><h3 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h3><pre><code class="bash"># 查看分支状态$ git status# 查看冲突内容$ git diffdiff --cc README.mdindex 0c6116374a,7b4933a1f1..0000000000--- a/README.md+++ b/README.md@@@ -2,8 -2,8 +2,13 @@@++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD +aaddda +bbbbbb++=======+ acaca+ aaaaaa++&gt;&gt;&gt;&gt;&gt;&gt;&gt; a</code></pre><h3 id="冲突处理-——-VS-Code"><a href="#冲突处理-——-VS-Code" class="headerlink" title="冲突处理 —— VS Code"></a>冲突处理 —— VS Code</h3><p><img src="/contents/git-in-action/vscode1.png" alt="vscode1"><br><img src="/contents/git-in-action/vscode2.png" alt="vscode2"></p><h3 id="冲突处理-——-IDEA"><a href="#冲突处理-——-IDEA" class="headerlink" title="冲突处理 —— IDEA"></a>冲突处理 —— IDEA</h3><p><img src="/contents/git-in-action/idea1.png" alt="idea1"><br><img src="/contents/git-in-action/idea2.png" alt="idea2"><br><img src="/contents/git-in-action/idea3.png" alt="idea3"></p><h3 id="如何尽可能的减少冲突？"><a href="#如何尽可能的减少冲突？" class="headerlink" title="如何尽可能的减少冲突？"></a>如何尽可能的减少冲突？</h3><ol><li>一次只做一件事</li><li>每件事一个分支</li><li>每个新分支都基于最新的代码创建</li><li>分支用后即弃，不要重复使用</li><li>培养良好的编码习惯</li></ol><blockquote><p>大忌：把自己代码备份一份，更新最新代码，用自己的备份去覆盖</p></blockquote><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><pre><code class="bash"># 选择 commit 应用至当前分支$ git cherry-pick eb44f34d50 536e9c94e0# 终止 cherry-pick$ git cherry-pick --abort</code></pre><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><pre><code class="bash"># 生成 patch$ git diff &gt; demo.patch# 应用 patch$ git apply demo.patch</code></pre><p><a href="https://www.cnblogs.com/y041039/articles/2411600.html" target="_blank" rel="noopener">Git的Patch功能</a></p><h2 id="第三招：见龙在田-——-可视化"><a href="#第三招：见龙在田-——-可视化" class="headerlink" title="第三招：见龙在田 —— 可视化"></a>第三招：见龙在田 —— 可视化</h2><p><img src="/contents/git-in-action/%E8%A7%81%E9%BE%99%E5%9C%A8%E7%94%B0.jpeg" alt="p3"></p><h3 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h3><pre><code class="config">logs = log --all --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s%Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit --date=relative</code></pre><p><img src="/contents/git-in-action/git-logs.png" alt="logs"></p><h3 id="gitk"><a href="#gitk" class="headerlink" title="gitk"></a>gitk</h3><p><img src="/contents/git-in-action/gitk.png" alt="gitk"></p><h3 id="Gitkraken"><a href="#Gitkraken" class="headerlink" title="Gitkraken"></a><a href="https://www.gitkraken.com/git-client" target="_blank" rel="noopener">Gitkraken</a></h3><p><img src="/contents/git-in-action/gitkraken.png" alt="Gitkraken"></p><h3 id="Pull-Merge-Request"><a href="#Pull-Merge-Request" class="headerlink" title="Pull/Merge Request"></a>Pull/Merge Request</h3><ul><li>触发 CI 进行自动检查</li></ul><p><img src="/contents/git-in-action/github-ci.jpg" alt="github-ci"><br><img src="/contents/git-in-action/gitlab-ci.png" alt="gitlab-ci"></p><ul><li>Code Review</li></ul><p><img src="/contents/git-in-action/github-cr.png" alt="github-cr"><br><img src="/contents/git-in-action/gitlab-cr.png" alt="gitlab-cr"></p><ul><li>合并 commit，清理分支</li></ul><p><img src="/contents/git-in-action/github-merge.png" alt="github-merge"><br><img src="/contents/git-in-action/github-merge-delete-branch.png" alt="github-merge-delete-branch"><br><img src="/contents/git-in-action/gitlab-merge.png" alt="gitlab-merge"></p><hr><p><img src="/contents/git-in-action/slide.png" alt="qrcode"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神油！WD-40</title>
      <link href="2020/05/15/wd-40/"/>
      <url>2020/05/15/wd-40/</url>
      
        <content type="html"><![CDATA[<p>用了几年的雷蛇黑寡妇竞技版，对其尺寸及没有令人眼花缭乱的键盘灯甚是满意。</p><p>不想突然开始频繁出现按键失灵及双击的现象，非常影响输入效率。</p><p>千方百计与雷蛇客服联系上了，却被告知“俺们雷蛇只换不修，如果没过保可以直接给你换一个”。</p><p>这个馅饼落到我头上了的话也就没有下边的故事了。</p><p>不能免费以旧换新，花钱修一下也行啊，雷蛇依旧高冷的回复：没地方修，新买一个吧。</p><p>那就死马当活马医吧。</p><p><a href="http://zhongce.sina.com.cn/article/view/796/" target="_blank" rel="noopener">雷蛇黑寡妇蜘蛛竞技机械键盘“无奈”换轴记录</a> 描述了同款键盘的换轴过程，但专业的操作令我望而却步。</p><p>偶然又发现了一篇文章 <a href="https://post.smzdm.com/p/666978/" target="_blank" rel="noopener">关于机械键盘按键失灵或双击的处理</a>，仿佛黑暗中的一盏明灯，照亮了这把键盘的后半生。</p><p>弄了点 WD-40，拔下键帽，点上几滴，上下运动几下，键盘又恢复了往日雄风，按键失灵和连击的现象都不再出现！</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Nginx 作为 HTTP 文件服务</title>
      <link href="2020/05/08/use-nginx-as-file-server/"/>
      <url>2020/05/08/use-nginx-as-file-server/</url>
      
        <content type="html"><![CDATA[<h2 id="伺服文件路径"><a href="#伺服文件路径" class="headerlink" title="伺服文件路径"></a>伺服文件路径</h2><p><a href="http://nginx.org/en/docs/http/ngx_http_autoindex_module.html" target="_blank" rel="noopener">ngx_http_autoindex_module</a> 模块可处理请求并生成目录列表。启用后当 <a href="http://nginx.org/en/docs/http/ngx_http_index_module.html" target="_blank" rel="noopener">ngx_http_index_module</a> 模块无法找到 index 文件时，会将请求交给 <code>ngx_http_autoindex_module</code> 模块处理。</p><p>配置示例：</p><pre><code class="nginx">location / {    autoindex on;}</code></pre><p>其他相关指令可查看 <a href="http://nginx.org/en/docs/http/ngx_http_autoindex_module.html" target="_blank" rel="noopener">官方文档</a>。</p><p>另外，需要配合 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank" rel="noopener">ngx_http_core_module</a> 模块的 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#root" target="_blank" rel="noopener">root</a> 指令指定文件服务的根路径，如：</p><pre><code class="nginx">location /i/ {    root /data/w3;}</code></pre><h2 id="设定字符集"><a href="#设定字符集" class="headerlink" title="设定字符集"></a>设定字符集</h2><p><a href="http://nginx.org/en/docs/http/ngx_http_charset_module.html" target="_blank" rel="noopener">ngx_http_charset_module</a> 提供了 charset 指令，设定相应字符集可以解决中文乱码问题，如：</p><pre><code class="nginx">location / {    charset utf-8;}</code></pre><h2 id="添加基本访问权限控制"><a href="#添加基本访问权限控制" class="headerlink" title="添加基本访问权限控制"></a>添加基本访问权限控制</h2><p><a href="http://nginx.org/en/docs/http/ngx_http_auth_basic_module.html" target="_blank" rel="noopener">ngx_http_auth_basic_module</a> 提供了使用 “HTTP Basic Authentication” 协议，进行基本的用户名和密码的认证。</p><p>配置示例：</p><pre><code class="nginx">location / {    auth_basic           &quot;closed site&quot;;    auth_basic_user_file conf/htpasswd;}</code></pre><p><code>auth_basic</code> 可以是任意字符串；<code>auth_basic_user_file</code> 需指定一个包含用户名和密码的文件，文件格式如下：</p><pre><code># commentname1:password1name2:password2:commentname3:password3</code></pre><p>密码可使用 <code>openssl passwd</code> 命令生成，例如：</p><pre><code class="bash">$ openssl passwd -crypt 123456AvkEiRVc9LrPs</code></pre><blockquote><p>注意：相同密码每次生成的密文不一致</p></blockquote><p>更多支持的密码类型，可见 <a href="http://nginx.org/en/docs/http/ngx_http_auth_basic_module.html" target="_blank" rel="noopener">模块文档</a>。</p><h2 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h2><p>nginx 配置：<a href="https://github.com/AlphaHinex/compose-docker/blob/master/nginx/file_server.conf" target="_blank" rel="noopener">https://github.com/AlphaHinex/compose-docker/blob/master/nginx/file_server.conf</a></p><p>可借助 <a href="https://github.com/AlphaHinex/compose-docker/blob/master/docker-compose.yml" target="_blank" rel="noopener">docker-compose</a> 启动：</p><pre><code class="bash">$ docker-compose up -d nginx</code></pre><p>之后访问 <a href="http://localhost:2020" target="_blank" rel="noopener">http://localhost:2020</a></p><p>输入用户名 <code>alpha</code>，密码 <code>hinex</code>，即可看到文件列表。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet 注册到了哪？</title>
      <link href="2020/04/30/where-are-servlets/"/>
      <url>2020/04/30/where-are-servlets/</url>
      
        <content type="html"><![CDATA[<p>按 <a href="https://alphahinex.github.io/2020/04/24/multi-dispatcherservlet/">还在给每个请求加前缀避免模块间接口冲突呢？</a> 中内容，我们可以通过 <code>ServletRegistrationBean</code> 注册多个 <code>DispatcherServlet</code>，那么 <code>Servlet</code> 被注册到哪了呢？</p><p>简单的回答：Servlet 容器。</p><p>没毛病！但马达马达大内！注册到了 Servlet 容器里的哪？存在什么结构里？</p><p>让我们以 Tomcat 容器为例，刨根问底。</p><h2 id="addRegistration"><a href="#addRegistration" class="headerlink" title="addRegistration"></a>addRegistration</h2><p>在 <code>ServletRegistrationBean</code> 中，有一个 <a href="https://github.com/spring-projects/spring-boot/blob/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/web/servlet/ServletRegistrationBean.java#L175-L179" target="_blank" rel="noopener">addRegistration</a> 方法，将具体的 Servlet 添加到了 ServletContext 中。</p><pre><code class="java">@Overrideprotected ServletRegistration.Dynamic addRegistration(String description, ServletContext servletContext) {  String name = getServletName();  return servletContext.addServlet(name, this.servlet);}</code></pre><h2 id="addServlet"><a href="#addServlet" class="headerlink" title="addServlet"></a>addServlet</h2><p>Servlet 容器负责提供 ServletContext 接口的实现。<br>在 Tomcat 中，ServletContext 的实现类为 <a href="https://github.com/apache/tomcat/blob/9.0.29/java/org/apache/catalina/core/ApplicationContext.java" target="_blank" rel="noopener">org.apache.catalina.core.ApplicationContext</a>。</p><p>其私有的 addServlet 方法，将注册的 Servlet <a href="https://github.com/apache/tomcat/blob/9.0.29/java/org/apache/catalina/core/ApplicationContext.java#L947" target="_blank" rel="noopener">放入了 Wrapper 中</a>。</p><pre><code class="java">wrapper.setServlet(servlet);</code></pre><p><a href="https://github.com/apache/tomcat/blob/9.0.29/java/org/apache/catalina/Wrapper.java" target="_blank" rel="noopener">org.apache.catalina.Wrapper</a> 会被作为 child 加入到 <a href="https://github.com/apache/tomcat/blob/9.0.29/java/org/apache/catalina/core/StandardContext.java" target="_blank" rel="noopener">StandardContext</a> 中。</p><h2 id="addChild"><a href="#addChild" class="headerlink" title="addChild"></a>addChild</h2><p>StandardContext 的 addChild 方法，会调用基类 <a href="https://github.com/apache/tomcat/blob/9.0.29/java/org/apache/catalina/core/ContainerBase.java" target="_blank" rel="noopener">ContainerBase</a> 的同名方法，进而调用 <a href="https://github.com/apache/tomcat/blob/9.0.29/java/org/apache/catalina/core/ContainerBase.java#L694" target="_blank" rel="noopener">ContainerBase#addChildInternal</a>，完成注册工作。</p><pre><code class="java">synchronized(children) {    if (children.get(child.getName()) != null)        throw new IllegalArgumentException(                sm.getString(&quot;containerBase.child.notUnique&quot;, child.getName()));    child.setParent(this);  // May throw IAE    children.put(child.getName(), child);}</code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Servlet 实例被包装至 StandardWrapper，注册到了其父容器 StandardContext 从基类 <a href="https://github.com/apache/tomcat/blob/9.0.29/java/org/apache/catalina/core/ContainerBase.java#L163" target="_blank" rel="noopener">ContainerBase</a> 继承的一个 <code>HashMap</code> 里。</p><pre><code class="java">/** * The child Containers belonging to this Container, keyed by name. */protected final HashMap&lt;String, Container&gt; children = new HashMap&lt;&gt;();</code></pre><h2 id="引申内容"><a href="#引申内容" class="headerlink" title="引申内容"></a>引申内容</h2><p>在 Tomcat Catalina 中，<a href="https://github.com/apache/tomcat/blob/9.0.29/java/org/apache/catalina/Container.java" target="_blank" rel="noopener">Container</a> 负责执行收到的请求，并基于请求返回响应。</p><p>Container 又扩展出<a href="https://github.com/apache/tomcat/blob/9.0.29/java/org/apache/catalina/Container.java#L39-L48" target="_blank" rel="noopener">四个接口</a>：</p><ol><li>Engine：代表整个 Catalina servlet 引擎，一般是包括一个或多个子容器，即 Host 或 Context 的实现，或其他自定义组。</li><li>Host：表示一个有拥有数个 Context 的虚拟主机。</li><li>Context：表示一个 ServletContext，包含一个或多个支持 Servlet 的 Wrapper。</li><li>Wrapper：表示一个独立的 Servlet。</li></ol><p><img src="/contents/where-are-servlets/container.png" alt="Container"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>还在给每个请求加前缀避免模块间接口冲突呢？</title>
      <link href="2020/04/24/multi-dispatcherservlet/"/>
      <url>2020/04/24/multi-dispatcherservlet/</url>
      
        <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>Spring MVC 按模块开发时，可能经常会遇到这个场景：一个模块由一个开发人员负责开发，模块内能较好的保证 RequestMapping 的 path 不重复，但模块间就很难有效的方式保证唯一。</p><p>通常有两种处理方式：</p><ol><li>对开发进行规范或约定，为每个模块起一个前缀，要求在模块内开发的所有 controller 都带上前缀，这样就只要保证模块内唯一即可。</li><li>每个模块部署为单独的服务，通过 servlet context path 进行区分。</li></ol><p>两种方式都能解决问题，但同时也都会带来一些问题：</p><ol><li>依赖开发、给开发带来额外负担、不够优雅；如果已经存在海量已完成的 controller，需要统一处理增加前缀。</li><li>可能导致本不需要拆分为独立服务的不合理拆分，服务粒度过细，造成额外负担。</li></ol><p>有没有更优雅的解决方案呢？</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>答案是肯定的。</p><p>定义多个 servlet 就好了嘛，每个 servlet 可以设定单独的 url mapping，同样能起到增加前缀的效果，一劳永逸，成本低，不增加额外负担。</p><p>Spring MVC 使用 <code>DispatcherServlet</code> 处理请求，在其 <a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L143-L146" target="_blank" rel="noopener">JavaDoc</a> 中有如下说明：</p><blockquote><ul><li><p><b>A web application can define any number of DispatcherServlets.</b></li></ul></blockquote><ul><li>Each servlet will operate in its own namespace, loading its own application context</li><li>with mappings, handlers, etc. Only the root application context as loaded by</li><li>{@link org.springframework.web.context.ContextLoaderListener}, if any, will be shared.</li></ul><p>传统 Spring MVC 项目中有 <code>web.xml</code> 文件，可以使用 <code>&lt;servlet&gt;</code> 及 <code>&lt;servlet-mapping&gt;</code> 配置多个 DispatcherServlet。</p><p>但在 Spring Boot 环境中，自动配置了一个开箱即用的 DispatcherServlet，映射路径为 <code>/</code>，而且没有了 <code>web.xml</code>，这个时候如果我们想配置多个 DispatcherServlet 要怎么做呢？</p><p>Spring Boot 提供了一个 <code>org.springframework.boot.web.servlet.ServletRegistrationBean</code> 来满足注册 servlet 的需求，可以像注册 bean 一样配置 servlet。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>直接上实例：<a href="https://github.com/AlphaHinex/multi-dispatcher" target="_blank" rel="noopener">https://github.com/AlphaHinex/multi-dispatcher</a></p><p>实例中定义了三个 Controller，分别对应默认的 DispatcherServlet 和自定义的两个不同的 url mapping：</p><pre><code class="java">@Beanpublic ServletRegistrationBean fooServlet() {    DispatcherServlet fooServlet = new DispatcherServlet();    AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();    context.register(FooConfiguration.class);    fooServlet.setApplicationContext(context);    ServletRegistrationBean&lt;DispatcherServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(fooServlet, &quot;/foo/*&quot;);    bean.setName(&quot;Foo servlet&quot;);    bean.setLoadOnStartup(1);    return bean;}@Beanpublic ServletRegistrationBean barServlet() {    AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();    context.scan(&quot;alpha.hinex.demo.bar&quot;);    DispatcherServlet barServlet = new DispatcherServlet(context);    ServletRegistrationBean&lt;DispatcherServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(barServlet, &quot;/bar/*&quot;);    bean.setName(&quot;Bar servlet&quot;);    bean.setLoadOnStartup(1);    return bean;}</code></pre><p>按不同方式为两个自定义的 DispatcherServlet 进行配置：</p><pre><code class="java">@Configuration@EnableWebMvc@ComponentScan(&quot;alpha.hinex.demo.foo.controller&quot;)public class FooConfiguration implements WebMvcConfigurer {}</code></pre><pre><code class="java">@Configurationpublic class BarConfiguration extends WebMvcConfigurationSupport {}</code></pre><p>两个对应自定义 DispatcherServlet 的 Controller 上配置的 RequestMapping 的 path 是相同的 <code>/same/path</code>。</p><p>可在实例中，启动应用进行验证，或执行集成测试验证效果。详细可见实例 <a href="https://github.com/AlphaHinex/multi-dispatcher/README.md" target="_blank" rel="noopener">README</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
            <tag> Servlet </tag>
            
            <tag> MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 中如何根据请求调用对应方法</title>
      <link href="2020/04/17/invoke-controller-by-request/"/>
      <url>2020/04/17/invoke-controller-by-request/</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>假设能够获得到一个 <code>HttpServletRequest</code>，需要根据这个请求内的具体信息，找到其所对应的 Spring Controller 中的方法，并对方法进行调用，获得该方法的返回值。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个需求，与 <code>DispatcherServlet</code> 的作用非常类似。先看一下请求到达 <code>DispatcherServlet</code> 之后的处理流程：</p><p><img src="/contents/invoke-controller-by-request/spring-mvc.jpg" alt="DispatcherServlet Processing"></p><p>因为最终目标是获得请求对应的 Controller 方法的返回值，所以上图中的流程走到第 4 步即可。</p><ol><li>HttpServletRequest 请求抵达 DispatcherServlet</li><li>通过 HandlerMapping 将请求映射到处理器（Handler)和拦截器</li><li>通过 Handler 找到对应的 HandlerAdapter</li><li>通过 HandlerAdapter 调用处理器</li></ol><p>以 <a href="https://github.com/spring-projects/spring-framework/tree/v5.2.2.RELEASE" target="_blank" rel="noopener">Spring Framework v5.2.2.RELEASE</a> 版本为例，<br>看看 DispatcherServlet 实现上述功能的过程：</p><h2 id="HttpServletRequest-请求抵达-DispatcherServlet"><a href="#HttpServletRequest-请求抵达-DispatcherServlet" class="headerlink" title="HttpServletRequest 请求抵达 DispatcherServlet"></a>HttpServletRequest 请求抵达 DispatcherServlet</h2><p>HttpServletRequest 被 Servlet 容器和 Spring Framework 送至  <a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L910" target="_blank" rel="noopener">org.springframework.web.servlet.DispatcherServlet#doService</a>，之后委托 <a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1000" target="_blank" rel="noopener">org.springframework.web.servlet.DispatcherServlet#doDispatch</a> 执行真正的请求分发。</p><h2 id="通过-HandlerMapping-将请求映射到处理器（Handler-和拦截器"><a href="#通过-HandlerMapping-将请求映射到处理器（Handler-和拦截器" class="headerlink" title="通过 HandlerMapping 将请求映射到处理器（Handler)和拦截器"></a>通过 HandlerMapping 将请求映射到处理器（Handler)和拦截器</h2><p>在 <code>doDispatch</code> 中，调用 <code>getHandler</code> 方法，根据 <code>HttpServletRequest</code> 获得 <code>HandlerExecutionChain</code>。</p><p><a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1224-L1241" target="_blank" rel="noopener">DispatcherServlet.java#L1224-L1241</a></p><pre><code class="java">/** * Return the HandlerExecutionChain for this request. * &lt;p&gt;Tries all handler mappings in order. * @param request current HTTP request * @return the HandlerExecutionChain, or {@code null} if no handler could be found */@Nullableprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {    if (this.handlerMappings != null) {        for (HandlerMapping mapping : this.handlerMappings) {            HandlerExecutionChain handler = mapping.getHandler(request);            if (handler != null) {                return handler;            }        }    }    return null;}</code></pre><p>该方法中，遍历在该类上初始化好的所有 <a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/HandlerMapping.java" target="_blank" rel="noopener">HandlerMapping</a>，<code>HandlerMapping</code> 接口中定义的唯一一个方法，与上述方法签名相同。</p><p><a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/HandlerMapping.java#L132-L148" target="_blank" rel="noopener">HandlerMapping.java#L132-L148</a></p><pre><code class="java">@NullableHandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;</code></pre><p><a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/HandlerExecutionChain.java" target="_blank" rel="noopener">HandlerExecutionChain</a> 是一个包含一个处理器（Handler）和一个拦截器（HandlerInterceptor）集合的结构体，其中的 Handler 就是我们需要的 Controller。</p><h2 id="通过-Handler-找到对应的-HandlerAdapter"><a href="#通过-Handler-找到对应的-HandlerAdapter" class="headerlink" title="通过 Handler 找到对应的 HandlerAdapter"></a>通过 Handler 找到对应的 HandlerAdapter</h2><p>从 <code>HandlerExecutionChain</code> 中获得到 handler 之后，可以根据 handler 找到对应的适配器（HandlerAdapter）。</p><p><a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/DispatcherServlet.java#L1262-L1277" target="_blank" rel="noopener">DispatcherServlet.java#L1262-L1277</a></p><pre><code class="java">/** * Return the HandlerAdapter for this handler object. * @param handler the handler object to find an adapter for * @throws ServletException if no HandlerAdapter can be found for the handler. This is a fatal error. */protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {    if (this.handlerAdapters != null) {        for (HandlerAdapter adapter : this.handlerAdapters) {            if (adapter.supports(handler)) {                return adapter;            }        }    }    throw new ServletException(&quot;No adapter for handler [&quot; + handler +            &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);}</code></pre><p><a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/HandlerAdapter.java" target="_blank" rel="noopener">HandlerAdapter</a> 接口定义了三个方法：</p><pre><code class="java">boolean supports(Object handler);@NullableModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;long getLastModified(HttpServletRequest request, Object handler);</code></pre><h2 id="通过-HandlerAdapter-调用处理器"><a href="#通过-HandlerAdapter-调用处理器" class="headerlink" title="通过 HandlerAdapter 调用处理器"></a>通过 HandlerAdapter 调用处理器</h2><p>可以看到 <code>handle</code> 方法的返回值类型是 <code>ModelAndView</code>，即此方法完成了上图中的 4、5 两步。而我们的需求中只需要根据请求找到并调用 Controller 对应的方法，并获得该方法的返回值。</p><p>Spring 为其 Controller 提供了 HandlerMapping 和 HandlerAdapter 接口的对应实现：<a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerMapping.java" target="_blank" rel="noopener">RequestMappingHandlerMapping</a> 和 <a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java" target="_blank" rel="noopener">RequestMappingHandlerAdapter</a>。</p><h3 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h3><p><img src="/contents/invoke-controller-by-request/RequestMappingHandlerMapping.png" alt="RequestMappingHandlerMapping"></p><p>抽象类 <code>AbstractHandlerMapping</code> 在实现 <code>HanlderMapping</code> 接口的 <code>getHandler</code> 方法时，将获得具体 handler 的方法委托给了抽象方法 <code>getHandlerInternal</code>。</p><p><a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L441-L442" target="_blank" rel="noopener">AbstractHandlerMapping.java#L441-L442</a></p><pre><code class="java">@Nullableprotected abstract Object getHandlerInternal(HttpServletRequest request) throws Exception;</code></pre><p>继承了这个抽象类的 <code>AbstractHandlerMethodMapping</code> 将 <code>getHandlerInternal</code> 方法的返回值类型具体化为了 <code>HandlerMethod</code>。</p><p><a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.java#L358-L373" target="_blank" rel="noopener">AbstractHandlerMethodMapping.java#L358-L373</a></p><pre><code class="java">/** * Look up a handler method for the given request. */@Overrideprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);    request.setAttribute(LOOKUP_PATH, lookupPath);    this.mappingRegistry.acquireReadLock();    try {        HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);        return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null);    }    finally {        this.mappingRegistry.releaseReadLock();    }}</code></pre><p><a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-web/src/main/java/org/springframework/web/method/HandlerMethod.java" target="_blank" rel="noopener">HandlerMethod</a> 将 handler 的 method 信息进行了封装，可以方便的获得 method，bean，入参及返回值类型信息，以及注解等信息。</p><h3 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h3><p><img src="/contents/invoke-controller-by-request/RequestMappingHandlerAdapter.png" alt="RequestMappingHandlerAdapter"></p><p>在 <code>RequestMappingHandlerAdapter</code> 继承的 <code>AbstractHandlerMethodAdapter</code> 中，实现了 <code>HandlerAdapter</code> 中的 <code>handler</code> 方法，将 handler 具体化为 <code>HandlerMethod</code> 类型，并交由 <code>handlerInternal</code> 抽象方法进行实现。</p><p><a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/AbstractHandlerMethodAdapter.java#L79-L88" target="_blank" rel="noopener">AbstractHandlerMethodAdapter.java#L79-L88</a></p><pre><code class="java">/** * This implementation expects the handler to be an {@link HandlerMethod}. */@Override@Nullablepublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)        throws Exception {    return handleInternal(request, response, (HandlerMethod) handler);}</code></pre><p><code>RequestMappingHandlerAdapter</code> 的 <a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L771" target="_blank" rel="noopener">handleInternal</a> 方法通过 <a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.java#L845" target="_blank" rel="noopener">invokeHandlerMethod</a> 来调用 handler，并将结果封装为 <code>ModelAndView</code> 返回。</p><p>终于刨到根了！</p><h3 id="invokeHandlerMethod"><a href="#invokeHandlerMethod" class="headerlink" title="invokeHandlerMethod"></a>invokeHandlerMethod</h3><p>先来看下方法签名：</p><pre><code class="java">/** * Invoke the {@link RequestMapping} handler method preparing a {@link ModelAndView} * if view resolution is required. * @since 4.2 * @see #createInvocableHandlerMethod(HandlerMethod) */@Nullableprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,        HttpServletResponse response, HandlerMethod handlerMethod) throws Exception</code></pre><p>方法体中，先根据 HandlerMethod 构建了一个 <code>ServletInvocableHandlerMethod</code></p><pre><code class="java">ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</code></pre><p>进行必要的设置（如入参解析器及返回值处理器等）之后，进行实际调用及处理：</p><pre><code class="java">invocableMethod.invokeAndHandle(webRequest, mavContainer);</code></pre><p><code>ServletInvocableHandlerMethod</code> 的 <a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/ServletInvocableHandlerMethod.java#L103" target="_blank" rel="noopener">invokeAndHandle</a> 方法执行了实际调用并获得返回值对象：</p><pre><code class="java">Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</code></pre><p><code>invokeForRequest</code> 为定义在 <a href="https://github.com/spring-projects/spring-framework/blob/v5.2.2.RELEASE/spring-web/src/main/java/org/springframework/web/method/support/InvocableHandlerMethod.java" target="_blank" rel="noopener">InvocableHandlerMethod</a> 中的方法，从请求中解析出具体 Controller 方法的入参，并通过反射进行调用。</p><pre><code class="java">/** * Invoke the method after resolving its argument values in the context of the given request. * &lt;p&gt;Argument values are commonly resolved through * {@link HandlerMethodArgumentResolver HandlerMethodArgumentResolvers}. * The {@code providedArgs} parameter however may supply argument values to be used directly, * i.e. without argument resolution. Examples of provided argument values include a * {@link WebDataBinder}, a {@link SessionStatus}, or a thrown exception instance. * Provided argument values are checked before argument resolvers. * &lt;p&gt;Delegates to {@link #getMethodArgumentValues} and calls {@link #doInvoke} with the * resolved arguments. * @param request the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs &quot;given&quot; arguments matched by type, not resolved * @return the raw value returned by the invoked method * @throws Exception raised if no suitable argument resolver can be found, * or if the method raised an exception * @see #getMethodArgumentValues * @see #doInvoke */@Nullablepublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,        Object... providedArgs) throws Exception {    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);    if (logger.isTraceEnabled()) {        logger.trace(&quot;Arguments: &quot; + Arrays.toString(args));    }    return doInvoke(args);}</code></pre><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>综上，要满足本文开始处提到的需求，需要实现：</p><ol><li>根据请求找到对应的 RequestMappingHandlerMapping</li><li>从 HandlerMapping 中获得 HandlerExecutionChain</li><li>从 HandlerExecutionChain 中获得 HandlerMethod</li><li>利用 HandlerMethod 构造一个 InvocableHandlerMethod</li><li>根据 HandlerMethod 找到对应的 RequestMappingHandlerAdapter</li><li>从 RequestMappingHandlerAdapter 中获得入参解析器集合</li><li>调用 InvocableHandlerMethod 的 invokeForRequest 方法，获得实际返回值</li></ol><p>关键部分代码如下：</p><pre><code class="java">/** * Invoke controller method according to input request. * Could build a request with ArtificialHttpServletRequest * * @param  request http servlet request * @return output of controller method or null when could not mapping a controller * @throws Exception exception will be thrown when getHandler or invokeForRequest */public Object invoke(HttpServletRequest request) throws Exception {    // Find the handler method by request    Optional&lt;HandlerMethod&gt; handlerMethod = handlerMethodHolder.getHandlerMethod(request);    Assert.isTrue(handlerMethod.isPresent(), &quot;Could NOT find handler method for request &quot; + request.getRequestURI());    InvocableHandlerMethod invocableHandlerMethod = new InvocableHandlerMethod(handlerMethod.get());    // Set resolvers    HandlerMethodArgumentResolverComposite composite = new HandlerMethodArgumentResolverComposite();    RequestMappingHandlerAdapter handlerAdapter = getHandlerAdapter(invocableHandlerMethod);    composite.addResolvers(handlerAdapter.getArgumentResolvers());    invocableHandlerMethod.setHandlerMethodArgumentResolvers(composite);    // Set data binder factory    invocableHandlerMethod.setDataBinderFactory(            new ServletRequestDataBinderFactory(new ArrayList&lt;&gt;(), new ConfigurableWebBindingInitializer()));    NativeWebRequest nativeWebRequest = new DispatcherServletWebRequest(request);    return invocableHandlerMethod.invokeForRequest(nativeWebRequest, new ModelAndViewContainer());}</code></pre><p>实例可见 <a href="https://github.com/AlphaHinex/spring-roll/blob/develop/modules/raw-materials/roll-web/src/main/java/io/github/springroll/web/request/InvokeControllerByRequest.java" target="_blank" rel="noopener">InvokeControllerByRequest.java</a> 及单元测试 <a href="https://github.com/AlphaHinex/spring-roll/blob/develop/modules/raw-materials/roll-web/src/test/groovy/io/github/springroll/web/request/InvokeControllerByRequestTest.groovy" target="_blank" rel="noopener">InvokeControllerByRequestTest.groovy</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
            <tag> Servlet </tag>
            
            <tag> MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Netty in Action》书摘</title>
      <link href="2020/04/10/netty-in-action/"/>
      <url>2020/04/10/netty-in-action/</url>
      
        <content type="html"><![CDATA[<p>Start at: 2020-01-05<br>End at: 2020-03-28<br>Process: 298/298</p><ul><li><a href="https://www.manning.com/books/netty-in-action" target="_blank" rel="noopener">https://www.manning.com/books/netty-in-action</a></li><li><a href="https://github.com/normanmaurer/netty-in-action" target="_blank" rel="noopener">https://github.com/normanmaurer/netty-in-action</a></li></ul><h1 id="3-Netty-components-and-design"><a href="#3-Netty-components-and-design" class="headerlink" title="3 Netty components and design"></a>3 Netty components and design</h1><h2 id="3-1-Channel-EventLoop-and-ChannelFuture"><a href="#3-1-Channel-EventLoop-and-ChannelFuture" class="headerlink" title="3.1 Channel, EventLoop, and ChannelFuture"></a>3.1 Channel, EventLoop, and ChannelFuture</h2><h3 id="3-1-2-Interface-EventLoop"><a href="#3-1-2-Interface-EventLoop" class="headerlink" title="3.1.2 Interface EventLoop"></a>3.1.2 Interface EventLoop</h3><p><img src="/contents/netty-in-action/3.1.2.png" alt="Channels, EventLoops, and EventLoopGroups"></p><ul><li>An <code>EventLoopGroup</code> contains one or more <code>EventLoop</code>s.</li><li>An <code>EventLoop</code> is bound to a single <code>Thread</code> for its lifetime.</li><li>All I/O events processed by an <code>EventLoop</code> are handled on its dedicated <code>Thread</code>.</li><li>A <code>Channel</code> is registered for its lifetime with a single <code>EventLoop</code>.</li><li>A single <code>EventLoop</code> may be assigned to one or more <code>Channel</code>s.</li></ul><h1 id="4-Transports"><a href="#4-Transports" class="headerlink" title="4 Transports"></a>4 Transports</h1><h2 id="4-3-Included-transports"><a href="#4-3-Included-transports" class="headerlink" title="4.3 Included transports"></a>4.3 Included transports</h2><h3 id="4-3-1-NIO-——-non-blocking-I-O"><a href="#4-3-1-NIO-——-non-blocking-I-O" class="headerlink" title="4.3.1 NIO —— non-blocking I/O"></a>4.3.1 NIO —— non-blocking I/O</h3><ul><li>Zero-copy is a feature currently available only with NIO and Epoll transport. It allows you to quickly and efficiently move data from a file system to the network without copying from kernel space to user space, which can significantly improve performance in protocols such as FTP or HTTP. This feature is not supported by all OSes. Specifically it is not usable with file systems that implement data encryption or compression—only the raw content of a file can be transferred. Conversely, transferring files that have already been encrypted isn’t a problem.</li></ul><h1 id="5-ByteBuf"><a href="#5-ByteBuf" class="headerlink" title="5 ByteBuf"></a>5 ByteBuf</h1><h2 id="5-2-Class-ByteBuf—Netty’s-data-container"><a href="#5-2-Class-ByteBuf—Netty’s-data-container" class="headerlink" title="5.2 Class ByteBuf—Netty’s data container"></a>5.2 Class ByteBuf—Netty’s data container</h2><h3 id="5-2-2-ByteBuf-usage-patterns"><a href="#5-2-2-ByteBuf-usage-patterns" class="headerlink" title="5.2.2 ByteBuf usage patterns"></a>5.2.2 ByteBuf usage patterns</h3><ul><li>If ByteBuf isn’t backed by an array. If not, this is a direct buffer.</li><li>The ByteBuf instances in a CompositeByteBuf may include both direct and nondirect allocations. If there is only one instance, calling has- Array() on a CompositeByteBuf will return the hasArray() value of that component; otherwise it will return false.</li></ul><h2 id="5-3-Byte-level-operations"><a href="#5-3-Byte-level-operations" class="headerlink" title="5.3 Byte-level operations"></a>5.3 Byte-level operations</h2><h3 id="5-3-2-Sequential-access-indexing"><a href="#5-3-2-Sequential-access-indexing" class="headerlink" title="5.3.2 Sequential access indexing"></a>5.3.2 Sequential access indexing</h3><ul><li>While ByteBuf has both reader and writer indices, the JDK’s ByteBuffer has only one, which is why you have to call flip() to switch between read and write modes.</li></ul><h3 id="5-3-8-Derived-buffers"><a href="#5-3-8-Derived-buffers" class="headerlink" title="5.3.8 Derived buffers"></a>5.3.8 Derived buffers</h3><ul><li><code>duplicate()</code>, <code>slice()</code>, <code>slice(int, int)</code>, <code>Unpooled.unmodifiableBuffer(...)</code>, <code>order(ByteOrder)</code>, <code>readSlice(int)</code>, each returns a new <code>ByteBuf</code> instance with its own reader, writer, and marker indices. The internal storage is shared just as in a JDK <code>ByteBuffer</code>. This makes a derived buffer inexpensive to create, but it also means that if you modify its contents you are modifying the source instance as well, so beware.</li><li>If you need a true copy of an existing buffer, use <code>copy()</code> or <code>copy(int,int)</code>. Unlike a derived buffer, the <code>ByteBuf</code> returned by this call has an independent copy of the data.</li></ul><h1 id="6-ChannelHandler-and-ChannelPipeline"><a href="#6-ChannelHandler-and-ChannelPipeline" class="headerlink" title="6 ChannelHandler and ChannelPipeline"></a>6 ChannelHandler and ChannelPipeline</h1><h2 id="6-1-The-ChannelHandler-family"><a href="#6-1-The-ChannelHandler-family" class="headerlink" title="6.1 The ChannelHandler family"></a>6.1 The ChannelHandler family</h2><h3 id="6-1-3-Interface-ChannelInboundHandler"><a href="#6-1-3-Interface-ChannelInboundHandler" class="headerlink" title="6.1.3 Interface ChannelInboundHandler"></a>6.1.3 Interface ChannelInboundHandler</h3><ul><li>When a ChannelInboundHandler implementation overrides channelRead(), it is responsible for explicitly releasing the memory associated with pooled ByteBuf instances. Netty provides a utility method for this purpose, ReferenceCountUtil.relese()</li><li>A simpler alternative is to use SimpleChannelInboundHandler. … Because SimpleChannelInboundHandler releases resources automatically, you shouldn’t store references to any messages for later use, as these will become invalid.</li></ul><h3 id="6-1-4-Interface-ChannelOutboundHandler"><a href="#6-1-4-Interface-ChannelOutboundHandler" class="headerlink" title="6.1.4 Interface ChannelOutboundHandler"></a>6.1.4 Interface ChannelOutboundHandler</h3><ul><li>ChannelPromise vs. ChannelFuture: ChannelPromise is a subinterface of ChannelFuture that defines the writable methods, … thus making ChannelFuture immutable.</li></ul><h3 id="6-1-6-Resource-management"><a href="#6-1-6-Resource-management" class="headerlink" title="6.1.6 Resource management"></a>6.1.6 Resource management</h3><ul><li>On the outbound side, if you handle a write() operation and discard a message, you’re responsible for releasing it.</li><li>It’s important not only to release resources but also to notify the ChannelPromise. Otherwise a situation might arise where a ChannelFutureListener has not been notified about a message that has been handled.</li><li>In sum, it is the responsibility of the user to call ReferenceCountUtil.release() if a message is consumed or discarded and not passed to the next ChannelOutboundHandler in the ChannelPipeline. If the message reaches the actual transport layer, it will be released automatically when it’s written or the Channel is closed.</li></ul><h2 id="6-2-Interface-ChannelPipeline"><a href="#6-2-Interface-ChannelPipeline" class="headerlink" title="6.2 Interface ChannelPipeline"></a>6.2 Interface ChannelPipeline</h2><ul><li>Every new Channel that’s created is assigned a new ChannelPipeline. This association is permanent; the Channel can neither attach another ChannelPipeline nor detach the current one. This is a fixed operation in Netty’s component lifecycle and requires no action on the part of the developer.</li></ul><h2 id="6-3-Interface-ChannelHandlerContext"><a href="#6-3-Interface-ChannelHandlerContext" class="headerlink" title="6.3 Interface ChannelHandlerContext"></a>6.3 Interface ChannelHandlerContext</h2><ul><li><code>ChannelHandlerContext</code> has numerous methods, some of which are also present on <code>Channel</code> and on <code>ChannelPipeline</code> itself, but there is an important difference. If you invoke these methods on a <code>Channel</code> or <code>ChannelPipeline</code> instance, they propagate through the entire pipeline. The same methods called on a <code>ChannelHandlerContext</code> will start at the current associated <code>ChannelHandler</code> and propagate only to the next <code>ChannelHandler</code> in the pipeline that is capable of handling the event.</li></ul><h1 id="7-EventLoop-and-threading-model"><a href="#7-EventLoop-and-threading-model" class="headerlink" title="7 EventLoop and threading model"></a>7 EventLoop and threading model</h1><h2 id="7-3-Task-scheduling"><a href="#7-3-Task-scheduling" class="headerlink" title="7.3 Task scheduling"></a>7.3 Task scheduling</h2><h3 id="7-3-1-JDK-scheduling-API"><a href="#7-3-1-JDK-scheduling-API" class="headerlink" title="7.3.1 JDK scheduling API"></a>7.3.1 JDK scheduling API</h3><ul><li>Although the <code>ScheduledExecutorService</code> API is straightforward, under heavy load it can introduce performance costs. In the next section we’ll see how Netty provides the same functionality with greater efficiency.</li></ul><h3 id="7-3-2-Scheduling-tasks-using-EventLoop"><a href="#7-3-2-Scheduling-tasks-using-EventLoop" class="headerlink" title="7.3.2 Scheduling tasks using EventLoop"></a>7.3.2 Scheduling tasks using EventLoop</h3><ul><li>The <code>ScheduledExecutorService</code> implementation has limitations, such as the fact that extra threads are created as part of pool management. This can become a bottleneck if many tasks are aggressively scheduled.</li></ul><h2 id="7-4-Implementation-details"><a href="#7-4-Implementation-details" class="headerlink" title="7.4 Implementation details"></a>7.4 Implementation details</h2><h3 id="7-4-1-Thread-management"><a href="#7-4-1-Thread-management" class="headerlink" title="7.4.1 Thread management"></a>7.4.1 Thread management</h3><ul><li>Note that each EvetnLoop has its own task queue, independent of that of any other EventLoop.</li><li>Never put a long-running task in the execution queue, because it will block any other task from executing on the same thread.</li><li>If you must make blocking calls or execute long-running tasks, we advise the use of a dedicated EventExecutor.</li></ul><h3 id="7-4-2-EventLoop-thread-allocation"><a href="#7-4-2-EventLoop-thread-allocation" class="headerlink" title="7.4.2 EventLoop/thread allocation"></a>7.4.2 EventLoop/thread allocation</h3><p><img src="/contents/netty-in-action/7.4.png" alt="Figure 7.4"></p><p><img src="/contents/netty-in-action/7.5.png" alt="Figure 7.5"></p><h1 id="8-Bootstrapping"><a href="#8-Bootstrapping" class="headerlink" title="8 Bootstrapping"></a>8 Bootstrapping</h1><h2 id="8-4-Bootstrapping-clients-from-a-Channel"><a href="#8-4-Bootstrapping-clients-from-a-Channel" class="headerlink" title="8.4 Bootstrapping clients from a Channel"></a>8.4 Bootstrapping clients from a Channel</h2><ul><li>a general guideline in coding Netty applications: reuse EventLoops wherever possible to reduce the cost of thread creation.</li></ul><h1 id="9-Unit-testing"><a href="#9-Unit-testing" class="headerlink" title="9 Unit testing"></a>9 Unit testing</h1><ul><li><p>Best practices dictate that you test not only to prove that your implementation is correct, but also to make it easy to isolate problems that crop up as code is modified. This type of testing is called unit testing.</p></li><li><p>The basic idea is to test your code in the smallest possible chunks, isolated as much as possible from other code modules and from runtime dependencies such as databases and networks. If you can verify through testing that each unit works correctly by itself, it will be much easier to find the culprit when something goes awry.</p></li></ul><h1 id="10-The-codec-framework"><a href="#10-The-codec-framework" class="headerlink" title="10 The codec framework"></a>10 The codec framework</h1><h2 id="10-3-Encoders"><a href="#10-3-Encoders" class="headerlink" title="10.3 Encoders"></a>10.3 Encoders</h2><h3 id="10-3-1-Abstract-class-MessageToByteEncoder"><a href="#10-3-1-Abstract-class-MessageToByteEncoder" class="headerlink" title="10.3.1 Abstract class MessageToByteEncoder"></a>10.3.1 Abstract class MessageToByteEncoder</h3><ul><li>You may have noticed that this class has only one method, while decoders have two. The reason is that decoders often need to produce a last message after the <code>Channel</code> has closed (hence the <code>decodeLast()</code> method). This is clearly not the case for an encoder—there is no sense in producing a message after the connection has been closed.</li></ul><h1 id="11-Provided-ChannelHandlers-and-codecs"><a href="#11-Provided-ChannelHandlers-and-codecs" class="headerlink" title="11 Provided ChannelHandlers and codecs"></a>11 Provided ChannelHandlers and codecs</h1><h2 id="11-5-Writing-big-data"><a href="#11-5-Writing-big-data" class="headerlink" title="11.5 Writing big data"></a>11.5 Writing big data</h2><ul><li>In cases where you need to copy the data from the file system into user memory, you can use <code>ChunkedWriteHandler</code>, which provides support for writing a large data stream asynchronously without incurring high memory consumption.</li><li>The key is <code>interface ChunkedInput&lt;B&gt;</code>, where the parameter <code>B</code> is the type returned by the method <code>readChunk()</code>. Four implementations of this interface are provided, as listed in table 11.7. Each one represents a data stream of indefinite length to be consumed by a <code>ChunkedWriteHandler</code>.</li></ul><h2 id="11-6-Serializing-data"><a href="#11-6-Serializing-data" class="headerlink" title="11.6 Serializing data"></a>11.6 Serializing data</h2><h3 id="11-6-2-Serialization-with-JBoss-Marshalling"><a href="#11-6-2-Serialization-with-JBoss-Marshalling" class="headerlink" title="11.6.2 Serialization with JBoss Marshalling"></a>11.6.2 Serialization with JBoss Marshalling</h3><ul><li>It’s up to three times faster than JDK Serialization and more compact. The overview on the JBoss Marshalling homepage defines it this way:</li><li>JBoss Marshalling is an alternative serialization API that fixes many of the problems found in the JDK serialization API while remaining fully compatible with java.io.Serializable and its relatives, and adds several new tunable parameters and additional features, all of which are pluggable via factory configuration (externalizers, class/instance lookup tables, class resolution, and object replacement, to name a few).</li></ul><h1 id="14-Case-studies-part-1"><a href="#14-Case-studies-part-1" class="headerlink" title="14 Case studies, part 1"></a>14 Case studies, part 1</h1><h2 id="14-3-Urban-Airship—building-mobile-services"><a href="#14-3-Urban-Airship—building-mobile-services" class="headerlink" title="14.3 Urban Airship—building mobile services"></a>14.3 Urban Airship—building mobile services</h2><h3 id="14-3-5-Netty-excels-at-managing-large-numbers-of-concurrent-connections"><a href="#14-3-5-Netty-excels-at-managing-large-numbers-of-concurrent-connections" class="headerlink" title="14.3.5 Netty excels at managing large numbers of concurrent connections"></a>14.3.5 Netty excels at managing large numbers of concurrent connections</h3><ul><li>As mentioned in the previous section, Netty makes supporting asynchronous I/O on the JVM trivial. Because Netty operates on the JVM, and because the JVM on Linux ultimately uses the Linux epoll facility to manage interest in socket file descriptors, Netty makes it possible to accommodate the rapid growth of mobile by allowing developers to easily accept large numbers of open sockets—close to 1 million TCP connections per single Linux process. At numbers of this scale, service providers can keep costs low, allowing a large number of devices to connect to a single process on a physical server.</li><li>Note the distinction of a physical server in this case. Although virtualization offers many benefits, leading cloud providers were regularly unable to accommodate more than 200,000–300,000 concurrent TCP connections to a single virtual host. With connections at or above this scale, expect to use bare metal servers and expect to pay close attention to the NIC (Network Interface Card) vendor.</li></ul><h1 id="Introduction-to-Maven"><a href="#Introduction-to-Maven" class="headerlink" title="Introduction to Maven"></a>Introduction to Maven</h1><h2 id="A2-2-POM-Inheritance-and-aggregation"><a href="#A2-2-POM-Inheritance-and-aggregation" class="headerlink" title="A2.2 POM Inheritance and aggregation"></a>A2.2 POM Inheritance and aggregation</h2><ul><li>The POM executed by Maven after all inherited information is assembled and all active profiles are applied is referred to as the “effective POM”. To see it, run the following Maven command in the same directory as any POM file: <code>mvn help:effective-pom</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3 动画还不够香</title>
      <link href="2020/04/03/css3-animation-cpu-usage-issue/"/>
      <url>2020/04/03/css3-animation-cpu-usage-issue/</url>
      
        <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>页面加载完毕静置一小会之后，CPU 使用率居高不下，风扇巨响，发热严重。关闭页面后现象消失。</p><h3 id="重现方式"><a href="#重现方式" class="headerlink" title="重现方式"></a>重现方式</h3><pre><code class="bash">$ git clone https://github.com/AlphaHinex/AlphaHinex.github.io.git$ cd AlphaHinex.github.io$ git checkout cdf1d11$ npm install$ npm audit fix$ cd themes/obsidian$ npm install$ cd ../..$ hexo server</code></pre><p>看到如下提示后，访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><pre><code class="console">INFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><p>在首页或打开博文页，观察 CPU 使用情况。如下图:</p><p><img src="/contents/css3-animation-cpu-usage-issue/cpu-usage-before.png" alt="CPU Usage - Before"></p><p>在页面静置时，<code>Google Chrome Helper (Renderer)</code> 的 CPU 使用率在 30% 以上至 40% 左右，<code>Google Chrome Helper (GPU)</code> 的 CPU 使用率也稳定在 30% 左右。滚动页面时，这两个进程的 CPU 使用率会继续上升。</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>页面上的内容都已经加载完了，上面 Renderer 和 GPU 两个进程还在持续使用这么多 CPU 资源，显然是不合理的。那么怎么找出罪魁祸首呢？</p><h3 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h3><p>在 Chrome 的 <code>任务管理器</code> 中，可以直观的看到是哪个标签页消耗了过多的资源。</p><p><img src="/contents/css3-animation-cpu-usage-issue/task-manager-1.png" alt="Path to Task Manager"></p><p><img src="/contents/css3-animation-cpu-usage-issue/task-manager-2.png" alt="Task List"></p><h3 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h3><p>操作系统和 Chrome 的任务管理器，都将问题指向了页面渲染。但是从界面上，并没有看到明显的在持续渲染的内容，也就不容易定位到具体的问题。这时可以使用 Chrome 开发者工具中提供的 Rendering 工具，位置如图：</p><p><img src="/contents/css3-animation-cpu-usage-issue/rendering.png" alt="Rendering"></p><p>打开 Rendering 后，如图勾选三个选项：</p><ol><li>Paint flashing</li><li>Layout Shift Regions</li><li>Layer borders</li></ol><p>之后再看下界面，可以发现一些蛛丝马迹。</p><p><img src="/contents/css3-animation-cpu-usage-issue/mov.gif" alt="Three animations"></p><p>从动图中可以看到，界面上共有三处动画：</p><ol><li>左侧中间位置蓝色方块（不开 Layout Shift Regions 在页面上根本看不到这东西）。这个是页面 loading 效果，在 loading 结束后，被设置为了透明，虽然看不见，但实际仍然在持续的进行渲染</li><li>右上 TOC 处原点扩散水波纹效果</li><li>右下百分比处水浪效果</li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>定位到了问题，解决起来就容易了。</p><ol><li>loading 效果原来的处理方式是通过设置透明变为不可见，可调整为在不需要的时候直接不显示。</li><li>另外两处无限循环的效果，简单粗暴的处理方式可以直接不进行效果的循环，或者将 CSS 动画改为 gif 动图，可显著降低 CPU 使用率。</li></ol><blockquote><p>参考资料中的 <code>translateZ(0)</code>、<code>will-change</code> 等方案，在本例中并未发现明显效果。</p></blockquote><p>改动内容可参考：</p><pre><code class="diff">diff --git a/themes/obsidian/source/css/obsidian.styl b/themes/obsidian/source/css/obsidian.stylindex eebc3fa..6b7494a 100644--- a/themes/obsidian/source/css/obsidian.styl+++ b/themes/obsidian/source/css/obsidian.styl@@ -18,13 +18,14 @@ body {   line-height: 2;   .loader {+    display: none;     width: 100vw;     height: 100vh;     position: fixed;     top: 0;     left: 0;     transition: opacity 600ms linear;-    opacity: 0;+    opacity: 1;     z-index: 1000;     background: #100e17;@@ -100,7 +101,7 @@ html { body.loading {   .loader {-    opacity: 1;+    display: block;   }@@ -319,9 +320,6 @@ img.spin {   position: relative;   z-index: 0;   border-bottom-right-radius: 180px;-  -webkit-animation: GradientEffect 1.2s ease infinite;-  -moz-animation: GradientEffect 1.2s ease infinite;-  animation: GradientEffect 1.2s ease infinite; } .screen-gradient-content {@@ -1164,7 +1162,7 @@ footer {       opacity: 0.4;       border-radius: 45%;       transform: translate(-50%, -70%) rotate(0);-      animation: rotate 6s linear infinite;+      animation: rotate 6s linear;       z-index: 10;     }@@ -1175,7 +1173,7 @@ footer {       background: linear-gradient(var(--dark), var(--secondary)) !important;       opacity: 0.9;       transform: translate(-50%, -70%) rotate(0);-      animation: rotate 10s linear -5s infinite;+      animation: rotate 10s linear -5s;       z-index: 20;     }   }@@ -2351,7 +2349,6 @@ h1.title {           left: -8px;           top: 1px;           -webkit-animation: pulsate 1.2s ease-out;-          -webkit-animation-iteration-count: infinite;           opacity: 0.0         }</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://stackoverflow.com/questions/13176746/css-keyframe-animation-cpu-usage-is-high-should-it-be-this-way" target="_blank" rel="noopener">CSS keyframe animation CPU usage is high, should it be this way?</a></li><li><a href="https://github.danielcardoso.net/load-awesome/" target="_blank" rel="noopener">Load Awesome</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> Performance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> Animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions 实战</title>
      <link href="2020/03/27/github-actions-in-action/"/>
      <url>2020/03/27/github-actions-in-action/</url>
      
        <content type="html"><![CDATA[<h2 id="GitHub-Actions-是什么？"><a href="#GitHub-Actions-是什么？" class="headerlink" title="GitHub Actions 是什么？"></a>GitHub Actions 是什么？</h2><p>与 <a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a>、<a href="https://www.jetbrains.com/teamcity/" target="_blank" rel="noopener">TeamCity</a>、<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 类似，<a href="https://help.github.com/en/actions" target="_blank" rel="noopener">GitHub Actions</a> 是 GitHub 提供的一个持续集成平台。</p><h2 id="与三方持续集成平台的对比"><a href="#与三方持续集成平台的对比" class="headerlink" title="与三方持续集成平台的对比"></a>与三方持续集成平台的对比</h2><table><thead><tr><th align="left"></th><th align="left">GitHub Actions</th><th align="left">Jenkins</th><th align="left">TeamCity</th><th align="left">Travis CI</th></tr></thead><tbody><tr><td align="left">代码仓库平台无关性</td><td align="left">×</td><td align="left">√</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">构建配置即源码</td><td align="left">√</td><td align="left">×</td><td align="left">×</td><td align="left">√</td></tr><tr><td align="left">无需单独部署</td><td align="left">√</td><td align="left">×</td><td align="left">×</td><td align="left">√</td></tr><tr><td align="left">自动回调 GitHub 构建状态接口</td><td align="left">√</td><td align="left">×</td><td align="left">×</td><td align="left">√</td></tr><tr><td align="left">无需配置敏感信息</td><td align="left">√</td><td align="left">×</td><td align="left">×</td><td align="left">×</td></tr></tbody></table><ul><li>代码仓库平台无关性：GitHub Actions 绑定 GitHub，若代码仓库迁移至其他持续集成平台，无法直接复用在 GitHub Actions 中定义的 workflow。</li><li>构建配置即源码：GitHub Actions 及 Travis CI 均使用 yaml 配置文件描述构建过程，便于复制且可与源码共同进行版本控制。</li><li>无需单独部署：GitHub Actions 及 Travis CI 为 SaaS 开箱即用，提交配置文件后即可看到效果。</li><li>自动回调 GitHub 构建状态接口：GitHub Actions 及 Travis CI 的构建状态无需插件及额外配置，会自动调用 GitHub 的 API 接口，完成状态显示。</li><li>无需配置敏感信息：在需要持续集成平台进行代码提交时（如自动合并代码），需要有代码仓库的相应权限。三方平台均需配置 GitHub 的 token，GitHub Actions 内置参数进行支持。</li></ul><h2 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a>怎么使用？</h2><p>在 GitHub 代码仓库根路径，创建 <code>.github/workflows</code> 路径，在路径内即可放置 <code>.yml</code> 或 <code>.yaml</code> 文件，在文件中定义各个具体的 workflow 内容，语法可见 <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions" target="_blank" rel="noopener">Workflow syntax for GitHub Actions</a>。</p><h2 id="常用功能实现方式"><a href="#常用功能实现方式" class="headerlink" title="常用功能实现方式"></a>常用功能实现方式</h2><h3 id="各分支及-PR-触发检查"><a href="#各分支及-PR-触发检查" class="headerlink" title="各分支及 PR 触发检查"></a>各分支及 PR 触发检查</h3><p>即当发生 <code>push</code> 或 <code>pull_request</code> 事件时，会触发 workflow 的执行，如：</p><pre><code class="yaml"># Trigger the workflow on push or pull requeston: [push, pull_request]</code></pre><p>实例可见：<a href="https://github.com/AlphaHinex/seata-at-demo/blob/seata-at/.github/workflows/check.yml#L4-L9" target="_blank" rel="noopener">https://github.com/AlphaHinex/seata-at-demo/blob/seata-at/.github/workflows/check.yml#L4-L9</a></p><p>相关文档：</p><ul><li><a href="https://help.github.com/en/actions/reference/events-that-trigger-workflows" target="_blank" rel="noopener">Events that trigger workflows</a></li><li><a href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestbranchestags" target="_blank" rel="noopener">on.&lt;push|pull_request&gt;.&lt;branches|tags&gt;</a></li></ul><h3 id="分支自动合并"><a href="#分支自动合并" class="headerlink" title="分支自动合并"></a>分支自动合并</h3><p>例如有这样一个需求：<code>master</code> 分支的任何变更，希望自动合并到 <code>develop</code> 分支上。可借助 <a href="https://github.com/marketplace/actions/nightly-merge" target="_blank" rel="noopener">Nightly Merge Action</a> 来实现，如：</p><p><code>on</code>:</p><pre><code class="yaml">on:  push:    branches:      - master</code></pre><p><code>steps</code>:</p><pre><code class="yaml">steps:- name: Auto Merge  uses: robotology/gh-action-nightly-merge@v1.2.0  with:    stable_branch: &#39;master&#39;    development_branch: &#39;develop&#39;</code></pre><p>实例可见：<a href="https://github.com/AlphaHinex/seata-at-demo/blob/seata-at/.github/workflows/auto-merge.yml" target="_blank" rel="noopener">https://github.com/AlphaHinex/seata-at-demo/blob/seata-at/.github/workflows/auto-merge.yml</a></p><blockquote><p>如希望合并操作在检查操作通过之后再执行，可将 master 分支的 push workflow 单独做，step1 check，step2 merge。</p></blockquote><h3 id="每日定时执行"><a href="#每日定时执行" class="headerlink" title="每日定时执行"></a>每日定时执行</h3><p>有时可能需要以计划任务方式执行构建，如每晚执行集成测试或打包等。可使用 <a href="https://help.github.com/en/actions/reference/events-that-trigger-workflows#scheduled-events-schedule" target="_blank" rel="noopener">schedule</a> 事件进行触发，如：</p><pre><code class="yaml">on:  schedule:    # * is a special character in YAML so you have to quote this string    - cron:  &#39;*/15 * * * *&#39;</code></pre><h3 id="Release-自动发布"><a href="#Release-自动发布" class="headerlink" title="Release 自动发布"></a>Release 自动发布</h3><p>在代码达到一个稳定版本需要进行释放时，可能需要将成果物发布到中央仓库中（如 Maven、npm registry、GitHub Packages Registry 等）以供他人使用。</p><p>在 GitHub 中，当设置了 tag 后，即可在仓库的 releases 页面看到一个发布（如 <a href="https://github.com/AlphaHinex/spring-roll/releases" target="_blank" rel="noopener">https://github.com/AlphaHinex/spring-roll/releases</a> ），并且可以为这个发布编写版本发布说明（如：<a href="https://github.com/spring-projects/spring-framework/releases/tag/v5.2.4.RELEASE）。" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework/releases/tag/v5.2.4.RELEASE）。</a></p><p>GitHub Actions 中分别有两种事件对应上述两种情况：</p><p><a href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestbranchestags" target="_blank" rel="noopener">on.&lt;push|pull_request&gt;.&lt;branches|tags&gt;</a></p><pre><code class="yaml">on:  push:    # Sequence of patterns matched against refs/tags    tags:              - v1             # Push events to v1 tag      - v1.*           # Push events to v1.0, v1.1, and v1.9 tags</code></pre><p><a href="https://help.github.com/en/actions/reference/events-that-trigger-workflows#release-event-release" target="_blank" rel="noopener">release event</a></p><pre><code class="yaml">on:  release:    types: [published]</code></pre><p>实例可见：<a href="https://github.com/AlphaHinex/spring-roll/pull/25/files" target="_blank" rel="noopener">https://github.com/AlphaHinex/spring-roll/pull/25/files</a></p><h3 id="Badge"><a href="#Badge" class="headerlink" title="Badge"></a>Badge</h3><p>可按照 <a href="https://help.github.com/en/actions/configuring-and-managing-workflows/configuring-a-workflow#adding-a-workflow-status-badge-to-your-repository" target="_blank" rel="noopener">官方文档</a> 中内容，按格式获得 badge 链接，也可以在创建好 actions 之后，直接在页面获得所需的 badge url，如：<a href="https://github.com/AlphaHinex/seata-at-demo/actions?query=workflow%3ACheck" target="_blank" rel="noopener">https://github.com/AlphaHinex/seata-at-demo/actions?query=workflow%3ACheck</a></p><p>实例如下：</p><p><code>https://github.com/AlphaHinex/seata-at-demo/workflows/Check/badge.svg</code></p><p><a href="https://github.com/AlphaHinex/seata-at-demo/actions?query=workflow%3ACheck" target="_blank" rel="noopener"><img src="https://github.com/AlphaHinex/seata-at-demo/workflows/Check/badge.svg" alt="Check"></a></p><h2 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h2><h3 id="3306-端口无法使用"><a href="#3306-端口无法使用" class="headerlink" title="3306 端口无法使用"></a>3306 端口无法使用</h3><p>GitHub Actions 运行在 GitHub-hosted runner 上，在这些环境中会预装一些软件，详细信息可见 <a href="https://help.github.com/en/actions/reference/software-installed-on-github-hosted-runners" target="_blank" rel="noopener">Software installed on GitHub-hosted runners</a>。</p><p>所以在希望自建一些服务（不使用预装的）时，可能需要调整端口。如 MySQL 的默认端口 <code>3306</code>，在使用 <a href="https://github.com/marketplace?type=actions&query=mysql" target="_blank" rel="noopener">MySQL 相关的 actions</a> 或通过 Docker Compose 构建 MySQL 容器时，需要调整默认端口。</p><h3 id="wait-for-it-无效"><a href="#wait-for-it-无效" class="headerlink" title="wait-for-it 无效"></a>wait-for-it 无效</h3><p>在 <a href="https://alphahinex.github.io/2020/02/05/microservices-integration-test-in-action/#%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">微服务的自动化集成测试实战</a> 一文中遇到了此问题：在 GitHub Actions 环境下 <a href="https://github.com/vishnubob/wait-for-it" target="_blank" rel="noopener">wait-for-it</a> 脚本虽然能正常执行但没有起到实际作用。此处没有找到太好的解决办法，通过增加一个等待的 action，在执行 <code>docker-compose up</code> 后强行等待一段时间，等服务都启动完成后再去执行集成测试。具体例子可见 <a href="https://github.com/AlphaHinex/seata-at-demo/blob/seata-at/.github/workflows/check.yml#L43-L46" target="_blank" rel="noopener">check.yml#L43-L46</a>。</p>]]></content>
      
      
      <categories>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> CI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 录播推流 RTMP 方案</title>
      <link href="2020/03/20/replay-to-rtmp-on-mac/"/>
      <url>2020/03/20/replay-to-rtmp-on-mac/</url>
      
        <content type="html"><![CDATA[<p>有时我们可能希望提前录制一些内容，在进行直播时推流至 RTMP 服务。本文提供了一个在 Mac 环境上实现此需求的方案。</p><h2 id="屏幕录制"><a href="#屏幕录制" class="headerlink" title="屏幕录制"></a>屏幕录制</h2><p>屏幕录制可以利用 <a href="https://alphahinex.github.io/2020/02/20/live-show-on-mac/">Mac RTMP 直播方案</a> 中提到的 <code>OBS</code>，<br>也可以直接使用系统自带的 <code>QuickTime Player</code>，占用的资源（主要是 CPU）更少，还提供了鼠标点击的可视化效果。</p><p>选择 <code>新建屏幕录制</code>，并选择 <code>内置麦克风</code> 即可，完成录制后，保存为 <code>.mov</code> 格式的视频。</p><p><img src="/contents/replay-to-rtmp-on-mac/recording.png" alt="recording"></p><h2 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h2><blockquote><p>the RTMP encapsulates MP3 or AAC audio and FLV1 video multimedia streams —— <a href="https://en.wikipedia.org/wiki/Real-Time_Messaging_Protocol" target="_blank" rel="noopener">Wikipedia</a></p></blockquote><p>RTMP 协议包含 MP3 或 AAC 格式的音频和 FLV1 格式的音频，所以需要将 <code>mov</code> 格式视频文件进行转换之后再进行推流。我们常说的视频格式（如 mp4、avi 等），更准确的说法应该是视频容器格式，在视频容器中，可以包含视频流、音频流等，详细信息可参见 <a href="https://alphahinex.github.io/2015/12/11/play-video-with-html5/">使用 HTML5 技术播放视频</a> 中相关内容。</p><p>格式转换及推流使用强大的 <a href="http://ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a>。可以提前将视频容器格式转换好，也可以在推流的同时进行转换。</p><h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><pre><code class="bash">$ ffmpeg -i test.mov test.flv</code></pre><h3 id="推流转换后格式"><a href="#推流转换后格式" class="headerlink" title="推流转换后格式"></a>推流转换后格式</h3><pre><code class="bash">$ ffmpeg -i test.flv -f flv rtmp://127.0.0.1/live/B11m2KPN8</code></pre><blockquote><p>先转换，再推流的好处是，可以在推流时节省一些视频转换所需的资源（如 CPU、时间）。</p></blockquote><h3 id="边转换边推流"><a href="#边转换边推流" class="headerlink" title="边转换边推流"></a>边转换边推流</h3><pre><code class="bash">$ ffmpeg -i test.mov -f flv rtmp://127.0.0.1/live/B11m2KPN8</code></pre><h2 id="效果验证"><a href="#效果验证" class="headerlink" title="效果验证"></a>效果验证</h2><p>开始推流后，可以通过直播方案中提到的 VLC 进行效果验证。</p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> RTMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频容器介绍</title>
      <link href="2020/03/12/video-container/"/>
      <url>2020/03/12/video-container/</url>
      
        <content type="html"><![CDATA[<p>以下内容节选自 <a href="https://alphahinex.github.io/2015/12/11/play-video-with-html5/">使用 HTML5 技术播放视频</a>，图片有更新。</p><h2 id="视频容器"><a href="#视频容器" class="headerlink" title="视频容器"></a>视频容器</h2><p>我们常见的视频格式有 <code>avi</code> 或 <code>mp4</code> 等，这些所谓的视频格式，实际上指的只是视频容器的格式。就像 <code>zip</code> 格式的压缩包里面可以放置任意类型的文件一样，视频容器格式可以简单理解为只定义了如何将视频及音频流数据存储在容器文件中。实际情况会比这更复杂一些，因为不是所有的视频流都可以兼容存入任意视频容器中。</p><p>一个视频文件通常包含多个轨道（track）—— 一个视频轨道（不包含声音），叠加一个或多个音频轨道（没有图像）。轨道之间通常是相互关联的。一个音频轨道中会包含一些标记，用来同步声音和图像。每个轨道可以有自己的元数据信息，如视频轨道的画面比例或音频轨道的语言。视频容器同样可以有元数据，如视频的标题、封面等等。</p><p>视频容器的格式有很多，常见的包括：</p><ul><li><a href="http://en.wikipedia.org/wiki/MPEG-4_Part_14" target="_blank" rel="noopener">MPEG 4</a>，通常是扩展名为 <code>.mp4</code> 或 <code>.m4v</code> 的文件。<code>MPEG 4</code> 容器是基于苹果之前的 <code>QuickTime</code> 容器格式（<code>.mov</code>）而来的。</li><li><a href="http://en.wikipedia.org/wiki/Ogg" target="_blank" rel="noopener">Ogg</a>，扩展名通常为 <code>.ogg</code> 或 <code>.ogv</code>。 Ogg 是一个开放的标准，开源友好，不受任何已知的专利限制。Firefox 3.5+，Chrome 4+ 以及 Opera 10.5+ 无需插件原生支持。Ogg 容器格式，包含 Ogg 视频（名为 <code>Theora</code>）和 Ogg 音频（名为 <code>Vorbis</code>）。Ogg 格式是大多数 Linux 发行版的开箱即用视频格式，并可以通过著名的 <a href="http://www.videolan.org/vlc/" target="_blank" rel="noopener">VLC</a> 播放器在各个平台上进行播放。</li><li><a href="http://www.webmproject.org/" target="_blank" rel="noopener">WebM</a>，扩展名 <code>.webm</code>。WebM 是一种无版税，开源友好的，专为 HTML5 设计的视频压缩格式，使用 <code>VP8</code> 视频编码和 <code>Vorbis</code> 音频编码。在技术上类似 <a href="https://en.wikipedia.org/wiki/Matroska" target="_blank" rel="noopener">Matroska</a> 格式（<code>.mkv</code>）。同样无需插件，在当前版本的 Chromium，Chrome，Firefox 和 Opera 上原生支持。</li><li><a href="http://en.wikipedia.org/wiki/Flash_Video" target="_blank" rel="noopener">Flash Video</a> (<code>.flv</code>) 是 Adobe Flash Player 所使用的格式。在近期的 Flash Player 版本中也加入了对 MPEG 4 容器的支持。</li><li><a href="http://en.wikipedia.org/wiki/Advanced_Systems_Format" target="_blank" rel="noopener">ASF</a> (<code>.asf</code>) 和 <a href="http://en.wikipedia.org/wiki/AVI" target="_blank" rel="noopener">Audio Video Interleave</a> (<code>.avi</code>) 是微软发明的格式，早期使用较多。</li></ul><h2 id="视频编解码器"><a href="#视频编解码器" class="headerlink" title="视频编解码器"></a>视频编解码器</h2><p>当我们观看视频时，视频播放器至少同时做了三件事：</p><ol><li>解析视频容器格式，找到可用的视频及音频轨道，以及他们是如何存放在容器内的，以便获得解码所需数据</li><li>解码视频流，在屏幕上显示一系列的图像</li><li>解码音频流，在扬声器中播放声音</li></ol><p>编解码器是指对视频进行编码和解码的算法。视频按照编码算法被转换成二进制流文件进行存储和分发，视频播放器按照解码算法对视频流进行解码，并将一系列图像或帧显示在屏幕上。大多数现代视频编解码器都竭尽其能地减少播放下一帧所需的信息。例如，为了避免保存每一帧图像（类似截屏），编码时将只会存储每帧之间的差异内容。多数视频也不是每一帧都与上一帧完全不同，这便使得更高的压缩率和更小的文件尺寸成为可能。</p><p>编解码器分为有损和无损两种类型。无损类型的视频尺寸对于互联网来说还是太大了，所以我们这里只关注有损类型的视频编码。有损类型的视频编解码器，意味着对视频编码总会伴随着不可挽回的原始数据丢失。就像翻录卡带一样，每次视频编码都会造成源视频信息的丢失以及视频质量的下降。多次编码后视频可能会有明显的卡顿，尤其是动作很多的视频（如动作片）。然而好的方面是，有损的视频编码格式能够提供惊人的压缩比例，并通过一些播放时的优化技术，使肉眼很难察觉到这些信息的损失。</p><p>常见的视频编解码器有 <code>H.264</code>、<code>Theora</code> 和 <code>VP8</code>。</p><h3 id="H-264"><a href="#H-264" class="headerlink" title="H.264"></a>H.264</h3><p><a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC" target="_blank" rel="noopener">H.264</a>，即 MEPG-4 part 10、MPEG-4 AVC、MPEG-4 Advanced Video Coding。 H.264 是 <a href="http://en.wikipedia.org/wiki/Moving_Picture_Experts_Group" target="_blank" rel="noopener">MPEG 组织</a> 开发并于 2003 年标准化的编码格式。它致力于为低带宽、低性能 CPU 设备（如手机），高带宽和高性能 CPU 设备（如现代桌面电脑），以及所有在此范围之间的设备，提供单独的一种编解码器。为了实现这个目标， H.264 标准定义了多种 <a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC#Profiles" target="_blank" rel="noopener">profiles</a> 和 <a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC#Levels" target="_blank" rel="noopener">levels</a>。配置（<code>profile</code>）定义了编码时所采取的约束，使解码器了解解码视频的要求；等级（<code>level</code>）与配置共同指定了视频的最大解析度、帧速及码率等。更高的配置提供更好的视频质量，更长的编码时间以及在实时播放时需要更强劲的 CPU 来解码。</p><p>概括来说，<a href="http://www.apple.com/cn/iphone/compare/" target="_blank" rel="noopener">iPhone 可支持 High 配置</a>，<a href="http://www.apple.com/tv/specs/" target="_blank" rel="noopener">AppleTV 支持 Baseline、Main 和 High 配置</a>，Flash 和台式机支持 <code>Baseline</code>、<code>Main</code> 和 <code>High</code> 配置。H.264 同时也是蓝光标准授权的编解码器，蓝光光盘通常使用 <code>High</code> 配置。</p><p>大多数的非 PC 设备（如 <code>iPhone</code> 和蓝光播放器）在播放 H.264 视频时，实际是由专用芯片负责解码，因为他们的 CPU 并没有足够的性能以支持视频的实时播放。目前甚至一些低端的桌面显卡也能够支持硬件解码 H.264。有很多 H.264 的编码器，包括开源的 <a href="http://www.videolan.org/developers/x264.html" target="_blank" rel="noopener">x264 library</a>。H.264 视频可以嵌入到大多数流行视频容器格式中，包括 <code>MP4</code> 和 <code>MKV</code>。</p><p><strong>H.264 标准是需要支付专利许可费用的</strong>，专利许可的主要来源是 <a href="http://www.mpegla.com/" target="_blank" rel="noopener">MPEG LA 组织</a>。<a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC#Patent_licensing" target="_blank" rel="noopener">2010年8月26日，MPEG LA 组织宣布使用 H.264 编码的网络视频对<strong>最终用户永久免费</strong></a>。但是离开网络使用到有关 H.264 的产品或服务，还是需要支付费用的。</p><p><img src="/contents/video-container/h264.png" alt="MPEG-4/H.264 video format"><br><a href="http://caniuse.com/#feat=mpeg4" target="_blank" rel="noopener">数据来源</a></p><h3 id="Theora"><a href="#Theora" class="headerlink" title="Theora"></a>Theora</h3><p><a href="http://en.wikipedia.org/wiki/Theora" target="_blank" rel="noopener">Theora</a> 由 <a href="http://en.wikipedia.org/wiki/Theora#History" target="_blank" rel="noopener">VP3 编解码器</a> 演化而来，随后由 <a href="http://xiph.org/" target="_blank" rel="noopener">Xiph.org 基金会</a> 开发维护。<strong>Theora 开源且免费</strong>，不过这套标准于 <code>2004</code> 年即处于“冻结”状态，<code>Theora</code> 项目（包含开源的视频编码及解码）只在 <code>2008</code> 年发布了初版，<code>2009</code> 年发布了 <code>1.1.1</code> 稳定版，最近一次发布的 <code>1.2.0 Alpha 1</code> 预览版也已是 5 年前的事情了。</p><p><code>Theora</code> 视频可以嵌入到任何视频容器格式内，不过最常见的还是 <code>Ogg</code> 容器。所有主流的 Linux 发行版都默认支持 <code>Theora</code> 格式，Firefox、Chrome 和 Opera 的当前版本都对其提供了原生支持。在安装了 Xiph.org 提供的开源解码软件后，在 <a href="http://www.xiph.org/dshow/" target="_blank" rel="noopener">Windows</a> 和 <a href="http://xiph.org/quicktime/" target="_blank" rel="noopener">Max OS X</a> 也可以播放 <code>Theora</code> 视频。</p><p><img src="/contents/video-container/theora.png" alt="Ogg/Theora video format"><br><a href="http://caniuse.com/#feat=ogv" target="_blank" rel="noopener">数据来源</a></p><h3 id="VP8"><a href="#VP8" class="headerlink" title="VP8"></a>VP8</h3><p><a href="http://en.wikipedia.org/wiki/VP8" target="_blank" rel="noopener">VP8</a> 最早由 <code>On2</code> 开发，2010 年，Google 收购 <code>On2</code> 后发布了这个视频编解码器的规范和开源的编码解码示例。在经过一些争论之后，最终 VP8 的授权确认为一个<strong>开放源代码授权</strong>。</p><p><code>WebM</code> 项目和 <code>VP8</code> 同时在 2010 年 5 月发表，Mozilla、Opera、Google 和其他 40 多家厂商共同协助发展，目的是让 VP8 成为 HTML5 的视频格式。 WebM 为一个容器格式，视频部分使用 VP8，声音格式则是使用 <code>Vorbis</code>。</p><p><img src="/contents/video-container/vp8.png" alt="WebM video format"><br><a href="http://caniuse.com/#feat=webm" target="_blank" rel="noopener">数据来源</a></p><h2 id="音频编解码器"><a href="#音频编解码器" class="headerlink" title="音频编解码器"></a>音频编解码器</h2><p>同视频编解码器一样，音频编解码器是指对音频流编码和解码的算法。音频编解码器也分为有损和无损两种。无损的音频对互联网来说同样太大，所以我们只关注有损音频编解码。</p><p>在播放视频时，音频编解码器起到的作用是解码音频数据流，并将其通过扬声器播放出来。同有损编码视频一样，有很多办法来减小音频流的尺寸。在 <code>录音 - 编码 - 解码 - 播放</code> 的过程中，有大量信息被丢弃。不同的音频编解码器丢弃的内容不同，但他们都能做到欺骗你的耳朵，让你察觉不到这些损失。</p><p>有一个只有在音频中才存在的概念：<code>声道</code>。声音通过扬声器来播放，普通的桌面电脑可能拥有左右两个扬声器。环绕立体声系统拥有 6 个甚至更多的扬声器。一个扬声器可以用来播放原始音轨中的一个特定声道。当你坐在 6 个扬声器之中，被 6 个独立声道播放出的声音所环绕，你的大脑会同步它们并使你产生出一种身临其境的感觉。</p><p>大部分通用性的音频编解码器能够处理两个声道。在录音时，声音被切分成左右两个声道；在编码时，两个声道被存储在同一个音频流中；解码时，两个声道解译后被送至不同的扬声器来播放。一些音频解码器能够处理两个以上的声道，并且加以区分，以便在播放时能够通过恰当的扬声器来播放。</p><p>常用的音频编解码器有：<code>MP3</code>、<code>AAC</code> 和 <code>Vorbis</code>。</p><h3 id="MPEG-1-Audio-Layer-3"><a href="#MPEG-1-Audio-Layer-3" class="headerlink" title="MPEG-1 Audio Layer 3"></a>MPEG-1 Audio Layer 3</h3><p><a href="http://en.wikipedia.org/wiki/MPEG-1_Audio_Layer_3" target="_blank" rel="noopener">MPEG-1 Audio Layer 3</a> 即 <code>MP3</code>。MP3 <strong>最多能容纳两个声道</strong>，可以编码为不同比特率：64 kbps, 128 kbps, 192 kbps, 甚至从 32 到 320 的各种速率。更高的比特率意味着更大的文件尺寸和更好的音频质量，不过音频质量和比特速率不是正比关系。128 kbps 要比 64 kbps 的音质水平提升两倍以上，但 256 kbps 并不能达到 128 kbps 的两倍音质。MP3 支持<strong>可变比特率编码</strong>，这意味着一个音频流的某一部分可能会比另一部分的压缩率高。例如交响乐在演奏时使用高比特率，而在章节间的静默阶段使用低比特率。MP3 同样也支持<strong>固定比特率编码</strong>。</p><p>MP3 标准没有确切定义如何编码，但却明确定义了如何解码；不同的编码器使用不同方式导致编码结果大相径庭，但它们需要保证编码结果都可以使用同一个播放器来解码并播放。开源的 <a href="http://lame.sourceforge.net/" target="_blank" rel="noopener">LAME 项目</a> 是免费编码器的首选。</p><p>MP3 格式（于 1991 年标准化）是<strong>受版权约束</strong>的，这也解释了为什么 <code>Linux</code> 系统不能直接播放 MP3 文件。官方是要求 MP3 编解码器购买授权的，但 MP3 的版权非常混乱和碎片化，这也导致 MP3 成为<strong>事实上的免费格式</strong>。到 2015 ~ 2017 年， MP3 的专利也基本都到期了，也将成为公共领域的东西。所有随身听都可以播放 MP3 文件，MP3 音频流也可以嵌入至任意视频容器中。Adobe Flash 可以播放独立的 MP3 文件，也可以播放在 MP4 视频容器中的 MP3 音频流。</p><p><img src="/contents/video-container/mp3.png" alt="MP3 audio format"><br><a href="http://caniuse.com/#search=mp3%20audio" target="_blank" rel="noopener">数据来源</a></p><h3 id="Advanced-Audio-Coding"><a href="#Advanced-Audio-Coding" class="headerlink" title="Advanced Audio Coding"></a>Advanced Audio Coding</h3><p><a href="http://en.wikipedia.org/wiki/Advanced_Audio_Coding" target="_blank" rel="noopener">Advanced Audio Coding</a> 通常简称为 <code>AAC</code>。标准化于 1997 年的这个规范，因苹果选择其作为 <code>iTunes Store</code> 的默认格式而声名鹊起。<code>AAC</code> 格式是<strong>需要收取版权费用</strong>的，收费标准可在 <a href="http://www.vialicensing.com/licensing/aac-fees.aspx" target="_blank" rel="noopener">这里</a> 查看。<strong>终端用户编码器和/或译码器产品制造商或开放商需要获得 AAC 专利授权。以 AAC 格式编码发布的比特流 —— 无论是通过广播、网络数据流或是通过物理媒体提供 —— 都没有专利授权费</strong>。</p><p><code>AAC</code> 被设计为在使用与 MP3 相同的比特率时提供更好的音质，并且可以使用任意比特率来编码（MP3 被限定在最高 320 kbps）。<code>AAC</code> 编码的音频<strong>最多可支持 48 个声道</strong>，虽然实际中并没有人需要使用这么多声道。<code>AAC</code> 格式还有一个区别于 MP3 的地方时，它同 <code>H.264</code> 一样，定义了多种<strong>配置</strong>（<code>profile</code>）。低端配置用以在计算资源有限的设备上实时播放，高端配置提供更好的音质，同时需要更长的编解码时间。</p><p>当前所有的苹果产品，包括 <code>iPod</code>、<code>AppleTV</code> 和 <code>QuickTime</code> 都支持播放在 MP4 视频容器中的 <code>ACC</code> 格式的固定配置音频流。<code>Adobe Flash</code> 通开源的 <code>MPlayer</code> 和 <code>VLC</code> 播放器一样，支持 MP4 容器中的任意配置的 <code>AAC</code> 格式音频。编码方面，<code>FAAC</code> 类库是一个可选的开源类库，同时还有 <code>mencoder</code> 和 <code>ffmpeg</code>。</p><p><img src="/contents/video-container/aac.png" alt="AAC audio file format"><br><a href="http://caniuse.com/#search=AAC%20audio" target="_blank" rel="noopener">数据来源</a></p><h3 id="Vorbis"><a href="#Vorbis" class="headerlink" title="Vorbis"></a>Vorbis</h3><p><a href="http://en.wikipedia.org/wiki/Vorbis" target="_blank" rel="noopener">Vorbis</a> 通常被称作 <code>Ogg Vorbis</code>，不过从技术角度来说这个称呼是有误的。<code>Ogg</code> 只是一个视频容器格式，<code>Voribs</code> 音频流也可以被嵌入到其他视频容器中。<code>Vorbis</code> 是<strong>开放、免费且无专利限制</strong>的，因此所有主要的 <code>Linux</code> 发行版及移动设备都可以通过开源的 <a href="http://www.rockbox.org/" target="_blank" rel="noopener">Rockbox</a> 固件为其提供支持。<code>Vorbis</code> 格式音频流通常被嵌入在 <code>Ogg</code> 或 <code>WebM</code> 容器中，但它们同时也可以被嵌入在 <code>MP4</code> 或 <code>MKV</code> 容器里（甚至经过一些改动后，也可以嵌入在 <a href="http://www.alexander-noe.com/video/amg/" target="_blank" rel="noopener">AVI</a> 中）。<code>Vorbis</code> 支持<strong>任意数量的声道</strong>。</p><p>开源的 <code>Vorbis</code> 编码器和解码器有很多，包括 <a href="http://oggconvert.tristanb.net/" target="_blank" rel="noopener">OggConvert</a>（编码）、<a href="http://www.ffmpeg.org/" target="_blank" rel="noopener">ffmpeg</a>（解码）、<a href="http://www.geocities.jp/aoyoume/aotuv/" target="_blank" rel="noopener">aoTuV</a>（编码）和 <a href="http://downloads.xiph.org/releases/vorbis/" target="_blank" rel="noopener">libvorbis</a>（解码）。</p><p><img src="/contents/video-container/vorbis.png" alt="Ogg Vorbis audio format"><br><a href="http://caniuse.com/#search=vorbis" target="_blank" rel="noopener">数据来源</a></p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Video </tag>
            
            <tag> Codec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>敏捷之我见</title>
      <link href="2020/03/04/agile-practice/"/>
      <url>2020/03/04/agile-practice/</url>
      
        <content type="html"><![CDATA[<h2 id="实施敏捷的要点"><a href="#实施敏捷的要点" class="headerlink" title="实施敏捷的要点"></a>实施敏捷的要点</h2><ul><li>团队以一个恒定的效率进行输出：敏捷不是一把梭，重要的是持之以恒</li><li>考核团队的绩效，而非个人的绩效：一个人可以走的很快，但一群人能走得更远</li><li>任务可视化：进度及工作饱和度的直观反馈</li><li>基于 TDD 及 CI/CD：灵魂</li><li>明确的目标：遵循 SMART 原则的目标，才能得到尽可能小的偏差</li><li>上层的支持：统一思想，某个环节敏捷没有用</li></ul><h2 id="具体实践形式"><a href="#具体实践形式" class="headerlink" title="具体实践形式"></a>具体实践形式</h2><h3 id="两周一个-Sprint"><a href="#两周一个-Sprint" class="headerlink" title="两周一个 Sprint"></a>两周一个 Sprint</h3><ul><li>每月 2~3 个迭代，频率适中，也方便与月度、季度、年度等目标对应。</li><li>每个 Sprint 明确必须达成的目标（高优先级），以及中、低优先级目标。</li></ul><h3 id="Kanban"><a href="#Kanban" class="headerlink" title="Kanban"></a>Kanban</h3><ul><li>电子看板为主，包括所有任务明细（名称、描述、责任人、优先级、WBS、状态、评估工时、实际用时）</li><li>物理看板粒度较粗（目标、用户故事级别），明确每个迭代周期的达成标准、优先级及完成时间</li><li>目标进行指派，任务自行分解，工时自行评估，并对自己评估的工时进行按期达成承诺</li><li>使用工具：<a href="https://www.jetbrains.com/youtrack/" target="_blank" rel="noopener">YouTrack</a>，可完成任务管理，看板展现，评估工时、实际使用工时记录，并基于工作量设计了一套绩效点数计算方案，每日自动计算，并在每轮结束时，进行绩效点数排名，进行奖惩</li></ul><h3 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h3><ul><li>每人有一个结对人员（类似导师），负责进行 code review</li></ul><h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><ul><li>要求所有代码有单元测试，并保证测试覆盖率</li></ul><h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><ul><li>CI 负责进行每个 PR 的静态代码检查（Pmd）、编码规范检查（Checkstyle）、隐性 bug 查找（Findbugs），并保证所有单元测试通过，及测试覆盖率不下降（Codecov）</li><li>CD 环境负责随时发布最新内容（非生产环境）</li></ul><h3 id="早站会"><a href="#早站会" class="headerlink" title="早站会"></a>早站会</h3><ul><li>时间控制在10分钟内</li><li>关注本轮目标达成情况，以及是否有阻碍性问题，如果有在站会上进行协调</li><li>随机选人对早站会内容进行总结</li></ul><h3 id="迭代总结会"><a href="#迭代总结会" class="headerlink" title="迭代总结会"></a>迭代总结会</h3><ul><li>每人总结一个本轮关键词，提高团队对总结会的参与度</li><li>每轮结束前，对本轮目标达成情况进行总结</li><li>并对下轮目标进行明确</li><li>总结本轮团队做的好的地方继续保持，并归纳做的不好的地方，提出改进方案，在后续迭代周期中进行改善及跟踪</li></ul><h3 id="值月-Scrum-Master"><a href="#值月-Scrum-Master" class="headerlink" title="值月 Scrum Master"></a>值月 Scrum Master</h3><ul><li>负责组织每日早站会</li><li>负责对迭代总结会进行会议记录并公布</li><li>负责组织一次团队建设</li></ul><h3 id="奖惩制度"><a href="#奖惩制度" class="headerlink" title="奖惩制度"></a>奖惩制度</h3><ul><li>个人奖章奖励（金银铜奖章，金奖章可以兑换物质激励）</li><li>培养团队责任意识，事事有责任人。出现事故或其他惩罚事项，责任人受惩罚（发红包，作为团队经费）</li></ul><h3 id="学习制度"><a href="#学习制度" class="headerlink" title="学习制度"></a>学习制度</h3><ul><li>每两月组织一次读书分享</li></ul>]]></content>
      
      
      <categories>
          
          <category> Agile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Agile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>敏捷开发之测试驱动开发从入门到放弃</title>
      <link href="2020/02/26/tdd-from-entry-to-abandon/"/>
      <url>2020/02/26/tdd-from-entry-to-abandon/</url>
      
        <content type="html"><![CDATA[<p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/01.jpg" alt="01"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/02.jpg" alt="02"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/03.jpg" alt="03"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/04.jpg" alt="04"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/05.jpg" alt="05"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/06.jpg" alt="06"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/07.jpg" alt="07"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/08.jpg" alt="08"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/09.jpg" alt="09"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/10.jpg" alt="10"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/11.jpg" alt="11"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/12.jpg" alt="12"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/13.jpg" alt="13"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/14.jpg" alt="14"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/15.jpg" alt="15"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/16.jpg" alt="16"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/17.jpg" alt="17"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/18.jpg" alt="18"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/19.jpg" alt="19"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/20.jpg" alt="20"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/21.jpg" alt="21"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/22.jpg" alt="22"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/23.jpg" alt="23"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/24.jpg" alt="24"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/25.jpg" alt="25"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/26.jpg" alt="26"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/27.jpg" alt="27"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/28.jpg" alt="28"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/29.jpg" alt="29"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/30.jpg" alt="30"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/31.jpg" alt="31"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/32.jpg" alt="32"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/33.jpg" alt="33"></p><p><img src="https://alphahinex.github.io/contents/tdd-from-entry-to-abandon/34.jpg" alt="34"></p>]]></content>
      
      
      <categories>
          
          <category> Agile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Agile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac RTMP 直播方案</title>
      <link href="2020/02/20/live-show-on-mac/"/>
      <url>2020/02/20/live-show-on-mac/</url>
      
        <content type="html"><![CDATA[<h2 id="Mac-直播软件"><a href="#Mac-直播软件" class="headerlink" title="Mac 直播软件"></a>Mac 直播软件</h2><p><a href="https://obsproject.com/" target="_blank" rel="noopener">OBS</a> 为 Mac 下可用的直播软件。上手简单，网上教程也很多。<br>不过因为 RMBP 的分辨率太高，直播画面必须进行缩小，否则 Mac 不一定能吃得消。<code>MacBook Pro (Retina, 15-inch, Mid 2015)</code> 播一会就提示资源不足，需降低分辨率之类的了。最后使用的如下配置，观看直播的分辨率基本可接受，录制起来也不会提示需要降低输出质量。</p><p><img src="/contents/live-show-on-mac/video.png" alt="video settings"></p><p>不过风扇还是会疯了一样响，如果使用 Mac 内置麦克风，可能会产生比较大噪音，影响直播效果。可以接入耳机，并且为声音添加降噪滤镜。</p><p><img src="/contents/live-show-on-mac/audio-1.png" alt="audio settings 1"></p><p><img src="/contents/live-show-on-mac/audio-2.png" alt="audio settings 2"></p><p>在 OBS 的 <code>设置</code> 中，有 <code>推流</code> 设置，里面可以设置将直播流推送的地址。</p><h2 id="本地-RTMP-服务器"><a href="#本地-RTMP-服务器" class="headerlink" title="本地 RTMP 服务器"></a>本地 RTMP 服务器</h2><p>在本地环境，可以使用 <a href="https://github.com/sallar/mac-local-rtmp-server" target="_blank" rel="noopener">mac-local-rtmp-server</a> 搭建一个本地 RTMP 服务器。运行后可获得一个 <code>RTMP URL</code> 和 <code>STREAM KEY</code>，分别填入 OBS 推流设置的 <code>服务器</code> 和 <code>串流密钥</code> 中即可。</p><h2 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h2><p>可使用 <a href="https://www.videolan.org/vlc/" target="_blank" rel="noopener">VLC 播放器</a> 观看流视频，以 iOS 版本为例，在 <code>网络</code> tab 页中，选择 <code>打开网络串流</code>，填入从本地 RTMP 服务器获得的 RTMP URL 和 STREAM KEY（斜线间隔）即可，如：<code>rtmp://127.0.0.1/live/r1hkK8cXU</code>。</p><blockquote><p>注意流媒体播放器需与服务器在相同网络内。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> RTMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集成 Spring Roll 的通用导出列表数据为 Excel 功能</title>
      <link href="2020/02/14/integrate-spring-roll-export/"/>
      <url>2020/02/14/integrate-spring-roll-export/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/AlphaHinex/spring-roll" target="_blank" rel="noopener">Spring Roll</a> 中提供了一个基于业务 REST Controller 实现的通用 Excel 导出功能，可将列表页查询结果直接导出为 Excel 文件。</p><p>本文描述如何集成 <a href="https://github.com/AlphaHinex/spring-roll/tree/v0.0.7.RELEASE/modules/blocks/roll-export" target="_blank" rel="noopener">roll-export</a> 模块，获得通用导出功能。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p><code>Spring Roll</code> 的包目前发布在 <code>GitHub Packages</code> 中，可参照 <a href="https://alphahinex.github.io/2020/01/17/github-packages-in-action/">GitHub Packages in Action</a> 或官方文档，对构建工具进行配置。</p><p>之后可在 Maven 中添加：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;io.github.spring-roll&lt;/groupId&gt;    &lt;artifactId&gt;roll-export&lt;/artifactId&gt;    &lt;version&gt;0.0.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>或在 Gradle 中添加 <code>io.github.spring-roll:roll-export:0.0.7.RELEASE</code> 。</p><h2 id="扫描-Spring-Roll-中组件"><a href="#扫描-Spring-Roll-中组件" class="headerlink" title="扫描 Spring Roll 中组件"></a>扫描 Spring Roll 中组件</h2><p>在相关配置类中增加 <code>@ComponentScan(basePackages = &quot;io.github.springroll&quot;)</code></p><blockquote><p>若之前使用了 <code>@SpringBootApplication</code> 注解所在类作为默认包扫描路径，在添加上述配置后，需要额外再显示声明一下扫描包路径。</p></blockquote><h2 id="提供从查询接口获得导出数据的实现类"><a href="#提供从查询接口获得导出数据的实现类" class="headerlink" title="提供从查询接口获得导出数据的实现类"></a>提供从查询接口获得导出数据的实现类</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>将对业务接口的调用信息封装到请求中，调用通用导出接口。通用导出接口负责将请求转发给实际业务接口，并对业务接口返回对象进行处理，获得到要导出的数据，再将数据填入 Excel 中，并输出到 Response 里。</p><h3 id="接口签名"><a href="#接口签名" class="headerlink" title="接口签名"></a>接口签名</h3><p>通用导出接口为 <code>/export/excel/{title}</code>，提供 <code>GET</code> 及 <code>POST</code> 两种形式：</p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><pre><code class="java">@GetMapping(&quot;/export/excel/{title}&quot;)public void export(@PathVariable String title, @RequestParam String cols, @RequestParam String url, String tomcatUriEncoding, HttpServletRequest request, HttpServletResponse response) throws Exception</code></pre><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><pre><code class="java">@PostMapping(&quot;/export/excel/{title}&quot;)public void export(@PathVariable String title, @RequestBody ExportModel model, HttpServletRequest request, HttpServletResponse response) throws Exception</code></pre><pre><code class="java">public class ExportModel {    /**     * 列表中对 columns 的定义     */    private List&lt;ColumnDef&gt; cols;    /**     * 查询数据请求 url     */    private String url;    /**     * tomcat server.xml 中 Connector 设定的 URIEncoding 值，若未设置，默认为 ISO-8859-1     */    private String tomcatUriEncoding;    /**     * 业务请求的 Request Body     */    private Map bizReqBody;}</code></pre><h3 id="参数描述"><a href="#参数描述" class="headerlink" title="参数描述"></a>参数描述</h3><p>针对业务接口可能存在 GET 和 POST 两种形式，通用导出接口也提供了两种类型。GET 时将所有参数（包括通用导出接口所需参数，及业务接口所需参数两部分）放入请求参数中，POST 时将参数放入请求体中。参数说明如下：</p><table><thead><tr><th align="left">通用导出接口所需参数</th><th align="left">参数描述</th><th align="left">是否必填</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">导出文件名</td><td align="left">必填</td></tr><tr><td align="left">cols</td><td align="left">列表（前端）中对 columns 的定义，支持 EasyUI、QUI 及 ElementUI 中表格组件对属性和名称的定义</td><td align="left">必填</td></tr><tr><td align="left">url</td><td align="left">具体业务的查询 url。GET 时将业务接口参数直接拼接到 url 后面，注意需进行 URL Encode；POST 时使用 bizReqBody 参数传递业务接口请求体</td><td align="left">必填</td></tr><tr><td align="left">tomcatUriEncoding</td><td align="left">tomcat <code>server.xml</code> 中 Connector 设定的 URIEncoding 值，若未设置，默认为 <code>ISO-8859-1</code></td><td align="left">非必填</td></tr><tr><td align="left">bizReqBody</td><td align="left">调用 POST 接口时，使用此属性传递业务接口请求体</td><td align="left">POST 时必填</td></tr></tbody></table><p>通用导出功能会根据 url 参数及调用导出接口所使用的 HTTP Method 去构造一个访问业务查询接口的请求，并对业务接口的返回对象使用实现了 <a href="https://github.com/AlphaHinex/spring-roll/blob/v0.0.7.RELEASE/modules/blocks/roll-export/src/main/java/io/github/springroll/export/excel/handler/PaginationHandler.java" target="_blank" rel="noopener">PaginationHandler</a> 接口的组件集合进行解析，获得具体业务数据之后，将其按照 cols 中的定义，输出到 Excel 中。</p><p>故在集成时，需根据业务接口的返回类型，提供获得具体业务数据的 <code>PaginationHandler</code> 接口的实现。</p><p>例如：</p><pre><code class="java">@Componentpublic class WrapperResponseIQueryPaginationHandler implements PaginationHandler {    @Override    public Optional&lt;Collection&gt; getPaginationData(Object rawObject) {        Optional&lt;Collection&gt; result = Optional.empty();        if (rawObject instanceof WrapperResponse) {            Object object = ((WrapperResponse) rawObject).getData();            if (object instanceof IQuery) {                result = Optional.ofNullable(((IQuery)object).getResult());            }        }        return result;    }}</code></pre><p><code>cols</code> 参数结构目前（v0.0.7.RELEASE）支持 EasyUI、QUI 及 ElementUI 三种前端类库中表格组件对属性和名称的定义：</p><table><thead><tr><th align="left">框架</th><th align="left"><code>属性</code>字段</th><th align="left"><code>名称</code>字段</th></tr></thead><tbody><tr><td align="left">EasyUI</td><td align="left">field</td><td align="left">title</td></tr><tr><td align="left">QUI</td><td align="left">name</td><td align="left">display</td></tr><tr><td align="left">ElementUI</td><td align="left">prop</td><td align="left">label</td></tr></tbody></table><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>集成之后可访问通用导出接口进行验证，如：</p><p><a href="http://localhost:8080/demo/export/excel/%E5%AF%BC%E5%87%BA?cols=%5B%7B%22name%22%3A%22clctId%22%2C%22display%22%3A%22%E9%87%87%E9%9B%86%E5%AE%9E%E4%BE%8BID%22%7D%2C%7B%22name%22%3A%22clctSttId%22%2C%22display%22%3A%22%E7%BB%9F%E8%AE%A1%E4%BB%BB%E5%8A%A1ID%22%7D%2C%7B%22name%22%3A%22bizTotlCnt%22%2C%22display%22%3A%22%E4%B8%9A%E5%8A%A1%E6%80%BB%E9%87%8F%22%7D%5D&url=%2Fbiz%2Fquery%2Fpage%3FpageSize%3D9999%26pageNumber%3D1" target="_blank" rel="noopener">GET 请求示例 URL</a>。</p><p>或 POST 请求 curl</p><pre><code class="bash">curl &#39;http://localhost:8080/export/excel/test&#39; -H &#39;Content-Type: application/json;charset=UTF-8&#39; --data-binary &#39;{&quot;bizReqBody&quot;:{&quot;userName&quot;:&quot;&quot;,&quot;age&quot;:&quot;&quot;},&quot;cols&quot;:[{&quot;name&quot;:&quot;userName&quot;,&quot;display&quot;:&quot;员工姓名&quot;},{&quot;name&quot;:&quot;userId&quot;,&quot;display&quot;:&quot;员工编号&quot;}],&quot;title&quot;:&quot;员工信息&quot;,&quot;url&quot;:&quot;http://localhost:8080/user/queryUserListByPage&quot;}&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring Roll </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Java </tag>
            
            <tag> Excel </tag>
            
            <tag> Spring Roll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务的自动化集成测试实战</title>
      <link href="2020/02/05/microservices-integration-test-in-action/"/>
      <url>2020/02/05/microservices-integration-test-in-action/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>利用 <a href="https://alphahinex.github.io/2020/01/22/how-to-integrate-seata-at-mode-with-spring-cloud/">How to integrate SEATA AT mode with Spring Cloud</a> 中定义好的微服务，进行集成测试。</p><p>包含以下服务：</p><ol><li>库存服务（storage）</li><li>用户账户服务（account）</li><li>订单服务（order）</li><li>业务服务（business）</li></ol><p>业务服务作为直接被调用的接口，组织关联其他三个服务。下订单时，服务的调用顺序如下：</p><pre><code>1. 减库存（storage）2. 创建订单2.1. 扣减用户账户（account）2.2. 生成订单（order）</code></pre><p>服务之间存在依赖关系，各服务对基础设施也有依赖（数据库、注册中心、分布式事务协调者等）。</p><p>集成测试包含两个测试用例：</p><ol><li>业务服务成功调用：验证请求成功</li><li>业务服务调用出现异常：验证分布式事务生效，异常节点之前的服务数据已回滚</li></ol><h2 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h2><ul><li><a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener">Spring Boot</a>：借助 Spring Boot 对测试框架的集成和支持，运行测试用例</li><li><a href="https://junit.org/junit4/" target="_blank" rel="noopener">JUnit</a>：集成测试用例编写</li><li><a href="http://gradle.org/" target="_blank" rel="noopener">Gradle</a>：构建工具执行集成测试，自动化执行的基础</li><li><a href="https://www.docker.com/" target="_blank" rel="noopener">docker</a>：各服务运行环境在容器中运行，便捷搭建集成测试环境</li><li><a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">docker-compose</a>：容器编排</li><li><a href="https://github.com/features/actions" target="_blank" rel="noopener">GitHub Actions</a>：持续集成平台，负责自动执行集成测试</li><li><a href="https://github.com/vishnubob/wait-for-it" target="_blank" rel="noopener">wait-for-it</a>：约束有依赖关系的服务进行启动等待</li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="编写集成测试用例"><a href="#编写集成测试用例" class="headerlink" title="编写集成测试用例"></a>编写集成测试用例</h3><p>借助 Spring Boot 的支持（如 <a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-with-running-server" target="_blank" rel="noopener">Testing with a running server</a>），在随机端口启动一个 Spring Boot 应用，执行对业务服务的调用。</p><p>本例中基于集成测试基类（<a href="https://github.com/AlphaHinex/spring-roll/blob/master/modules/dev-kits/roll-test/src/main/groovy/io/github/springroll/test/AbstractIntegrationTest.groovy" target="_blank" rel="noopener">AbstractIntegrationTest.groovy</a>），按场景中描述编写了两个测试用例，完整代码可参见 <a href="https://github.com/AlphaHinex/seata-at-demo/blob/seata-at/modules/integration-test/src/test/groovy/io/github/alphahinex/demo/seata/at/integration/test/IntegrationTest.groovy" target="_blank" rel="noopener">IntegrationTest.groovy</a>：</p><pre><code class="groovy">@Testvoid successRequest() {    vo.put(&#39;amount&#39;, 100)    post(url, JsonOutput.toJson(vo), HttpStatus.CREATED)}@Testvoid failedRequest() {    def storage = resOfGet(&quot;http://localhost:8081/at/storage/$commodityCode&quot;, HttpStatus.OK).count    // 生成订单服务抛出异常    vo.put(&#39;amount&#39;, -10)    post(url, JsonOutput.toJson(vo), HttpStatus.INTERNAL_SERVER_ERROR)    // 应用全局事务，库存数据回滚，不会变更    def newStorage = resOfGet(&quot;http://localhost:8081/at/storage/$commodityCode&quot;, HttpStatus.OK).count    assert newStorage == storage}</code></pre><h3 id="容器化部署所有服务"><a href="#容器化部署所有服务" class="headerlink" title="容器化部署所有服务"></a>容器化部署所有服务</h3><p>为简化集成测试运行环境，将所有服务运行在容器中，通过 Docker Compose 进行编排，部署在单节点。</p><p>因为服务之间存在依赖关系，被依赖的服务若未完成启动，可能会导致有依赖的服务也不能正常运行。为解决这个问题，仅依赖 Docker Compose 中提供的 <a href="https://docs.docker.com/compose/compose-file/#depends_on" target="_blank" rel="noopener">depends_on</a> 是不够的，因为 <code>depends_on</code> 仅能保证服务的启动顺序，不能保证服务启动完成（能正常提供服务）之后再启动后续服务。</p><p>官方文档中针对此问题也给出了 <a href="https://docs.docker.com/compose/startup-order/" target="_blank" rel="noopener">方案</a>，可利用 <code>wait-for-it</code> 脚本强制服务进行等待。例如：</p><pre><code class="yaml">order:  image: propersoft/docker-jre:8u171-jre  volumes:    - ./modules/order/build/libs/order-0.0.1-SNAPSHOT.jar:/usr/local/demo/order.jar    - ./docker/wait-for-it.sh:/wait-for-it.sh  depends_on:    - mysql    - nacos    - storage    - account    - seata-server  command: [&quot;./wait-for-it.sh&quot;, &quot;-t&quot;, &quot;0&quot;, &quot;storage:8081&quot;, &quot;--&quot;, &quot;./wait-for-it.sh&quot;, &quot;-t&quot;, &quot;0&quot;, &quot;account:8082&quot;, &quot;--&quot;, &quot;java&quot;, &quot;-jar&quot;, &quot;/usr/local/demo/order.jar&quot;]  ports:    - &quot;8083:8083&quot;</code></pre><p>完整的配置可参考 <a href="https://github.com/AlphaHinex/seata-at-demo/blob/seata-at/docker-compose.yml" target="_blank" rel="noopener">docker-compose</a>。</p><p>这里可能还会遇到一个问题：Feign 接口首次调用失败。</p><p>服务之间通过 <code>@FeignClient</code> 进行 RESTful API 的调用，在默认配置下，Ribbon 是懒加载的，在首次请求时，才会开始初始化相关类，而这可能就会导致各服务启动完毕后，首次被 Feign Client 调用时，调用失败。</p><p>为解决这个问题，可以启用 Ribbon 的 <code>eager load</code>，并配置相应客户端，如：</p><pre><code class="yaml">ribbon:  eager-load:    enabled: true    clients: account, storage</code></pre><p>完整配置文件可参考 <a href="https://github.com/AlphaHinex/seata-at-demo/blob/seata-at/modules/order/src/main/resources/application-dev.yml" target="_blank" rel="noopener">这里</a>。</p><h3 id="运行集成测试"><a href="#运行集成测试" class="headerlink" title="运行集成测试"></a>运行集成测试</h3><p>在 <a href="https://github.com/AlphaHinex/seata-at-demo/blob/seata-at/docker-compose.yml" target="_blank" rel="noopener">docker-compose.yml</a> 所在路径执行</p><pre><code class="bash">$ docker-compose up -d</code></pre><p>即可启动所有服务。因为服务间依赖及强制等待，所有服务启动完毕需要一段时间。</p><p>可访问最后一个服务（ <a href="http://localhost:8084" target="_blank" rel="noopener">http://localhost:8084</a> ），或查看容器日志，确认服务是否完成启动。</p><p>之后可在源码中直接运行集成测试查看效果。</p><h4 id="集成测试与单元测试分别执行"><a href="#集成测试与单元测试分别执行" class="headerlink" title="集成测试与单元测试分别执行"></a>集成测试与单元测试分别执行</h4><p>因为集成测试需要启动服务而单元测试不需要，且集成测试的执行时间一般都要比单元测试的时间长（主要消耗在环境准备上），故利用构建工具执行测试时，最好将单元测试与集成测试分开执行。</p><p>可将集成测试单独放到一个模块内，在常规测试任务中，将这个模块排除，并重新注册一个执行集成测试的任务，如：</p><pre><code>├── account├── business├── integration-test├── order└── storage</code></pre><pre><code class="gradle">test {  exclude &#39;**/integration/**&#39;}task integrationTest(type: Test, dependsOn: test) {  include &#39;**/integration/**&#39;}</code></pre><p>完整配置可见 <a href="https://github.com/AlphaHinex/seata-at-demo/blob/seata-at/modules/integration-test/integration-test.gradle" target="_blank" rel="noopener">integration-test.gradle</a>。</p><p>之后可通过 <code>gradlew test</code> 执行单元测试，通过 <code>gradlew integrationTest</code> 执行集成测试。</p><blockquote><p>单元测试中，涉及调用其他服务时，可通过注解 <code>@MockBean</code> 来模拟其他微服务的行为，例如 <a href="https://github.com/AlphaHinex/seata-at-demo/blob/seata-at/modules/business/src/test/groovy/io/github/alphahinex/demo/seata/at/business/BusinessApplicationTest.groovy" target="_blank" rel="noopener">BusinessApplicationTest.groovy</a></p></blockquote><p>在本地环境可验证集成测试执行结果为通过。</p><p>那么如何在持续集成环境自动化完成这个过程呢？</p><h3 id="持续集成环境配置"><a href="#持续集成环境配置" class="headerlink" title="持续集成环境配置"></a>持续集成环境配置</h3><p>完成以上步骤后，要完成自动化测试，理论上只剩下在 CI 上启动服务和执行集成测试任务了。</p><p>本例中选用的 CI 平台是 GitHub Actions，对于托管在 GitHub 上的项目，要使用 GitHub Actions，需要做的就是在代码仓库中增加配置文件，如 <a href="https://github.com/AlphaHinex/seata-at-demo/blob/seata-at/.github/workflows/check.yml" target="_blank" rel="noopener">./github/workflows/check.yml</a>。</p><p>So easy 是吧，但在 GitHub Actions 中运行本例的集成测试时，依然遇到了两个问题：</p><ol><li><strong>无法映射到 3306 端口</strong>：不确定 GitHub Actions 环境中 3306 端口是不是给 mysql 的 action 预留了，docker 无法将容器端口映射到宿主的 3306 上。修改为其他端口即可。</li><li><strong>wait-for-it 无效</strong>：在 GitHub Actions 环境下 wait-for-it 脚本虽然能正常执行但没有起到实际作用，此处没有找到太好的解决办法，通过增加一个等待的 action，在执行 <code>docker-compose up</code> 后强行等待一段时间，等服务都启动完成后再去执行集成测试。具体例子可见 <a href="https://github.com/AlphaHinex/seata-at-demo/blob/seata-at/.github/workflows/check.yml#L43-L46" target="_blank" rel="noopener">check.yml#L43-L46</a>。</li></ol><p>在 GitHub Actions 上的集成测试执行情况可见：<a href="https://github.com/AlphaHinex/seata-at-demo/actions?query=workflow%3ACheck" target="_blank" rel="noopener">https://github.com/AlphaHinex/seata-at-demo/actions?query=workflow%3ACheck</a></p><p>本文完整实例可见：<a href="https://github.com/AlphaHinex/seata-at-demo" target="_blank" rel="noopener">https://github.com/AlphaHinex/seata-at-demo</a></p>]]></content>
      
      
      <categories>
          
          <category> Test </category>
          
          <category> Microservices </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Integration test </tag>
            
            <tag> Automation test </tag>
            
            <tag> Microservices </tag>
            
            <tag> DevOps </tag>
            
            <tag> GitHub Actions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 Gooreplacer 科学访问 Codecov</title>
      <link href="2020/01/29/using-gooreplacer-to-access-codecov/"/>
      <url>2020/01/29/using-gooreplacer-to-access-codecov/</url>
      
        <content type="html"><![CDATA[<p><a href="https://codecov.io/" target="_blank" rel="noopener">Codecov</a> 是一个测试覆盖率结果可视化展现网站，并与 GitHub 和 Pull Request 有较好的集成，可以在 Pull Request 中展现覆盖率变化结果，协助保证代码质量。</p><p>不过在 GFW 环境下访问 Codecov 不是很稳定，因为网站使用了一些 Google 的 CDN 资源（主要是 js 和 css）。利用 <a href="https://liujiacai.net/gooreplacer/" target="_blank" rel="noopener">Gooreplacer</a> 可以将这些资源重定向到可访问的地址，科学使用 Codecov 提供的服务。</p><h2 id="安装-Gooreplacer-Chrome-插件"><a href="#安装-Gooreplacer-Chrome-插件" class="headerlink" title="安装 Gooreplacer Chrome 插件"></a>安装 Gooreplacer Chrome 插件</h2><p>因无法直接在线安装 Chrome 插件，可以从 Gooreplacer 的 <a href="https://github.com/jiacai2050/gooreplacer/releases" target="_blank" rel="noopener">Releases</a> 页面直接下载作者打好的 zip 包，如：<a href="https://github.com/jiacai2050/gooreplacer/releases/download/v3.11.0/chrome_gooreplacer_1574507740.zip" target="_blank" rel="noopener">https://github.com/jiacai2050/gooreplacer/releases/download/v3.11.0/chrome_gooreplacer_1574507740.zip</a> 。在 Chrome 的 <code>扩展程序</code> 中打开 <code>开发者模式</code>，直接加载解压出的内容即可。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置在线规则"><a href="#配置在线规则" class="headerlink" title="配置在线规则"></a>配置在线规则</h3><p>可参照 <a href="https://github.com/jiacai2050/gooreplacer/blob/master/README.md" target="_blank" rel="noopener">README</a> 中内容配置好在线规则，即可完成大部分 Google 资源的重定向。</p><h3 id="去掉-content-security-policy-限制"><a href="#去掉-content-security-policy-限制" class="headerlink" title="去掉 content-security-policy 限制"></a>去掉 content-security-policy 限制</h3><p>由于 Codecov 网站安全限制，浏览器会拒绝加载重定向的资源。可参照 <a href="https://github.com/jiacai2050/gooreplacer/issues/13" target="_blank" rel="noopener">#13</a> 中方式，在 <code>请求/响应头</code> 中，新增一个响应头，填写如下信息：</p><table><thead><tr><th align="left">key</th><th align="left">value</th></tr></thead><tbody><tr><td align="left">匹配模式</td><td align="left">codecov.io</td></tr><tr><td align="left">匹配类型</td><td align="left">通配符</td></tr><tr><td align="left">动作类型</td><td align="left">拦截</td></tr><tr><td align="left">键名</td><td align="left">content-security-policy</td></tr><tr><td align="left">键值</td><td align="left">空</td></tr><tr><td align="left">是否开启</td><td align="left">是</td></tr></tbody></table><h3 id="重定向-codecov-资源"><a href="#重定向-codecov-资源" class="headerlink" title="重定向 codecov 资源"></a>重定向 codecov 资源</h3><table><thead><tr><th align="left">匹配模式</th><th align="left">目标地址</th></tr></thead><tbody><tr><td align="left"><a href="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js" target="_blank" rel="noopener">https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js</a></td><td align="left"><a href="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js" target="_blank" rel="noopener">https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js</a></td></tr><tr><td align="left"><a href="https://codecov-cdn.storage.googleapis.com/4.4.11-95184d8/bower/deps.min.css" target="_blank" rel="noopener">https://codecov-cdn.storage.googleapis.com/4.4.11-95184d8/bower/deps.min.css</a></td><td align="left"><a href="https://alphahinex.github.io/proxy/codecov/deps.min.css">https://alphahinex.github.io/proxy/codecov/deps.min.css</a></td></tr><tr><td align="left"><a href="https://codecov-cdn.storage.googleapis.com/4.4.11-95184d8/media/css/style.css" target="_blank" rel="noopener">https://codecov-cdn.storage.googleapis.com/4.4.11-95184d8/media/css/style.css</a></td><td align="left"><a href="https://alphahinex.github.io/proxy/codecov/style.css">https://alphahinex.github.io/proxy/codecov/style.css</a></td></tr><tr><td align="left"><a href="https://codecov-cdn.storage.googleapis.com/4.4.11-95184d8/bower/deps.min.js" target="_blank" rel="noopener">https://codecov-cdn.storage.googleapis.com/4.4.11-95184d8/bower/deps.min.js</a></td><td align="left"><a href="https://alphahinex.github.io/proxy/codecov/deps.min.js">https://alphahinex.github.io/proxy/codecov/deps.min.js</a></td></tr><tr><td align="left"><a href="https://codecov-cdn.storage.googleapis.com/4.4.11-95184d8/media/js/script.min.js" target="_blank" rel="noopener">https://codecov-cdn.storage.googleapis.com/4.4.11-95184d8/media/js/script.min.js</a></td><td align="left"><a href="https://alphahinex.github.io/proxy/codecov/script.min.js">https://alphahinex.github.io/proxy/codecov/script.min.js</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> GFW </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Codecov </tag>
            
            <tag> GFW </tag>
            
            <tag> Gooreplacer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to integrate SEATA AT mode with Spring Cloud</title>
      <link href="2020/01/22/how-to-integrate-seata-at-mode-with-spring-cloud/"/>
      <url>2020/01/22/how-to-integrate-seata-at-mode-with-spring-cloud/</url>
      
        <content type="html"><![CDATA[<p>本文基于一个 Spring Cloud 业务实例，说明如何集成 SEATA AT 模式，进行分布式事务控制。</p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><h3 id="SEATA-是什么？"><a href="#SEATA-是什么？" class="headerlink" title="SEATA 是什么？"></a>SEATA 是什么？</h3><p>Seata: Simple Extensible Autonomous Transaction Architecture</p><blockquote><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。 —— 引用自 SEATA <a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="AT-模式是什么？"><a href="#AT-模式是什么？" class="headerlink" title="AT 模式是什么？"></a>AT 模式是什么？</h3><p><a href="https://blog.csdn.net/m0_38110132/article/details/77043580" target="_blank" rel="noopener">TXC分布式事务简介</a> 中提到，AT 模式意为 Automatic Taobao Transaction Constructor，但在 SEATA 的官方文档中，并没有关于 AT 名称具体的解释。个人认为 AT 模式可以归类为柔性事务中的二阶段提交方式实现，一阶段先将本地事务进行提交，二阶段如果需要回滚，会根据一阶段生成的 undo log 自动进行回滚，所以可以认为 AT 模式是自动完成回滚的二阶段提交分布式事务处理模型，这也应该是 AT 模式名称的由来。</p><h3 id="为什么要使用-SEATA-AT-模式？"><a href="#为什么要使用-SEATA-AT-模式？" class="headerlink" title="为什么要使用 SEATA AT 模式？"></a>为什么要使用 SEATA AT 模式？</h3><p>由上述内容可以看到，AT 模式的优缺点非常明显：</p><ul><li>优点：侵入性小，可以用较小代价获得基本的分布式事务控制</li><li>缺点：一阶段会直接提交，不保证读隔离性</li></ul><blockquote><p>如果应用在特定场景下，必需要求全局的 <strong>读已提交</strong> ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。</p></blockquote><p>为了付出二成努力获得八成效果，AT 模式的优点具有很强吸引力。</p><h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><p>假设当前有这样一个基础微服务环境：</p><ul><li>基于 <a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener">Spring Cloud</a> 构建，使用 <a href="https://nacos.io" target="_blank" rel="noopener">Nacos</a> 作为注册中心，利用 <a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">OpenFeign</a> 进行服务间 RESTFul API 的调用。</li></ul><p>包含以下服务：</p><ol><li>库存服务（storage）</li><li>用户账户服务（account）</li><li>订单服务（order）</li><li>业务服务（business）</li></ol><p>业务服务作为直接被调用的接口，组织关联其他三个服务。下订单时，服务的调用顺序如下：</p><pre><code>1. 减库存（storage）2. 创建订单2.1. 扣减用户账户（account）2.2. 生成订单（order）</code></pre><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><a href="https://github.com/AlphaHinex/seata-at-demo/tree/master" target="_blank" rel="noopener">这里</a> 构建了一个包含上述环境的可运行实例，可导入 IDEA 中或使用提供的 docker-compose 查看效果。</p><blockquote><p>注意：该实例运行需要用到发布到 GitHub Packages Registry 的 jar 包，可参考 <a href="https://alphahinex.github.io/2020/01/17/github-packages-in-action/">GitHub Packages in Action</a> 进行配置。</p></blockquote><p>可以在发送第二个 POST 请求得到异常之后查看数据库的数据变化情况，也可以通过集成测试来验证在没有分布式事务控制的情况下，发生异常时三个服务的数据状态出现了不一致。</p><h2 id="集成-SEATA-AT-模式"><a href="#集成-SEATA-AT-模式" class="headerlink" title="集成 SEATA AT 模式"></a>集成 SEATA AT 模式</h2><p>集成所需所有改动可见 <a href="https://github.com/AlphaHinex/seata-at-demo/compare/master...seata-at" target="_blank" rel="noopener">https://github.com/AlphaHinex/seata-at-demo/compare/master...seata-at</a></p><h3 id="添加-SEATA-依赖"><a href="#添加-SEATA-依赖" class="headerlink" title="添加 SEATA 依赖"></a>添加 SEATA 依赖</h3><pre><code class="gradle">implementation &#39;com.alibaba.cloud:spring-cloud-starter-alibaba-seata:2.1.1.RELEASE&#39;implementation &#39;io.seata:seata-all:1.0.0&#39;implementation &#39;io.seata:seata-spring-boot-starter:1.0.0&#39;</code></pre><h4 id="为什么需要三个-SEATA-的依赖？每个依赖的作用是什么？"><a href="#为什么需要三个-SEATA-的依赖？每个依赖的作用是什么？" class="headerlink" title="为什么需要三个 SEATA 的依赖？每个依赖的作用是什么？"></a>为什么需要三个 SEATA 的依赖？每个依赖的作用是什么？</h4><ol><li><p>spring-cloud-starter-alibaba-seata</p><p> 对 Feign Client 和全局事务 XID 进行了自动配置。</p><p> 需要注意的是 Spring Cloud Alibaba 的毕业版本的 GroupId 是 <code>com.alibaba.cloud</code>。<code>spring-cloud-starter-alibaba-seata</code> 这个依赖中只依赖了 <code>spring-cloud-alibaba-seata</code>，所以在项目中添加 <code>spring-cloud-starter-alibaba-seata</code> 和 <code>spring-cloud-alibaba-seata</code> 是一样的。</p></li><li><p>seata-all</p><p> <code>spring-cloud-starter-alibaba-seata</code> 装配的 SEATA 版本为 0.9.0，若需使用其他版本，需额外进行依赖。本例中使用的 SEATA 版本为 1.0.0，故需单独配置 <code>io.seata:seata-all:1.0.0</code> 依赖。</p></li><li><p>seata-spring-boot-starter</p><p>包括自动代理数据源，及支持 yml 配置。</p><p>此处需注意，虽说引入此 jar 包后可以通过 yml 的方式对 registry.conf 及 file.conf 中内容进行配置，但目前仍存在一些问题导致无法全部替代 conf 配置文件。例如：</p><p>用 yml 配置与 registry.conf 相同的内容，会报 <code>no available service &#39;null&#39; found, please make sure registry config correct</code></p><p>服务启动后，持续报如下警告：<code>io.seata.config.FileConfiguration        : Could not found property service.disableGlobalTransaction, try to use default value instead.</code></p><p>类似问题在 <a href="https://github.com/seata/seata/issues/2114" target="_blank" rel="noopener">https://github.com/seata/seata/issues/2114</a> 中也有讨论。目前的解决方案为：还是通过 registry.conf 和 file.conf 来存放 yml 中配置无效的内容，</p><p>另外，在同时引入 <code>spring-cloud-starter-alibaba-seata</code> 及 <code>seata-spring-boot-starter</code> 依赖时，需要排除掉 <code>spring-cloud-alibaba-seata</code> 里的 <code>GlobalTransactionAutoConfiguration</code>，否则会报错，详见 <a href="https://github.com/seata/seata/issues/2076" target="_blank" rel="noopener">https://github.com/seata/seata/issues/2076</a> 。</p></li></ol><h3 id="在各服务数据库中增加-undo-log-表"><a href="#在各服务数据库中增加-undo-log-表" class="headerlink" title="在各服务数据库中增加 undo_log 表"></a>在各服务数据库中增加 undo_log 表</h3><p>建表语句可从 SEATA 发布版中获得，如 <a href="https://github.com/seata/seata/blob/v1.0.0/script/client/at/db/mysql.sql" target="_blank" rel="noopener">https://github.com/seata/seata/blob/v1.0.0/script/client/at/db/mysql.sql</a> 。</p><p>示例中为简化过程，所有服务共用一个数据库，并通过 mysql 启动初始化过程，在库中创建了 undo_log 表。</p><h3 id="各服务中配置-SEATA-服务端地址"><a href="#各服务中配置-SEATA-服务端地址" class="headerlink" title="各服务中配置 SEATA 服务端地址"></a>各服务中配置 SEATA 服务端地址</h3><p>因引入了 <code>seata-spring-boot-starter</code>，可使用 yml 进行配置，如：</p><pre><code class="yml">seata:  service:    grouplist: seata-server:8091</code></pre><h3 id="添加全局事务注解"><a href="#添加全局事务注解" class="headerlink" title="添加全局事务注解"></a>添加全局事务注解</h3><p>终于把准备工作都完成了，使用 SEATA AT 模式最核心的一步：在 controller 或者 service 上，标记 <code>@GlobalTransactional</code> 注解。That’s all。</p><p>没错，这就结束了。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>可通过集成测试对分布式事务的效果进行验证。如 <a href="https://github.com/AlphaHinex/seata-at-demo" target="_blank" rel="noopener">seata-at-demo</a> 中 README 所示，使用 seata-at 分支代码，在所有服务均正常启动完毕之后，可通过提供的 curl 或编写好的集成测试对效果进行验证。</p><p>集成测试结果通过，即表示分布式事务生效，在调用过程中出现异常时，之前执行过的服务对数据进行的变更会自动回滚。</p><p>使用 curl 进行验证时，需自己检查数据库中数据变化情况。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Microservice </category>
          
          <category> Distributed Transaction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gradle </tag>
            
            <tag> Docker </tag>
            
            <tag> SEATA </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> Nacos </tag>
            
            <tag> OpenFeign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Packages in Action</title>
      <link href="2020/01/17/github-packages-in-action/"/>
      <url>2020/01/17/github-packages-in-action/</url>
      
        <content type="html"><![CDATA[<p><a href="https://help.github.com/en/github/managing-packages-with-github-packages" target="_blank" rel="noopener">GitHub Packages</a> 可以用来当做 Release 版本 jar 包的 Maven 仓库。</p><p>与 Maven 中央库比，没有繁琐的申请流程，可以快速的将 jar 包发布出去供他人使用。</p><p>与 Nexus 私服相比，无需架设公网访问环境。</p><p><strong>缺点</strong> 是只支持 Release 版本的发布和下载，Snapshot 版本虽然可以发布上去，但无法被其他项目依赖。目前尚不支持自行删除已上传的 jar 包，需联系 GitHub 协助处理。</p><p>本文以实例说明，在 Gradle 中如何利用 GPR（GitHub Packages Registry）进行发布版 jar 包的上传、下载及删除。</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>参考 <a href="https://help.github.com/en/github/managing-packages-with-github-packages/configuring-gradle-for-use-with-github-packages" target="_blank" rel="noopener">官方文档</a>，需完成如下步骤。</p><h3 id="在-GitHub-创建-Personal-access-token"><a href="#在-GitHub-创建-Personal-access-token" class="headerlink" title="在 GitHub 创建 Personal access token"></a>在 GitHub 创建 Personal access token</h3><p>GPR 相当于一个需要权限才可访问的 Maven 仓库。故必须使用 GitHub 账号进行相应操作。虽按文档描述可直接利用 GitHub 账号密码（实际若直接用密码，会收到提示，无法正常使用），但更推荐的是通过 token 的方式，限定 token 的权限范围，利用不同 token 完成不同操作。</p><p>可在 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a> 创建个人的 token，GRP 相关权限可见 <a href="https://help.github.com/en/github/managing-packages-with-github-packages/about-github-packages#about-tokens" target="_blank" rel="noopener">About tokens</a>。</p><p>建议创建如下两个 token：</p><ul><li>只读 token（包含 <code>read:packages</code>）：可用来从 GPR 下载自己 <strong>及他人</strong> 发布的 jar 包</li><li>管理 token（包含 <code>read:packages</code>, <code>write:packages</code>, <code>delete:packages</code>, <code>repo</code>）：可发布、删除 packages</li></ul><h3 id="在-build-gradle-中添加配置"><a href="#在-build-gradle-中添加配置" class="headerlink" title="在 build.gradle 中添加配置"></a>在 <code>build.gradle</code> 中添加配置</h3><p>借助 Gradle 的 <code>maven-publish</code> 插件，将 GPR 配置为 Maven 仓库，通过 <code>publish</code> task 即可完成上传。</p><p>以使用 Gradle Groovy 的单包仓库为例，可在 <code>build.gradle</code> 中添加如下内容（注意替换 <code>username</code> 和 <code>password</code>）：</p><pre><code class="gradle">plugins {    id(&quot;maven-publish&quot;)}publishing {    repositories {        maven {            name = &quot;GitHubPackages&quot;            url = uri(&quot;https://maven.pkg.github.com/OWNER/REPOSITORY&quot;)            credentials {                username = project.findProperty(&quot;gpr.user&quot;) ?: System.getenv(&quot;USERNAME&quot;)                password = project.findProperty(&quot;gpr.key&quot;) ?: System.getenv(&quot;PASSWORD&quot;)            }        }    }    publications {        gpr(MavenPublication) {            from(components.java)        }    }}</code></pre><blockquote><p>更多示例可参考 <a href="https://help.github.com/en/github/managing-packages-with-github-packages/configuring-gradle-for-use-with-github-packages" target="_blank" rel="noopener">官方文档</a> 或 <a href="https://github.com/AlphaHinex/spring-roll" target="_blank" rel="noopener">spring-roll</a> 项目的 <a href="https://github.com/AlphaHinex/spring-roll/blob/master/build.gradle" target="_blank" rel="noopener">实例</a>。</p></blockquote><p>此处需补充一下，发布 jar 包时若需要包含源码，需在编译阶段生成好源码 jar 包。</p><p>Gradle 6.0.1 Java 插件对此提供了支持，可直接在 <code>build.gradle</code> 中添加如下内容</p><pre><code class="gradle">java {    withSourcesJar()}</code></pre><blockquote><p>若是 6.x 之前的版本，可自定义 task 完成源码 jar 包的打包，但是否能正常上传 GPR 未验证。</p></blockquote><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><pre><code class="bash">$ ./gradlew publish</code></pre><p>发布成功后，可在仓库的 <a href="https://github.com/AlphaHinex/spring-roll/packages" target="_blank" rel="noopener">packages</a> 选项卡或 <a href="https://github.com/AlphaHinex?tab=packages" target="_blank" rel="noopener">Profile</a> 中查看，也可使用类似 <a href="https://maven.pkg.github.com/alphahinex/spring-roll/io/github/spring-roll/roll-base/0.0.1.RELEASE/roll-base-0.0.1.RELEASE.pom" target="_blank" rel="noopener">https://maven.pkg.github.com/alphahinex/spring-roll/io/github/spring-roll/roll-base/0.0.1.RELEASE/roll-base-0.0.1.RELEASE.pom</a> 的地址（需提供 GPR 的访问权限）确认。</p><blockquote><p>开发时若需要将 SNAPSHOT 版本发布到本地 Maven 库，可使用 <code>./gradlew publishToMavenLocal</code>，并在项目 <code>build.gradle</code> 文件的 <code>repositories</code> 块中增加 <code>mavenLocal()</code>。</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>需下载他人发布到 GPR 中的 jar 包时，配置方式与配置 Nexus 私服的方式类似，例如：</p><pre><code class="gradle">repositories {  mavenCentral()  mavenLocal()  maven {    url &quot;https://maven.pkg.github.com/alphahinex/spring-roll&quot;    credentials {      username = &#39;GITHUB_USERNAME&#39;      password = &#39;TOKEN_WITH_READ:PACKAGES_SCOPE&#39;    }  }}</code></pre><p>之后在 <code>dependencies</code> 中添加依赖，如 <code>implementation &#39;io.github.spring-roll:roll-base:0.0.1.RELEASE&#39;</code>，若一切顺利即可下载到 roll-base v0.0.1.RELEASE 的 jar 包和源码。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>虽然有 <code>delete:packages</code> 权限，但目前 GitHub 仅允许用户对上传到 GPR 的私有仓库的 jar 包进行删除。</p><p>若需要删除公开仓库的 jar 包，需通过 <a href="https://support.github.com/contact" target="_blank" rel="noopener">支持</a> 与 GitHub 联系，并提供需要删除的包的链接。</p><p>删除私有库的 jar 包需使用 GitHub 在 GraphQL 中提供的删除方法（未验证）。</p><p>删除前需获得要删除的包的 <code>packageVersionId</code>（界面不可见），可通过查询接口进行查询，如：</p><pre><code class="bash">$ curl -X POST \-H &quot;Authorization: bearer TOKEN&quot; \-H &quot;Accept: application/vnd.github.packages-preview+json&quot; \-d &#39;{&quot;query&quot;: &quot;query { user(login: \&quot;AlphaHinex\&quot;) { registryPackagesForQuery(packageType: MAVEN, first: 100) { edges { node { name id version(version: \&quot;0.1.0.RELEASE\&quot;) { id version }} } } }}&quot;}&#39; https://api.github.com/graphql</code></pre><p>得到类似下方的信息：</p><pre><code class="json">{  &quot;data&quot;: {    &quot;user&quot;: {      &quot;registryPackagesForQuery&quot;: {        &quot;edges&quot;: [          {            &quot;node&quot;: {              &quot;name&quot;: &quot;io.github.spring-roll.roll-base&quot;,              &quot;id&quot;: &quot;MDc6UGFja2FnZTkyOTgy&quot;,              &quot;version&quot;: {                &quot;id&quot;: &quot;MDE0OlBhY2thZ2VWZXJzaW9uNTI3MTcx&quot;,                &quot;version&quot;: &quot;0.1.0-SNAPSHOT&quot;              }            }          },          {            &quot;node&quot;: {              &quot;name&quot;: &quot;io.github.spring-roll.roll-dev-configs&quot;,              &quot;id&quot;: &quot;MDc6UGFja2FnZTkyOTg0&quot;,              &quot;version&quot;: {                &quot;id&quot;: &quot;MDE0OlBhY2thZ2VWZXJzaW9uNTI3MTcy&quot;,                &quot;version&quot;: &quot;0.1.0-SNAPSHOT&quot;              }            }          },          {            &quot;node&quot;: {              &quot;name&quot;: &quot;io.github.spring-roll.roll-dl&quot;,              &quot;id&quot;: &quot;MDc6UGFja2FnZTkyOTg1&quot;,              &quot;version&quot;: {                &quot;id&quot;: &quot;MDE0OlBhY2thZ2VWZXJzaW9uNTI3MTcz&quot;,                &quot;version&quot;: &quot;0.1.0-SNAPSHOT&quot;              }            }          },          {            &quot;node&quot;: {              &quot;name&quot;: &quot;io.github.spring-roll.roll-test&quot;,              &quot;id&quot;: &quot;MDc6UGFja2FnZTkyOTg2&quot;,              &quot;version&quot;: {                &quot;id&quot;: &quot;MDE0OlBhY2thZ2VWZXJzaW9uNTI3MTc0&quot;,                &quot;version&quot;: &quot;0.1.0-SNAPSHOT&quot;              }            }          },          {            &quot;node&quot;: {              &quot;name&quot;: &quot;io.github.spring-roll.roll-utils&quot;,              &quot;id&quot;: &quot;MDc6UGFja2FnZTkyOTg3&quot;,              &quot;version&quot;: {                &quot;id&quot;: &quot;MDE0OlBhY2thZ2VWZXJzaW9uNTI3MTc3&quot;,                &quot;version&quot;: &quot;0.1.0-SNAPSHOT&quot;              }            }          },          {            &quot;node&quot;: {              &quot;name&quot;: &quot;io.github.spring-roll.roll-web&quot;,              &quot;id&quot;: &quot;MDc6UGFja2FnZTkyOTg4&quot;,              &quot;version&quot;: {                &quot;id&quot;: &quot;MDE0OlBhY2thZ2VWZXJzaW9uNTI3MTc5&quot;,                &quot;version&quot;: &quot;0.1.0-SNAPSHOT&quot;              }            }          }        ]      }    }  }}</code></pre><p>获得到要删除的 jar 包的 <code>packageVersionId</code> 后，依旧通过 GraphQL 接口删除：</p><pre><code class="bash">$ curl -X POST \-H &quot;Accept: application/vnd.github.package-deletes-preview+json&quot; \-H &quot;Authorization: bearer TOKEN&quot; \-d &#39;{&quot;query&quot;:&quot;mutation { deletePackageVersion(input:{packageVersionId:\&quot;MDc6UGFja2FnZTkyOTgy\&quot;}) { success }}&quot;}&#39; \https://api.github.com/graphql</code></pre><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>jar 包发布可参考项目 <a href="https://github.com/AlphaHinex/spring-roll" target="_blank" rel="noopener">spring-roll</a></li><li>使用 jar 包可参考项目 <a href="https://github.com/AlphaHinex/seata-at-demo" target="_blank" rel="noopener">seata-at-demo</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.jianshu.com/p/af7ac20f2c64" target="_blank" rel="noopener">GraphQL 实战：GitHub V4 API 使用</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gradle </tag>
            
            <tag> GitHub </tag>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Using Gradle Behind Proxy</title>
      <link href="2020/01/05/using-gradle-behind-proxy/"/>
      <url>2020/01/05/using-gradle-behind-proxy/</url>
      
        <content type="html"><![CDATA[<p>在网络代理环境下使用 Gradle 时，可能会遇到以下三个问题：</p><ol><li><code>gradlew</code> 下载对应 Gradle 发布版时无法下载</li><li>下载依赖时，提示连接超时</li><li>SSL 证书无效</li></ol><h2 id="gradlew-下载对应-Gradle-发布版时无法下载"><a href="#gradlew-下载对应-Gradle-发布版时无法下载" class="headerlink" title="gradlew 下载对应 Gradle 发布版时无法下载"></a><code>gradlew</code> 下载对应 Gradle 发布版时无法下载</h2><h3 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h3><p><code>Unable to tunnel through proxy. Proxy returns &quot;HTTP/1.1 407 Proxy Authorization Required&quot;</code></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>wrapper 下载发布包时也需要配置代理</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>试遍各种为 wrapper 配置代理的方法，均无果。用最直接的办法：按照 <code>gradle.properties</code> 中 <code>distributionUrl</code> 路径，手动下载好发布包，放到 wrapper 自动创建的路径下（如：<code>~/.gradle/wrapper/dists/gradle-6.0.1-all/99d3u8wxs16ndehh90lbbir67</code>），继续执行 gradlew 命令即可。</p><h2 id="下载依赖时，提示连接超时"><a href="#下载依赖时，提示连接超时" class="headerlink" title="下载依赖时，提示连接超时"></a>下载依赖时，提示连接超时</h2><h3 id="错误提示-1"><a href="#错误提示-1" class="headerlink" title="错误提示"></a>错误提示</h3><p><code>&gt; Connection timed out: connect</code></p><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p>需为 Gradle 配置代理参数</p><h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p>在 <code>gradle.properties</code> 中添加如下内容（注意修改各参数值）：</p><pre><code class="properties">systemProp.http.proxyHost=www.somehost.orgsystemProp.http.proxyPort=8080systemProp.http.proxyUser=useridsystemProp.http.proxyPassword=passwordsystemProp.http.nonProxyHosts=*.nonproxyrepos.com|localhostsystemProp.https.proxyHost=www.somehost.orgsystemProp.https.proxyPort=8080systemProp.https.proxyUser=useridsystemProp.https.proxyPassword=passwordsystemProp.https.nonProxyHosts=*.nonproxyrepos.com|localhost</code></pre><h2 id="SSL-证书无效"><a href="#SSL-证书无效" class="headerlink" title="SSL 证书无效"></a>SSL 证书无效</h2><h3 id="错误提示-2"><a href="#错误提示-2" class="headerlink" title="错误提示"></a>错误提示</h3><p><code>&gt; sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</code></p><h3 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h3><p>错误提示中，<code>unable to find valid certification path</code> 和 <code>PKIX path building failed</code> 表明了这是因 SSL 证书引起的问题。<br>在通过代理访问网络时，可能需要在本地添加需要信任的根证书（在未添加根证书并信任时，无法通过浏览器访问 https 站点）。<br>在此种环境下，需要为 Gradle 所使用的 Java 也进行类似操作，才能通过 Java 代码访问 https 资源（如：<a href="https://plugins.gradle.org/）。" target="_blank" rel="noopener">https://plugins.gradle.org/）。</a></p><h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="1-确定-Gradle-所使用的-Java-路径"><a href="#1-确定-Gradle-所使用的-Java-路径" class="headerlink" title="1. 确定 Gradle 所使用的 Java 路径"></a>1. 确定 Gradle 所使用的 Java 路径</h4><p>先找到 Gradle 所使用的 Java home，可通过 <code>./gradlew -v</code> 查看所使用的 Java 版本。</p><h4 id="2-查看-JDK-中已存在的证书"><a href="#2-查看-JDK-中已存在的证书" class="headerlink" title="2. 查看 JDK 中已存在的证书"></a>2. 查看 JDK 中已存在的证书</h4><p>假设已定义了环境变量 <code>JAVA_HOME</code> 代表 JDK 安装路径，可通过如下命令查看 keystore 中已经存在的证书：</p><pre><code class="bash">$ keytool -list -keystore $JAVA_HOME/jre/lib/security/cacerts</code></pre><p>提示需要输入密码时，直接回车即可。</p><h4 id="3-导入新证书"><a href="#3-导入新证书" class="headerlink" title="3. 导入新证书"></a>3. 导入新证书</h4><p>将网络代理方提供的根证书导入到 keystore 中（注意修改 <code>&lt;&gt;</code> 中变量）：</p><pre><code class="bash">$ sudo keytool -import -alias &lt;alias&gt; -keystore $JAVA_HOME/jre/lib/security/cacerts -file &lt;/path/to/cert/file&gt;</code></pre><p>默认密码：<code>changeit</code></p><h4 id="4-配置信任证书"><a href="#4-配置信任证书" class="headerlink" title="4. 配置信任证书"></a>4. 配置信任证书</h4><p>证书导入至 keystore 之后，还需将其加入 truststore。</p><p>在 <code>gradle.properties</code> 中添加如下内容（注意修改 <code>&lt;&gt;</code> 中内容）：</p><pre><code class="properties">systemProp.javax.net.ssl.trustStore=&lt;JAVA_HOME&gt;/jre/lib/security/cacertssystemProp.javax.net.ssl.trustStorePassword=changeit</code></pre><p>配置完成后，可能需要重新开启终端，继续执行 Gradle 命令，即可生效。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.cresco.co.jp/blog/entry/2014/" target="_blank" rel="noopener">Solutions for “Unable to resolve dependency” on building with Android Studio 3.0</a></li><li><a href="https://www.jianshu.com/p/60278f144fc6" target="_blank" rel="noopener">AndroidStudio构建项目异常:PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderE…</a></li><li><a href="http://www.voidcn.com/article/p-shfykodk-pw.html" target="_blank" rel="noopener">import a .cer file to .keysore file</a></li><li><a href="https://stackoverflow.com/questions/52779083/truststore-setup-for-gradle-plugin-in-intellij" target="_blank" rel="noopener">Truststore setup for gradle plugin in IntelliJ</a></li><li><a href="https://stackoverflow.com/questions/21252800/how-to-tell-maven-to-disregard-ssl-errors-and-trusting-all-certs" target="_blank" rel="noopener">How to tell Maven to disregard SSL errors (and trusting all certs)?</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gradle </tag>
            
            <tag> Proxy </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Using Liquibase with Gradle in Spring Project</title>
      <link href="2018/05/15/liquibase-with-gradle/"/>
      <url>2018/05/15/liquibase-with-gradle/</url>
      
        <content type="html"><![CDATA[<p>Spring 项目通过 Gradle 插件使用 Liquibase 的简易说明</p><h2 id="Liquibase-是什么"><a href="#Liquibase-是什么" class="headerlink" title="Liquibase 是什么"></a>Liquibase 是什么</h2><p>引用 <a href="http://www.liquibase.org/index.html" target="_blank" rel="noopener">Liquibase 官网</a> 的一张图片：</p><p><img src="http://www.liquibase.org/custom_images/home_tagline.png" alt="Source Control for Your Database"></p><p>类似的工具还有 <a href="https://flywaydb.org/" target="_blank" rel="noopener">Flyway</a>。</p><h2 id="为什么选择-Liquibase"><a href="#为什么选择-Liquibase" class="headerlink" title="为什么选择 Liquibase"></a>为什么选择 Liquibase</h2><p><a href="https://flywaydb.org/" target="_blank" rel="noopener">Flyway 官网</a> 上有一个同类工具特性的对比，详见 <code>Feature Comparison</code> 部分或下图：</p><p><img src="/contents/liquibase-with-gradle/Feature-Comparison.png" alt="Feature Comparison"></p><p>看图的话，Flyway 完胜，不过 <strong>等等！看完下面内容再做决定</strong>：</p><ul><li><a href="https://stackoverflow.com/questions/37385823/liquibase-vs-flyway-which-one-to-use" target="_blank" rel="noopener">Liquibase vs Flyway which one to use?</a></li><li><a href="https://reflectoring.io/database-refactoring-flyway-vs-liquibase/" target="_blank" rel="noopener">Tool-based Database Refactoring: Flyway vs. Liquibase</a></li><li><a href="http://ju.outofmemory.cn/entry/85903" target="_blank" rel="noopener">Java世界最棒的DB Migration Tool</a></li></ul><p>一句话总结一下：</p><pre><code>面向 SQL，选择 Flyway不面向 SQL，选择 Liquibase</code></pre><h2 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use?"></a>How to use?</h2><p>Liquibase 的使用方式可参考官方提供的 <a href="http://www.liquibase.org/quickstart.html" target="_blank" rel="noopener">Quick Start</a> 文档，这里主要讲一下 <strong>Liquibase 和 Spring 集成使用的方式</strong>。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>先统一一下本文中使用的各类组件的版本：</p><ul><li><a href="https://github.com/liquibase/liquibase/tree/liquibase-parent-3.6.1" target="_blank" rel="noopener">liquibase v3.6.1</a></li><li><a href="https://github.com/liquibase/liquibase-gradle-plugin/tree/acf7a693563471f83fd26b9e15365ab98011d804" target="_blank" rel="noopener">liquibase-gradle-plugin v1.2.4</a></li><li><a href="https://github.com/gradle/gradle/tree/v4.6.0" target="_blank" rel="noopener">Gradle v4.6</a></li><li><a href="https://github.com/h2database/h2database/tree/version-1.3/version-1.3.176/h2" target="_blank" rel="noopener">H2 v1.3.176</a></li></ul><h3 id="入口-bean"><a href="#入口-bean" class="headerlink" title="入口 bean"></a>入口 bean</h3><pre><code class="xml">&lt;bean id=&quot;liquibase&quot; class=&quot;liquibase.integration.spring.SpringLiquibase&quot; lazy-init=&quot;false&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;property name=&quot;changeLog&quot; value=&quot;classpath*:liquibase/changelog.xml&quot;/&gt;    &lt;property name=&quot;contexts&quot; value=&quot;${database.liquibase.profile}&quot;/&gt;&lt;/bean&gt;</code></pre><p>需要注意几点：</p><ol><li>数据库的变更最好在应用启动时进行，所以需要给入口 bean 配置上 <code>lazy-init=&quot;false&quot;</code></li><li>Spring 提供的 <a href="http://propersoft-cn.github.io/pep-refs/projects/spring-framework/4.3.0/index.html#beans-definition-profiles" target="_blank" rel="noopener">profiles</a> 机制可以对应到 Liquibase 的 <a href="http://www.liquibase.org/documentation/contexts.html" target="_blank" rel="noopener">Contexts</a> 上，以便在不同的 profile 执行不同的数据库操作</li><li>大型项目一般都会分模块，模块最终可能会以 jar 包方式被引用。入口 changelog.xml 可能也是存在于 jar 包中的。故 <code>changeLog</code> 属性的 <code>value</code> 配置为 <code>classpath*:liquibase/changelog.xml</code>。<strong>想法很不错，但这里会遇到一个问题：<code>CORE-3139</code></strong></li></ol><h4 id="CORE-3139"><a href="#CORE-3139" class="headerlink" title="CORE-3139"></a>CORE-3139</h4><p><a href="https://liquibase.jira.com/browse/CORE-3139" target="_blank" rel="noopener">CORE-3139</a> 是 Liquibase 无法从 JAR 包中读取资源文件的一个 bug。这个 bug 已有 <a href="https://github.com/liquibase/liquibase/pull/725" target="_blank" rel="noopener">PR #725</a> 进行了处理，CORE-3139 中也标记这个问题已在 Liquibase <code>v3.5.4</code> 版本中修复，但事实证明在 <a href="https://github.com/liquibase/liquibase/tree/liquibase-parent-3.6.1" target="_blank" rel="noopener">Liquibase v3.6.1</a> 版本中仍然存在，且之前修复这个问题的代码也基本都被覆盖掉了 orz。</p><p>这个问题只会影响到从 JAR 包中读取资源文件的情况（比如 changelog.xml 在 JAR 包中），资源直接存在于文件系统时并不受此问题影响。</p><p>为了避免这个问题再反复出现，新提交了一个 <a href="https://github.com/liquibase/liquibase/pull/767" target="_blank" rel="noopener">PR #767</a> 对问题进行了修正，并补充了单元测试。如需将 changelog 打入 JAR 包中，可使用合并了此 PR 的版本的 Liquibase。</p><h3 id="Change-Log-的组织"><a href="#Change-Log-的组织" class="headerlink" title="Change Log 的组织"></a>Change Log 的组织</h3><p>项目模块化后，Change Log 也需要分布到各个模块中，与官方 <a href="http://www.liquibase.org/bestpractices.html" target="_blank" rel="noopener">最佳实践</a> 给出的结构不同，项目中的结构可能更类似下面的情况：</p><pre><code>├── a│   └── src│       └── main│           └── resources│               └── liquibase│                   └── changelog.xml├── b│   └── src│       └── main│           └── resources│               └── liquibase│                   └── changelogs│                       ├── changelog-ddl-b.xml│                       └── changelog-dml-b.xml└── c    └── src        └── main            └── resources                └── liquibase                    └── changelogs                        └── changelog-dml-c.xml</code></pre><p>除 <code>a</code> 模块作为 changelog 入口模块外，<code>b</code>、<code>c</code> 模块可能都是被以 JAR 包方式选择性引入的，即 <code>a</code> 模块的 changelog.xml 不应该感知到 <code>b</code>、<code>c</code> 模块内的 <code>changelog-*.xml</code>；同时当引入 <code>b</code>、<code>c</code> 模块时又能将模块下的 <code>changelog-*.xml</code> 都正常加载到。</p><p>实现这个需求需借助 Liquibase 提供的 <a href="http://www.liquibase.org/documentation/includeall.html" target="_blank" rel="noopener">includeAll</a>，同时要注意下其中的 <code>Warnings</code>：</p><blockquote><p>If you do choose to use the includeAll tag, make sure you have a naming strategy in place that will insure that you will never have conflicts or need to rename files to change to force a reordering.</p></blockquote><p>可参考如下方式组织 changelogs：</p><ul><li>入口 changelog 为 <code>liquibase/changelog.xml</code></li><li>为避免入口 changelog include 到自己，各模块的 changelog 存放路径要与入口 changelog 路径有区别，如放在 <code>liquibase/changelogs/</code> 路径下</li><li>将 DDL 和 DML 分开放置，且按 <code>changelog-[ddl/dml]-{module}.xml</code> 方式命名，因为 Liquibase 是将所有 changelog 文件按字典序方式执行，这样可以保证 DDL 会优先 DML 执行，且不会因路径相同导致 changelog 文件被覆盖</li></ul><blockquote><p>注：即使在不同 JAR 包下，相对路径相同的 changelog 文件也会被覆盖</p></blockquote><blockquote><p>如需从 JAR 包中读取 changelog，你可能需要 <a href="https://github.com/liquibase/liquibase/pull/767" target="_blank" rel="noopener">PR #767</a>。</p></blockquote><h4 id="入口-Change-Log"><a href="#入口-Change-Log" class="headerlink" title="入口 Change Log"></a>入口 Change Log</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;databaseChangeLog    xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog         http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.6.xsd&quot;&gt;    &lt;includeAll path=&quot;classpath*:liquibase/changelogs/&quot; context=&quot;dev, production&quot;/&gt;&lt;/databaseChangeLog&gt;</code></pre><h4 id="Change-Log-Template"><a href="#Change-Log-Template" class="headerlink" title="Change Log Template"></a>Change Log Template</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;databaseChangeLog xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;                   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;                   xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog                                       http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.6.xsd&quot;&gt;    &lt;changeSet author=&quot;alphahinex&quot; id=&quot;20180515-1&quot;&gt;      ...    &lt;/changeSet&gt;&lt;/databaseChangeLog&gt;</code></pre><h3 id="利用-Gradle-执行-Liquibase-命令"><a href="#利用-Gradle-执行-Liquibase-命令" class="headerlink" title="利用 Gradle 执行 Liquibase 命令"></a>利用 Gradle 执行 Liquibase 命令</h3><p>如果不是从项目起始时就使用了 Liquibase，或者不想手写 Change Set，可以通过 Liquibase 提供的 <a href="http://www.liquibase.org/documentation/command_line.html" target="_blank" rel="noopener">命令</a> 来生成 Change Log 或 DDL 的变更（数据的变更暂不支持生成）。如果是使用 Gradle 的项目，可以利用 <a href="https://github.com/liquibase/liquibase-gradle-plugin/tree/acf7a693563471f83fd26b9e15365ab98011d804" target="_blank" rel="noopener">Liquibase 的 Gradle 插件</a> 来执行命令，更加便捷。</p><blockquote><p>Liquibase 项目本身的活跃度目前并不高，插件的活跃度及文档的准确性更是问题重重，这也是本文存在的意义之一。</p></blockquote><h4 id="Gradle-配置"><a href="#Gradle-配置" class="headerlink" title="Gradle 配置"></a>Gradle 配置</h4><p>以 <a href="http://h2database.com/html/main.html" target="_blank" rel="noopener">H2 数据库</a> 为例，为执行 Liquibase 引入数据库驱动：</p><pre><code class="gradle">buildscript {    dependencies {        classpath &#39;com.h2database:h2:1.3.176&#39;    }}</code></pre><p>引入插件：</p><pre><code class="gradle">plugins {    id &#39;org.liquibase.gradle&#39; version &#39;1.2.4&#39;}</code></pre><p>定义 activities 用以生成不同的 Change Log：</p><pre><code class="gradle">ext {    // 数据库地址    liquibaseUrl = &#39;jdbc:h2:~/data/h2/pep_dev;AUTO_SERVER=TRUE;DB_CLOSE_ON_EXIT=FALSE;MVCC=TRUE&#39;    // 旧版数据库地址，比较差异用    liquibaseOldUrl = &#39;jdbc:h2:~/data/h2-diff/pep_dev;AUTO_SERVER=TRUE;DB_CLOSE_ON_EXIT=FALSE;MVCC=TRUE&#39;    liquibaseUsername = &#39;sa&#39;    liquibasePassword = &#39;&#39;}liquibase {    activities {        // 生成全库结构 Change Log        genDev {            changeLogFile &#39;db/dev.xml&#39;            url           liquibaseUrl            username      liquibaseUsername            password      liquibasePassword        }        // 生成全库数据 Change Log        genDevData {            changeLogFile     &#39;db/dev-data.xml&#39;            url               liquibaseUrl            username          liquibaseUsername            password          liquibasePassword            diffTypes         &#39;data&#39;        }        // 对比生成数据库结构变更 Change Log        diffDev {            changeLogFile     &#39;db/dev-diff.xml&#39;            url               liquibaseOldUrl            username          liquibaseUsername            password          liquibasePassword            referenceUrl      liquibaseUrl            referenceUsername liquibaseUsername            referencePassword liquibasePassword        }    }    // 若不设定 runList，所有 activities 都会被执行    // -PrunList=abc 并不好用，所以要执行指定的 activities 时，可直接修改此处值    // 多个值可用逗号间隔，如 &#39;genDev,genDevData&#39;    runList = &#39;genDevData&#39;}</code></pre><h3 id="生成-Change-Log"><a href="#生成-Change-Log" class="headerlink" title="生成 Change Log"></a>生成 Change Log</h3><h4 id="全库-Change-Log，包括结构和数据"><a href="#全库-Change-Log，包括结构和数据" class="headerlink" title="全库 Change Log，包括结构和数据"></a>全库 Change Log，包括结构和数据</h4><ol><li><code>runList</code> 设定为 <code>genDev,genDevData</code></li><li><code>./gradlew generateChangelog</code></li><li>在 <code>./db/dev.xml</code> 可找到全库结构的 Change Log</li><li>在 <code>./db/dev-data.xml</code> 可找到全库数据的 Change Log。</li></ol><blockquote><p>注意：执行命令前需保证这两个文件不存在，否则会报错。</p></blockquote><blockquote><p>生成的 Change Log 中的内容最好进行检查和一定的调整，以免自动生成的名称没有直观的含义，或产生冲突等问题。</p></blockquote><h4 id="结构变更-Change-Log"><a href="#结构变更-Change-Log" class="headerlink" title="结构变更 Change Log"></a>结构变更 Change Log</h4><ol><li>欲进行数据库结构变更时，先将变更前的库备份，例如从 <code>~/data/h2/pep_dev</code> 备份至 <code>~/data/h2-diff/pep_dev</code></li><li><code>runList</code> 设定为 <code>diffDev</code></li><li><code>./gradlew diffChangeLog</code></li><li>结构变更 Change Log 将生成至 <code>./db/dev-diff.xml</code>。</li></ol><h4 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h4><ol><li>在数据库中执行 insert 语句</li><li>修改 build.gradle 中配置的 liquibase.runList，将其值改为 <code>genDevData</code></li><li><code>./gradlew generateChangelog</code></li><li>从 <code>db/dev-data.xml</code> 中找到新增数据的 changeSet，并放至相应模块的 change log 文件中</li></ol><h4 id="变更数据"><a href="#变更数据" class="headerlink" title="变更数据"></a>变更数据</h4><p>Liquibase <a href="http://forum.liquibase.org/topic/data-diff-diffchangelog" target="_blank" rel="noopener">目前并不支持数据变更的生成</a>，可参照官方文档手写 Change Set，语法基本类似 SQL，可参照：</p><ul><li><a href="http://www.liquibase.org/documentation/changes/update.html" target="_blank" rel="noopener">Update</a></li><li><a href="http://www.liquibase.org/documentation/changes/delete.html" target="_blank" rel="noopener">Delete</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/liquibase/liquibase" target="_blank" rel="noopener">Liquibase</a></li><li><a href="http://www.liquibase.org/documentation/index.html" target="_blank" rel="noopener">Liquibase Documentation</a></li><li><a href="https://github.com/liquibase/liquibase-gradle-plugin" target="_blank" rel="noopener">liquibase-gradle-plugin</a></li><li><a href="https://github.com/liquibase/liquibase-hibernate/wiki#why-not-use-hbm2ddl" target="_blank" rel="noopener">Why not use HBM2DDL?</a></li><li><a href="http://www.liquibase.org/documentation/generating_changelogs.html" target="_blank" rel="noopener">Generating Change Logs</a></li><li><a href="http://www.liquibase.org/documentation/existing_project.html" target="_blank" rel="noopener">Adding Liquibase on an Existing project</a></li><li><a href="https://github.com/liquibase/liquibase-hibernate" target="_blank" rel="noopener">liquibase-hibernate</a></li><li><a href="http://www.liquibase.org/documentation/diff.html" target="_blank" rel="noopener">Database “Diff”</a></li><li><a href="http://www.liquibase.org/documentation/spring.html" target="_blank" rel="noopener">Spring Integration</a></li><li><a href="http://www.liquibase.org/documentation/trimming_changelogs.html" target="_blank" rel="noopener">Trimming ChangeLog Files</a></li><li><a href="https://stackoverflow.com/questions/8397488/comparing-databases-and-generating-sql-script-using-liquibase" target="_blank" rel="noopener">comparing databases and generating sql script using liquibase</a></li><li><a href="http://www.liquibase.org/documentation/changes/index.html" target="_blank" rel="noopener">Bundled Liquibase Changes</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gradle </tag>
            
            <tag> Spring </tag>
            
            <tag> Liquibase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TeamCity for Java Project on GitHub</title>
      <link href="2016/06/15/TeamCity-for-Java-Project-on-GitHub/"/>
      <url>2016/06/15/TeamCity-for-Java-Project-on-GitHub/</url>
      
        <content type="html"><![CDATA[<p>GitHub 上 Java 项目使用 TeamCity 和 Codecov 的简易说明</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>利用 TeamCity 构建 GitHub 上的 Java 项目</li><li>构建时进行静态代码质量检查及单元测试，并生成测试覆盖率报告</li><li>确保每个 PR 和 master 分支的每次提交都能触发构建</li><li>将构建结果和覆盖率情况可视化展现</li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>使用 <a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a> 镜像搭建基础环境：</p><pre><code class="bash">$ docker pull propersoft/docker-teamcity:server$ docker pull propersoft/docker-teamcity:agent-java</code></pre><blockquote><p><code>docker-teamcity</code> 镜像基于 <code>OpenJDK 7</code> 构建</p></blockquote><blockquote><p><code>server</code> tag 为 TeamCity Server，包含 <a href="https://github.com/jonnyzzz/TeamCity.GitHub" target="_blank" rel="noopener">TeamCity.GitHub 插件</a>，用以通过 <a href="https://github.com/blog/1227-commit-status-api" target="_blank" rel="noopener">GitHub Change Status API</a> 将构建状态展示在 <code>Pull Request</code> 中</p></blockquote><blockquote><p><code>agent-java</code> tag 为 TeamCity Agent，包含 <code>gralde</code> 构建工具，用以构建 java 项目</p></blockquote><p>启动 TeamCity Server，并将 <code>context</code> 设置为 <code>tc</code>：</p><pre><code class="bash">$ docker run --name tc-server -v /home/ds/teamcity:/var/lib/teamcity -p 9090:8111 -e &#39;TEAMCITY_CONTEXT=tc&#39; -d propersoft/docker-teamcity:server</code></pre><p>启动 2 个 TeamCity Java Agent：</p><pre><code class="bash">$ docker run --name tc-aj1 -p 9091:9090 -e &#39;TEAMCITY_SERVER=http://SERVER_IP:9090/tc&#39; -e &#39;TEAMCITY_AGENT_PORT=9091&#39; -e &#39;TEAMCITY_AGENT_NAME=Java Agent 1&#39; -d propersoft/docker-teamcity:agent-java$ docker run --name tc-aj2 -p 9092:9090 -e &#39;TEAMCITY_SERVER=http://SERVER_IP:9090/tc&#39; -e &#39;TEAMCITY_AGENT_PORT=9092&#39; -e &#39;TEAMCITY_AGENT_NAME=Java Agent 2&#39; -d propersoft/docker-teamcity:agent-java</code></pre><p>此时可登录 TeamCity Server，看到有两个 Agent，授权后即可使用。</p><h2 id="添加项目及构建"><a href="#添加项目及构建" class="headerlink" title="添加项目及构建"></a>添加项目及构建</h2><p>添加 GitHub Repo 至 <code>VCS Roots</code> 后，需配置 <code>Branch Specification</code>：<code>+:refs/pull/(*/merge)</code></p><p>在 gradle 的任务中通过 jacoco 插件生成覆盖率报告。为了在 <a href="https://codecov.io/" target="_blank" rel="noopener">codecov</a> 平台展现总体的覆盖率情况，需设置 jacoco 生成 xml 格式的报告</p><blockquote><p>若项目为私有仓库，需在项目根路径创建 <code>codecov.yml</code>，并在其中添加 <code>codecov</code> 平台提供的 <code>token</code></p></blockquote><p>在构建步骤中添加 <code>Command Line</code> 类型步骤，将 <code>curl -s https://codecov.io/bash | bash</code> 配置到 <code>custom script</code> 中，以将覆盖率报告上传至 <code>codecov</code></p><p>添加 <code>VCS Trigger</code>，使用默认配置即可</p><p>在 <code>Build Features</code> 中添加 <code>Report change status to GitHub</code> 的 Feature，并调整好相应配置</p><h2 id="构建结果和覆盖率情况可视化展现"><a href="#构建结果和覆盖率情况可视化展现" class="headerlink" title="构建结果和覆盖率情况可视化展现"></a>构建结果和覆盖率情况可视化展现</h2><p>启用 TeamCity 的 <code>guest</code> 账户，并赋予其查看构建结果的权限</p><p>通过 TeamCity 的 <a href="https://blog.jetbrains.com/teamcity/2012/07/teamcity-build-status-icon/" target="_blank" rel="noopener">status icon</a> 和 Codecov 提供的 <code>Badge</code> 将构建结果和覆盖率情况可视化展现</p><h2 id="将-TeamCity-部署至-nginx-后面"><a href="#将-TeamCity-部署至-nginx-后面" class="headerlink" title="将 TeamCity 部署至 nginx 后面"></a>将 TeamCity 部署至 nginx 后面</h2><pre><code class="nginx">map $http_upgrade $connection_upgrade {    default upgrade;    &#39;&#39;   &#39;&#39;;}server {    listen       400;    server_name  teamcity.public;    location /tc {        proxy_pass          http://teamcity.local:8111/tc;        proxy_http_version  1.1;        proxy_set_header    X-Forwarded-For $remote_addr;        proxy_set_header    Host $server_name:$server_port;        proxy_set_header    Upgrade $http_upgrade;        proxy_set_header    Connection $connection_upgrade;    }}</code></pre><pre><code class="nginx">http {    proxy_read_timeout     1200;    proxy_connect_timeout  240;    client_max_body_size   0;    ....}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.jetbrains.com/teamcity/2013/02/automatically-building-pull-requests-from-github-with-teamcity/" target="_blank" rel="noopener">Automatically Building Pull Requests from GitHub</a></li><li><a href="https://blog.jetbrains.com/teamcity/2012/07/teamcity-build-status-icon/" target="_blank" rel="noopener">TeamCity build status icon</a></li><li><a href="https://confluence.jetbrains.com/display/TCD9/REST+API#RESTAPI-BuildStatusIcon" target="_blank" rel="noopener">Build Status Icon</a></li><li><a href="https://confluence.jetbrains.com/pages/viewpage.action?pageId=74847395#HowTo...-Nginx" target="_blank" rel="noopener">Set Up TeamCity behind Nginx</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> TeamCity </tag>
            
            <tag> jacoco </tag>
            
            <tag> Codecov </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Resource Optimizer for Java (wro4j) Demo</title>
      <link href="2016/02/02/wro4j-demo/"/>
      <url>2016/02/02/wro4j-demo/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/wro4j/wro4j" target="_blank" rel="noopener">wro4j 代码仓库</a></p><p><a href="http://wro4j.readthedocs.org/en/stable/" target="_blank" rel="noopener">wro4j 文档</a></p><h2 id="运行时编译"><a href="#运行时编译" class="headerlink" title="运行时编译"></a>运行时编译</h2><p>在 web 项目中配置一个 <code>Filter</code>，页面上需要 css 或 js 资源时，将请求发送至 <code>Filter</code>，Filter 将按照 <code>wro.xml</code> 配置文件中配置的 <code>group</code> 将资源编译后返回。</p><h3 id="步骤-1：添加-WroFilter"><a href="#步骤-1：添加-WroFilter" class="headerlink" title="步骤 1：添加 WroFilter"></a>步骤 1：添加 <code>WroFilter</code></h3><pre><code class="xml">&lt;filter&gt;    &lt;filter-name&gt;WebResourceOptimizer&lt;/filter-name&gt;    &lt;filter-class&gt;ro.isdc.wro.http.WroFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;WebResourceOptimizer&lt;/filter-name&gt;    &lt;url-pattern&gt;/wro/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><h3 id="步骤-2：web-xml-同路径创建-wro-xml"><a href="#步骤-2：web-xml-同路径创建-wro-xml" class="headerlink" title="步骤 2：web.xml 同路径创建 wro.xml"></a>步骤 2：<code>web.xml</code> 同路径创建 <code>wro.xml</code></h3><pre><code class="xml">&lt;groups xmlns=&quot;http://www.isdc.ro/wro&quot;&gt;    &lt;group name=&quot;all&quot;&gt;        &lt;css&gt;/asset/*.css&lt;/css&gt;        &lt;js&gt;/asset/*.js&lt;/js&gt;    &lt;/group&gt;&lt;/groups&gt;</code></pre><h3 id="步骤-3：页面引用"><a href="#步骤-3：页面引用" class="headerlink" title="步骤 3：页面引用"></a>步骤 3：页面引用</h3><pre><code class="html">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Web Page using wro4j&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/wro/all.css&quot; /&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;/wro/all.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>示例项目：<a href="/contents/wro4j/wro4j-demo.war">wro4j-demo.war</a> &amp; <a href="https://github.com/AlphaHinex/seed-gradle-java/tree/wro4j" target="_blank" rel="noopener">源码</a></p></blockquote><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>预编译可以将资源文件事先编译好，页面直接引用即可，无需在 <code>web.xml</code> 中配置 <code>Filter</code>。预编译有两种方式，一种是命令行方式，一种是插件方式。</p><h3 id="command-line"><a href="#command-line" class="headerlink" title="command-line"></a>command-line</h3><p><a href="https://github.com/wro4j/wro4j-runner" target="_blank" rel="noopener">wro4j-runner 代码仓库</a></p><p><a href="http://wro4j.readthedocs.org/en/stable/wro4jRunner/" target="_blank" rel="noopener">wro4j-runner 文档</a></p><p>根据源码编译的 <a href="/contents/wro4j/wro4j-runner-1.7.6.jar">wro4j-runner-1.7.6.jar</a></p><h4 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h4><p>假设 jar 包放在 web 应用根路径 <code>src/main/webapp</code>，<code>wro.xml</code> 在 <code>src/main/webapp/WEB-INF/wro.xml</code></p><pre><code class="bash"># 仅合并文件$ java -jar wro4j-runner-1.7.6.jar --wroFile ./WEB-INF/wro.xml -i# 合并并压缩$ java -jar wro4j-runner-1.7.6.jar --wroFile ./WEB-INF/wro.xml -i -m -c cssMin</code></pre><p>编译后文件生成至 <code>src/main/webapp/wro/</code>。详细用法参见 <a href="http://wro4j.readthedocs.org/en/stable/wro4jRunner/" target="_blank" rel="noopener">文档</a>。</p><h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><p><a href="http://wro4j.readthedocs.org/en/docs/MavenPlugin/" target="_blank" rel="noopener">Maven plugin</a> 及使用 Maven plugin 的 <a href="https://github.com/jbosstools/m2e-wro4j" target="_blank" rel="noopener">Eclipse plugin</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wro4j </tag>
            
            <tag> wro4j-runner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Clear Key 加密 MP4 视频并播放</title>
      <link href="2015/12/31/how-to-encrypt-mp4-using-clearkey-and-play/"/>
      <url>2015/12/31/how-to-encrypt-mp4-using-clearkey-and-play/</url>
      
        <content type="html"><![CDATA[<p>使用 HTML5 技术播放视频简单方便，但同时也将视频源直接暴露了出去。针对一些需要保护以避免用户随意下载的视频，有没有鱼和熊掌兼得之策呢？</p><p>在现代浏览器中，使用 HTML5 技术在线播放视频已不是难事，只需浏览器支持和视频格式兼容即可（参见 <a href="https://alphahinex.github.io/2015/12/11/play-video-with-html5/">使用 HTML5 技术播放视频</a>）。<code>&lt;video&gt;</code> 标签带给我们便利的同时，也将视频源地址直接暴露了出去。虽然 <code>开放</code> 是互联网精神之一，但总会有些内容需要限制传播或独家提供。在 HTML5 视频播放技术中，有没有一些可用的版权保护策略呢？</p><p>既然 YouTube 已经将默认的播放器切换成了 HTML5，那么答案一定是<strong>肯定的</strong>。让我们从 YouTube 的这篇 <a href="http://youtube-eng.blogspot.jp/2015/01/youtube-now-defaults-to-html5_27.html" target="_blank" rel="noopener">博文</a> 中来找找线索。</p><p>YouTube 在其中提到了这一重大进步中的一些关键技术：</p><ul><li><p><a href="https://w3c.github.io/media-source/" target="_blank" rel="noopener"><code>Media Source Extensions</code></a>：可变比特流（Adaptive Bitrate(ABR) streaming）在为用户提供高质量的视频体验中非常重要，它允许我们在面对多变的网络环境时快速且无缝的调整视频分辨率和比特率。<code>ABR</code> 能够在总体上减少超过 50% 的缓冲，在某些极度拥挤的网络环境下甚至能达到 80%。Media Source Extensions 不仅可以在浏览器中使用，还可以在如 XBox 和 PS4 等游戏主机的直播中使用。</p></li><li><p><a href="https://w3c.github.io/encrypted-media/" target="_blank" rel="noopener"><code>Encrypted Media Extensions</code></a> 和 <code>Common Encryption</code>：过去，视频分发平台（Flash、Silverlight 等）和版权保护技术（Access，PlayReady）是紧密连接的，内容保护深入集成在分发平台甚至文件格式中。Encrypted Media Extensions 将内容保护技术与分发平台分离，使得如 YouTube 的内容提供商可以使用同一个 HTML5 视频播放器覆盖大量不同平台。与 Common Encryption 技术联合使用可以针对不同平台提供不同的版权保护技术，这使得 YouTube 的视频播放更加平稳快速。</p></li></ul><h2 id="Encrypted-Media-Extensions-EME"><a href="#Encrypted-Media-Extensions-EME" class="headerlink" title="Encrypted Media Extensions(EME)"></a>Encrypted Media Extensions(EME)</h2><p><a href="http://www.html5rocks.com/en/tutorials/eme/basics" target="_blank" rel="noopener">EME WTF?</a> 简单来说，EME 提供了一套 API 以允许 web 应用能够与内容保护系统进行交互，并使播放加密过的视频和音频成为可能。从 <code>Extensions</code> 可以看出，EME 是 <code>HTMLMediaElement</code> 标准的扩展，这意味着<strong>浏览器对其的支持不是必须的</strong>。从 <code>jwplayer</code> 的网站上我们能够找到<a href="http://www.jwplayer.com/html5/mediasource/" target="_blank" rel="noopener">一些浏览器对 <code>MSE</code> 和 <code>EME</code> 的支持情况</a>：</p><p><img src="/contents/html5-video/jwplayer-test.png" alt="JW Player MSE and EME test"></p><p>不过实际测试中发现这份数据<strong>并不完全准确</strong>，例如在 <code>win7</code> 下的 <code>Chrome41</code> 就无法播放使用 <code>Clear Key</code> 加密的 <code>MP4</code> 视频。</p><p>EME 实现需要使用下列外部组件：</p><ul><li><strong>Key System</strong>：一种内容保护（DRM）机制。常见的 Key System 有 Clear Key、Playready、Widevine 等。EME 并没有定义 Key System 本身，除了 <code>Clear Key</code>。</li><li><strong>Content Decryption Module</strong>：用来播放加密媒体资源的客户端软件或硬件机制。同 <code>Key System</code> 一样，EME 也没有定义任何内容解密模块（CDM），但为应用提供了一个接口用来与可用的 CDM 模块交互。</li><li><strong>License（Key） server</strong>：与 CDM 模块交互并提供解密媒体资源所需的 <code>key</code>。与 <code>license server</code> 通信是由应用本身负责的。</li><li><strong>Packaging service</strong>：编码并加密媒体资源以供发布和播放使用。</li></ul><h2 id="Common-Encryption"><a href="#Common-Encryption" class="headerlink" title="Common Encryption"></a>Common Encryption</h2><p><code>Common Encryption</code> 允许内容提供商按 <code>容器/编码</code> 加密并打包内容一次，而后在各种支持的 Key System、CDM 和 客户端中使用。例如一个使用 <code>Playready</code> 加密的视频可以在使用 <code>Widevine</code> 内容解密模块从 <code>Widevine license server</code> 获得解密 <code>key</code> 的浏览器中播放。</p><h2 id="Clear-Key"><a href="#Clear-Key" class="headerlink" title="Clear Key"></a>Clear Key</h2><p>虽然 EME 没有定义 DRM 功能，但规范中要求所有支持 EME 的浏览器<strong>必须实现</strong> <code>Clear Key</code>。使用这套系统，媒体资源可以使用一个 <code>key</code> 来加密，在播放时只需简单的提供这个 <code>key</code> 即可。Clear Key 可以构建至浏览器中：它甚至不需要一个单独的解密模块。</p><p>尽管不容易被用于许多类型的商业内容，Clear Key 可以与所有支持 EME 的浏览器完全兼容。它也可以用来测试 EME 的实现和应用，甚至可以直接提供 key 以免去授权服务器。在 <a href="http://simpl.info/eme/clearkey" target="_blank" rel="noopener">simpl.info/ck</a> 有一个简单的演示。演示中的视频使用的是加密过的 <code>WebM</code> 格式。</p><p>要加密 WebM 视频并非易事，目前的一个可用方案是使用 <code>webm-crypt</code> 模块。按照 <a href="https://docs.google.com/document/d/17d6_KX5jX0gY1ygYbjqOEdVzuUGkPO53wL8t40dMGeQ/edit?usp=sharing" target="_blank" rel="noopener">How to build and use webm_crypt</a> 中的步骤来看，为了使用这个模块你需要编译整个 <code>chrome</code>，<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 上的编译好的 chrome 镜像体积有 <strong>20G+</strong> 的规模。</p><p>相比之下，<a href="http://www.cablelabs.com/" target="_blank" rel="noopener">Cable Labs</a> 提供的针对 <code>MP4</code> 的解决方案则简便许多。</p><h2 id="用-Clear-Key-加密-MP4-并在浏览器中播放"><a href="#用-Clear-Key-加密-MP4-并在浏览器中播放" class="headerlink" title="用 Clear Key 加密 MP4 并在浏览器中播放"></a>用 Clear Key 加密 MP4 并在浏览器中播放</h2><p>终于到了今天的重头戏，先来看下 <a href="https://html5.cablelabs.com/mse-eme/doc/overview.html" target="_blank" rel="noopener">Cable Labs MSE-EME Overview</a> 中的方案总览：</p><p><img src="https://html5.cablelabs.com/mse-eme/doc/images/EMETools.png" alt="EME Tools Overview"></p><p>总体方案分为两部分：<a href="https://html5.cablelabs.com/mse-eme/doc/creation.html" target="_blank" rel="noopener">加密内容的创建</a>和<a href="https://html5.cablelabs.com/mse-eme/doc/playback.html" target="_blank" rel="noopener">内容播放</a>。</p><ul><li>加密内容的创建：包括对原始视频的转码以获得 <code>MP4(H.264/AAC)</code> 格式视频；视频内容加密；DASH 分割及打包。</li><li>内容播放：在浏览器中播放加密并 DASH 视频。</li></ul><h3 id="Dynamic-Adaptive-Streaming-over-HTTP-DASH"><a href="#Dynamic-Adaptive-Streaming-over-HTTP-DASH" class="headerlink" title="Dynamic Adaptive Streaming over HTTP (DASH)"></a>Dynamic Adaptive Streaming over HTTP (DASH)</h3><p><code>DASH</code>（即 <code>MPEG-DASH</code>）设计用来最大限度的满足在实际环境中的媒体内容流播放及下载需求。很多其他技术也在做着类似的事情 —— 例如苹果的 <a href="https://en.wikipedia.org/wiki/HTTP_Live_Streaming" target="_blank" rel="noopener">HTTP Live Streaming(HLS)</a> 和微软的 <a href="https://en.wikipedia.org/wiki/Adaptive_bitrate_streaming#Microsoft_Smooth_Streaming" target="_blank" rel="noopener">Smooth Streaming</a> —— 但 DASH 是唯一的一个基于开放标准的使用 HTTP 提供可变比特率流技术。DASH 已经应用在 YouTube 等网站上。</p><p>这与 EME 和 MSE 有什么关系？基于 MSE 的 DASH 实现能够解析清单（<code>mpd</code> 文件），下载恰当比特率的视频片段，并将其提供给 <code>&lt;video&gt;</code> 元素，这些都是在现有的 HTTP 之上完成的。换句话说，DASH 使商用内容提供商能够提供可变比特率的受保护内容。</p><h3 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h3><ul><li><a href="https://github.com/FFmpeg/FFmpeg" target="_blank" rel="noopener">ffmpeg</a>：视频转码，将源视频格式转换为 MP4(H.264/AAC)。</li><li><a href="https://github.com/cablelabs/mse-eme" target="_blank" rel="noopener">mse-eme</a>：Cable Labs 提供的相关工具集合，使用其中的 Clear Key 加密文件生成器来生成加密用文件。</li><li><a href="https://github.com/gpac/gpac" target="_blank" rel="noopener">MP4Box</a>：GPAC 项目中的 MP4Box 工具可用来对 MP4 视频进行加密及 DASH。</li><li><a href="https://github.com/Dash-Industry-Forum/dash.js" target="_blank" rel="noopener">dash.js</a>：用来在浏览器中播放 DASH 视频。</li></ul><p>上述工具除 <code>dash.js</code> 外，基本都需要安装，可以自行按照官网的说明来安装，也可以直接使用我组装好的这个 <a href="https://hub.docker.com/r/alphahinex/try-docker/" target="_blank" rel="noopener">docker 镜像</a>，使用方式为：</p><pre><code class="bash"># 拉取镜像$ docker pull alphahinex/try-docker:vc# 交互模式运行镜像，并将容器命名为 vc$ docker run --name vc -v /local/folder:/docker/folder -t -i alphahinex/try-docker:vc /bin/bash# 查看 ffmpeg 信息root@57ec3690605c:/usr/local# ffmpeg -version# 查看 MP4Box 信息root@57ec3690605c:/usr/local# MP4Box -version# 查看 clearkey 加密文件生成工具信息root@57ec3690605c:/usr/local# java -jar mse-eme/create/encrypt/clearkey/cryptgen/clearkey.jar -help# 退出容器root@57ec3690605c:/usr/local# exit</code></pre><p>各个工具的具体参数请参考其帮助手册。好，让我们找个视频来试一下。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>引用 <a href="http://www.html5rocks.com" target="_blank" rel="noopener">html5rocks</a> 上的这个 <a href="http://www.html5rocks.com/en/tutorials/video/basics/devstories.webm" target="_blank" rel="noopener">WebM 视频</a> 作为源视频，将其转换为 <code>MP4</code> 并使用 <code>Clear Key</code> 加密，之后使用 HTML5 播放。</p><pre><code class="bash"># 交互模式启动之前创建的容器 vc$ docker start -i vc# 假定源文件在容器中的路径为 /usr/local/video/devstories.webmroot@57ec3690605c:/usr/local/video# ffmpeg -i devstories.webm -codec:v libx264 -x264opts keyint=48:min-keyint=48:no-scenecut -codec:a aac -strict -2 devstories.mp4# 可通过 ffprobe 或 MP4Box 查看转换后的视频信息root@57ec3690605c:/usr/local/video# ffprobe -i devstories.mp4root@57ec3690605c:/usr/local/video# MP4Box -info devstories.mp4# 生成加密文件，key id 和 key 随便写，都是 16 位的 16 进制数，需要记住其转换成的 Base64 字符串root@57ec3690605c:/usr/local/video# java -jar /usr/local/mse-eme/create/encrypt/clearkey/cryptgen/clearkey.jar 1:20212223-2425-2627-2829-2A2B2C2D2E2F=15161718191A1B1C1D1E1F2021222324 2:12131415-1617-1819-1A1B-1C1D1E1F2021=25262728292A2B2C2D2E2F3031323334 -out devstories_drm.xmlEnsure the following keys are available to the client:    202122232425262728292a2b2c2d2e2f : 15161718191a1b1c1d1e1f2021222324 (ICEiIyQlJicoKSorLC0uLw : FRYXGBkaGxwdHh8gISIjJA)    12131415161718191a1b1c1d1e1f2021 : 25262728292a2b2c2d2e2f3031323334 (EhMUFRYXGBkaGxwdHh8gIQ : JSYnKCkqKywtLi8wMTIzNA)# 使用上一步生成的 devstories_drm.xml 加密 MP4root@57ec3690605c:/usr/local/video# MP4Box -crypt devstories_drm.xml devstories.mp4 -out devstories_enc.mp4# 可再次通过 MP4Box -info devstories_enc.mp4 看到两个轨道都已被加密# dashroot@57ec3690605c:/usr/local/video# MP4Box -dash 10000 -profile onDemand -out devstories_enc.mpd devstories_enc.mp4#video devstories_enc.mp4#audio</code></pre><p>完成上述步骤后，会得到如下三个文件，从 <code>mpd</code> 中可以看到视频清单和加密使用的 <code>key id</code>。</p><blockquote><p>devstories_enc.mpd<br/>devstories_enc_track1_dashinit.mp4<br/>devstories_enc_track2_dashinit.mp4</p></blockquote><p>将上述文件部署至服务器，并在页面中增加如下代码：</p><pre><code class="html">&lt;head&gt;  &lt;script src=&quot;dash.all-1.5.1.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;  function init() {    var video, context, player;    video = document.querySelector(&#39;video&#39;);    context = new Dash.di.DashContext()    player = new MediaPlayer(context);    player.startup();    player.attachView(video);    player.setAutoPlay(true);    player.attachSource(&#39;devstories_enc.mpd&#39;, null, {      &#39;org.w3.clearkey&#39;: {        // 例子中是将解密视频所需的 key id 和 key 都硬编码在 js 中        &#39;clearkeys&#39;: {          &#39;ICEiIyQlJicoKSorLC0uLw&#39;: &#39;FRYXGBkaGxwdHh8gISIjJA&#39;,          &#39;EhMUFRYXGBkaGxwdHh8gIQ&#39;: &#39;JSYnKCkqKywtLi8wMTIzNA&#39;        }        // 还可以使用授权服务器在播放视频时根据 key id 请求解密所需 key        // &#39;serverURL&#39;: &#39;http://license-server-host:port&#39;      }    });  }  &lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;init()&quot;&gt;  &lt;video width=&quot;640&quot; height=&quot;360&quot; controls=&quot;true&quot;&gt;&lt;/video&gt;&lt;/body&gt;</code></pre><h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><p>实际例子与上述代码片段略有不同。由于无法在 <code>onload</code> 中触发 <code>init</code> 函数，需点击下面 <code>初始化并播放</code> 按钮初始化视频后方可播放。</p><p>为了显示效果，为视频增加了一个封面图片。</p><blockquote><p>目前 <code>dash.js</code> 版本已更新至 <code>1.6.0</code>，但实际测试时发现播放加密视频时会有解码错误或无法完整播放的情况，还有在视频播放完后无法重新播放等问题，故例子中使用 <code>1.5.1</code> 版本。</p></blockquote><blockquote><p>据不完全测试，该段视频只能在 Chrome45+ 中播放。</p></blockquote><script src="https://alphahinex.github.io/contents/html5-video/dash.all-1.5.1.js"></script><script>function init() {  var video, context, player;  video = document.querySelector('video');  context = new Dash.di.DashContext();  player = new MediaPlayer(context);  player.startup();  player.attachView(video);  player.setAutoPlay(true);  player.attachSource('/archives/html5-video/devstories_enc.mpd', null, {    'org.w3.clearkey': {      'clearkeys': {        'ICEiIyQlJicoKSorLC0uLw': 'FRYXGBkaGxwdHh8gISIjJA',        'EhMUFRYXGBkaGxwdHh8gIQ': 'JSYnKCkqKywtLi8wMTIzNA'      }    }  });}</script><div>  <button onclick="init()">初始化并播放</button>  <video width="640" height="360" controls="true" poster="/contents/html5-video/poster.png"></video></div><h2 id="Clear-Key-License-Server"><a href="#Clear-Key-License-Server" class="headerlink" title="Clear Key License Server"></a>Clear Key License Server</h2><p>如上所述，除了直接将解密所需 key 硬编码进 js 之外，还可从授权服务器中根据 <code>key id</code> 获取 key。下面的 <code>server.js</code> 是一个简单的 <code>node.js</code> server，能够根据请求中发送过来的 key id 响应所需的 key。用法为：</p><pre><code class="bash">$ node server.js</code></pre><p>之后将上面代码片段中 <code>serverURL</code> 属性替换为服务发布的 ip 和端口并解注，注释掉 <code>clearkeys</code> 属性即可。</p><pre><code class="javascript">var http = require(&#39;http&#39;);var url = require(&#39;url&#39;);console.log(&#39;&#39;);console.log(&#39;Clear Key License Server Demo&#39;);console.log(&#39;&#39;);keys = {  &#39;ICEiIyQlJicoKSorLC0uLw&#39;: &#39;FRYXGBkaGxwdHh8gISIjJA&#39;,  &#39;EhMUFRYXGBkaGxwdHh8gIQ&#39;: &#39;JSYnKCkqKywtLi8wMTIzNA&#39;};var addCORSHeaders = function(res, length) {  res.writeHeader(200, {    &#39;Content-Length&#39;: length,    &#39;Content-Type&#39;: &#39;application/json&#39;,    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, PUT, POST, DELETE, OPTIONS&#39;,    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type, Authorization, Content-Length, X-Requested-Width&#39;});};var onReq = function(req, res) {  console.log(&#39;Request URL:&#39; + req.url);  var parsed_url = url.parse(req.url, true);  var query = parsed_url.query;  console.log(&#39;Received key request!  Query = %j&#39;, query);  // Validate query string  if (query === undefined) {    console.error(&#39;Illegal request!&#39;);    res.writeHeader(400, &#39;Illegal query string&#39;);    res.end();    return;  }  var keyIDs = [];  for (var p in query) {    keyIDs.push(p);  }  var keyarray = [];  for (var i = 0; i &lt; keyIDs.length; i++) {    var keyID = keyIDs[i];    if (!keys.hasOwnProperty(keyID)) {      console.warn(&#39;KeyID %s not registered in our lookup table!&#39;, keyID);      continue;    }    var keypair = {      kid: keyIDs[i],      k: keys[keyIDs[i]]    };    keyarray.push(keypair);  }  var response = {    keys: keyarray  };  console.log(&#39;Returning key array: %j&#39;, response);  var json_str_response = JSON.stringify(response);  addCORSHeaders(res, json_str_response.length);  res.write(json_str_response);  res.end();};http.createServer(onReq).listen(8584);</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://youtube-eng.blogspot.jp/2015/01/youtube-now-defaults-to-html5_27.html" target="_blank" rel="noopener">YouTube now defaults to HTML5</a></li><li><a href="https://w3c.github.io/media-source/" target="_blank" rel="noopener">Media Source Extensions</a></li><li><a href="https://w3c.github.io/encrypted-media/" target="_blank" rel="noopener">Encrypted Media Extensions</a></li><li><a href="http://www.html5rocks.com/en/tutorials/eme/basics" target="_blank" rel="noopener">EME WTF?</a></li><li><a href="https://gpac.wp.mines-telecom.fr/mp4box/encryption/common-encryption/" target="_blank" rel="noopener">Common Encryption</a></li><li><a href="https://html5.cablelabs.com/mse-eme/doc/creation.html" target="_blank" rel="noopener">Content Creation</a></li><li><a href="http://simpl.info/eme/clearkey/" target="_blank" rel="noopener">Clear Key demo</a></li><li><a href="https://html5.cablelabs.com/mse-eme/doc/playback.html" target="_blank" rel="noopener">Client Player Applications</a></li><li><a href="https://www.radiantmediaplayer.com/working-with-mp4box.html" target="_blank" rel="noopener">Working with MP4Box</a></li><li><a href="https://github.com/cablelabs/mse-eme" target="_blank" rel="noopener">mse-eme</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> Video </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 HTML5 技术播放视频</title>
      <link href="2015/12/11/play-video-with-html5/"/>
      <url>2015/12/11/play-video-with-html5/</url>
      
        <content type="html"><![CDATA[<p>HTML5 定义了通过 video 元素在网页中嵌入视频的标准方式。尽管这种方式仍在不断进化中，也暂时不能做到在任何浏览器下都运转良好，但现代浏览器对其支持的趋势及程度还是很值得期待的，即便在一些不支持的环境下，也有替代方案可供选择。本文主要基于 Dive Into HTML5 # Video on the Web，并对一些内容有更新和补充。</p><p>随着 <a href="https://html.spec.whatwg.org/multipage/" target="_blank" rel="noopener">HTML5 标准</a> 的定稿以及在线视频巨头 <code>YouTube</code> 在 <code>2015</code> 年初宣布<a href="http://youtube-eng.blogspot.jp/2015/01/youtube-now-defaults-to-html5_27.html" target="_blank" rel="noopener">默认使用 HTML5 视频播放器</a>，主流的在线视频播放技术正在逐步由 <code>flash</code> 播放器向 <code>HTML5</code> 播放器过渡。国内主流的在线视频网站，如优酷、土豆、爱奇艺、网易公开课等，依然在使用 <code>flash player</code>，而国内一些先进的视频直播网站，如 <a href="https://shou.tv/" target="_blank" rel="noopener">Shou.tv</a> 已试水 HTML5 技术。</p><p>HTML5 定义了通过 <code>&lt;video&gt;</code> 元素在网页中嵌入视频的标准方式。尽管这种方式仍在不断进化中，也暂时不能做到在任何浏览器下都运转良好，但现代浏览器对其支持的趋势及程度还是很值得期待的，即便在一些不支持的环境下，也有替代方案可供选择。</p><p>让我们先来看看当前各类浏览器对 video 元素的支持情况：</p><p><img src="/contents/html5-video/video-element.png" alt="video-element"><br><a href="http://caniuse.com/#feat=video" target="_blank" rel="noopener">数据来源</a></p><p>同是支持 <code>&lt;video&gt;</code> 元素，不同的浏览器所支持的视频格式还是有差异的。让我们先来了解一下常见的视频格式。</p><h2 id="视频容器"><a href="#视频容器" class="headerlink" title="视频容器"></a>视频容器</h2><p>我们常见的视频格式有 <code>avi</code> 或 <code>mp4</code> 等，这些所谓的视频格式，实际上指的只是视频容器的格式。就像 <code>zip</code> 格式的压缩包里面可以放置任意类型的文件一样，视频容器格式可以简单理解为只定义了如何将视频及音频流数据存储在容器文件中。实际情况会比这更复杂一些，因为不是所有的视频流都可以兼容存入任意视频容器中。</p><p>一个视频文件通常包含多个轨道（track）—— 一个视频轨道（不包含声音），叠加一个或多个音频轨道（没有图像）。轨道之间通常是相互关联的。一个音频轨道中会包含一些标记，用来同步声音和图像。每个轨道可以有自己的元数据信息，如视频轨道的画面比例或音频轨道的语言。视频容器同样可以有元数据，如视频的标题、封面等等。</p><p>视频容器的格式有很多，常见的包括：</p><ul><li><a href="http://en.wikipedia.org/wiki/MPEG-4_Part_14" target="_blank" rel="noopener">MPEG 4</a>，通常是扩展名为 <code>.mp4</code> 或 <code>.m4v</code> 的文件。<code>MPEG 4</code> 容器是基于苹果之前的 <code>QuickTime</code> 容器格式（<code>.mov</code>）而来的。</li><li><a href="http://en.wikipedia.org/wiki/Ogg" target="_blank" rel="noopener">Ogg</a>，扩展名通常为 <code>.ogg</code> 或 <code>.ogv</code>。 Ogg 是一个开放的标准，开源友好，不受任何已知的专利限制。Firefox 3.5+，Chrome 4+ 以及 Opera 10.5+ 无需插件原生支持。Ogg 容器格式，包含 Ogg 视频（名为 <code>Theora</code>）和 Ogg 音频（名为 <code>Vorbis</code>）。Ogg 格式是大多数 Linux 发行版的开箱即用视频格式，并可以通过著名的 <a href="http://www.videolan.org/vlc/" target="_blank" rel="noopener">VLC</a> 播放器在各个平台上进行播放。</li><li><a href="http://www.webmproject.org/" target="_blank" rel="noopener">WebM</a>，扩展名 <code>.webm</code>。WebM 是一种无版税，开源友好的，专为 HTML5 设计的视频压缩格式，使用 <code>VP8</code> 视频编码和 <code>Vorbis</code> 音频编码。在技术上类似 <a href="https://en.wikipedia.org/wiki/Matroska" target="_blank" rel="noopener">Matroska</a> 格式（<code>.mkv</code>）。同样无需插件，在当前版本的 Chromium，Chrome，Firefox 和 Opera 上原生支持。</li><li><a href="http://en.wikipedia.org/wiki/Flash_Video" target="_blank" rel="noopener">Flash Video</a> (<code>.flv</code>) 是 Adobe Flash Player 所使用的格式。在近期的 Flash Player 版本中也加入了对 MPEG 4 容器的支持。</li><li><a href="http://en.wikipedia.org/wiki/Advanced_Systems_Format" target="_blank" rel="noopener">ASF</a> (<code>.asf</code>) 和 <a href="http://en.wikipedia.org/wiki/AVI" target="_blank" rel="noopener">Audio Video Interleave</a> (<code>.avi</code>) 是微软发明的格式，早期使用较多。</li></ul><h2 id="视频编解码器"><a href="#视频编解码器" class="headerlink" title="视频编解码器"></a>视频编解码器</h2><p>当我们观看视频时，视频播放器至少同时做了三件事：</p><ol><li>解析视频容器格式，找到可用的视频及音频轨道，以及他们是如何存放在容器内的，以便获得解码所需数据</li><li>解码视频流，在屏幕上显示一系列的图像</li><li>解码音频流，在扬声器中播放声音</li></ol><p>编解码器是指对视频进行编码和解码的算法。视频按照编码算法被转换成二进制流文件进行存储和分发，视频播放器按照解码算法对视频流进行解码，并将一系列图像或帧显示在屏幕上。大多数现代视频编解码器都竭尽其能地减少播放下一帧所需的信息。例如，为了避免保存每一帧图像（类似截屏），编码时将只会存储每帧之间的差异内容。多数视频也不是每一帧都与上一帧完全不同，这便使得更高的压缩率和更小的文件尺寸成为可能。</p><p>编解码器分为有损和无损两种类型。无损类型的视频尺寸对于互联网来说还是太大了，所以我们这里只关注有损类型的视频编码。有损类型的视频编解码器，意味着对视频编码总会伴随着不可挽回的原始数据丢失。就像翻录卡带一样，每次视频编码都会造成源视频信息的丢失以及视频质量的下降。多次编码后视频可能会有明显的卡顿，尤其是动作很多的视频（如动作片）。然而好的方面是，有损的视频编码格式能够提供惊人的压缩比例，并通过一些播放时的优化技术，使肉眼很难察觉到这些信息的损失。</p><p>常见的视频编解码器有 <code>H.264</code>、<code>Theora</code> 和 <code>VP8</code>。</p><h3 id="H-264"><a href="#H-264" class="headerlink" title="H.264"></a>H.264</h3><p><a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC" target="_blank" rel="noopener">H.264</a>，即 MEPG-4 part 10、MPEG-4 AVC、MPEG-4 Advanced Video Coding。 H.264 是 <a href="http://en.wikipedia.org/wiki/Moving_Picture_Experts_Group" target="_blank" rel="noopener">MPEG 组织</a> 开发并于 2003 年标准化的编码格式。它致力于为低带宽、低性能 CPU 设备（如手机），高带宽和高性能 CPU 设备（如现代桌面电脑），以及所有在此范围之间的设备，提供单独的一种编解码器。为了实现这个目标， H.264 标准定义了多种 <a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC#Profiles" target="_blank" rel="noopener">profiles</a> 和 <a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC#Levels" target="_blank" rel="noopener">levels</a>。配置（<code>profile</code>）定义了编码时所采取的约束，使解码器了解解码视频的要求；等级（<code>level</code>）与配置共同指定了视频的最大解析度、帧速及码率等。更高的配置提供更好的视频质量，更长的编码时间以及在实时播放时需要更强劲的 CPU 来解码。</p><p>概括来说，<a href="http://www.apple.com/cn/iphone/compare/" target="_blank" rel="noopener">iPhone 可支持 High 配置</a>，<a href="http://www.apple.com/tv/specs/" target="_blank" rel="noopener">AppleTV 支持 Baseline、Main 和 High 配置</a>，Flash 和台式机支持 <code>Baseline</code>、<code>Main</code> 和 <code>High</code> 配置。H.264 同时也是蓝光标准授权的编解码器，蓝光光盘通常使用 <code>High</code> 配置。</p><p>大多数的非 PC 设备（如 <code>iPhone</code> 和蓝光播放器）在播放 H.264 视频时，实际是由专用芯片负责解码，因为他们的 CPU 并没有足够的性能以支持视频的实时播放。目前甚至一些低端的桌面显卡也能够支持硬件解码 H.264。有很多 H.264 的编码器，包括开源的 <a href="http://www.videolan.org/developers/x264.html" target="_blank" rel="noopener">x264 library</a>。H.264 视频可以嵌入到大多数流行视频容器格式中，包括 <code>MP4</code> 和 <code>MKV</code>。</p><p><strong>H.264 标准是需要支付专利许可费用的</strong>，专利许可的主要来源是 <a href="http://www.mpegla.com/" target="_blank" rel="noopener">MPEG LA 组织</a>。<a href="https://en.wikipedia.org/wiki/H.264/MPEG-4_AVC#Patent_licensing" target="_blank" rel="noopener">2010年8月26日，MPEG LA 组织宣布使用 H.264 编码的网络视频对<strong>最终用户永久免费</strong></a>。但是离开网络使用到有关 H.264 的产品或服务，还是需要支付费用的。</p><p><img src="/contents/html5-video/h264.png" alt="MPEG-4/H.264 video format"><br><a href="http://caniuse.com/#feat=mpeg4" target="_blank" rel="noopener">数据来源</a></p><h3 id="Theora"><a href="#Theora" class="headerlink" title="Theora"></a>Theora</h3><p><a href="http://en.wikipedia.org/wiki/Theora" target="_blank" rel="noopener">Theora</a> 由 <a href="http://en.wikipedia.org/wiki/Theora#History" target="_blank" rel="noopener">VP3 编解码器</a> 演化而来，随后由 <a href="http://xiph.org/" target="_blank" rel="noopener">Xiph.org 基金会</a> 开发维护。<strong>Theora 开源且免费</strong>，不过这套标准于 <code>2004</code> 年即处于“冻结”状态，<code>Theora</code> 项目（包含开源的视频编码及解码）只在 <code>2008</code> 年发布了初版，<code>2009</code> 年发布了 <code>1.1.1</code> 稳定版，最近一次发布的 <code>1.2.0 Alpha 1</code> 预览版也已是 5 年前的事情了。</p><p><code>Theora</code> 视频可以嵌入到任何视频容器格式内，不过最常见的还是 <code>Ogg</code> 容器。所有主流的 Linux 发行版都默认支持 <code>Theora</code> 格式，Firefox、Chrome 和 Opera 的当前版本都对其提供了原生支持。在安装了 Xiph.org 提供的开源解码软件后，在 <a href="http://www.xiph.org/dshow/" target="_blank" rel="noopener">Windows</a> 和 <a href="http://xiph.org/quicktime/" target="_blank" rel="noopener">Max OS X</a> 也可以播放 <code>Theora</code> 视频。</p><p><img src="/contents/html5-video/theora.png" alt="Ogg/Theora video format"><br><a href="http://caniuse.com/#feat=ogv" target="_blank" rel="noopener">数据来源</a></p><h3 id="VP8"><a href="#VP8" class="headerlink" title="VP8"></a>VP8</h3><p><a href="http://en.wikipedia.org/wiki/VP8" target="_blank" rel="noopener">VP8</a> 最早由 <code>On2</code> 开发，2010 年，Google 收购 <code>On2</code> 后发布了这个视频编解码器的规范和开源的编码解码示例。在经过一些争论之后，最终 VP8 的授权确认为一个<strong>开放源代码授权</strong>。</p><p><code>WebM</code> 项目和 <code>VP8</code> 同时在 2010 年 5 月发表，Mozilla、Opera、Google 和其他 40 多家厂商共同协助发展，目的是让 VP8 成为 HTML5 的视频格式。 WebM 为一个容器格式，视频部分使用 VP8，声音格式则是使用 <code>Vorbis</code>。</p><p><img src="/contents/html5-video/vp8.png" alt="WebM video format"><br><a href="http://caniuse.com/#feat=webm" target="_blank" rel="noopener">数据来源</a></p><h2 id="音频编解码器"><a href="#音频编解码器" class="headerlink" title="音频编解码器"></a>音频编解码器</h2><p>同视频编解码器一样，音频编解码器是指对音频流编码和解码的算法。音频编解码器也分为有损和无损两种。无损的音频对互联网来说同样太大，所以我们只关注有损音频编解码。</p><p>在播放视频时，音频编解码器起到的作用是解码音频数据流，并将其通过扬声器播放出来。同有损编码视频一样，有很多办法来减小音频流的尺寸。在 <code>录音 - 编码 - 解码 - 播放</code> 的过程中，有大量信息被丢弃。不同的音频编解码器丢弃的内容不同，但他们都能做到欺骗你的耳朵，让你察觉不到这些损失。</p><p>有一个只有在音频中才存在的概念：<code>声道</code>。声音通过扬声器来播放，普通的桌面电脑可能拥有左右两个扬声器。环绕立体声系统拥有 6 个甚至更多的扬声器。一个扬声器可以用来播放原始音轨中的一个特定声道。当你坐在 6 个扬声器之中，被 6 个独立声道播放出的声音所环绕，你的大脑会同步它们并使你产生出一种身临其境的感觉。</p><p>大部分通用性的音频编解码器能够处理两个声道。在录音时，声音被切分成左右两个声道；在编码时，两个声道被存储在同一个音频流中；解码时，两个声道解译后被送至不同的扬声器来播放。一些音频解码器能够处理两个以上的声道，并且加以区分，以便在播放时能够通过恰当的扬声器来播放。</p><p>常用的音频编解码器有：<code>MP3</code>、<code>AAC</code> 和 <code>Vorbis</code>。</p><h3 id="MPEG-1-Audio-Layer-3"><a href="#MPEG-1-Audio-Layer-3" class="headerlink" title="MPEG-1 Audio Layer 3"></a>MPEG-1 Audio Layer 3</h3><p><a href="http://en.wikipedia.org/wiki/MPEG-1_Audio_Layer_3" target="_blank" rel="noopener">MPEG-1 Audio Layer 3</a> 即 <code>MP3</code>。MP3 <strong>最多能容纳两个声道</strong>，可以编码为不同比特率：64 kbps, 128 kbps, 192 kbps, 甚至从 32 到 320 的各种速率。更高的比特率意味着更大的文件尺寸和更好的音频质量，不过音频质量和比特速率不是正比关系。128 kbps 要比 64 kbps 的音质水平提升两倍以上，但 256 kbps 并不能达到 128 kbps 的两倍音质。MP3 支持<strong>可变比特率编码</strong>，这意味着一个音频流的某一部分可能会比另一部分的压缩率高。例如交响乐在演奏时使用高比特率，而在章节间的静默阶段使用低比特率。MP3 同样也支持<strong>固定比特率编码</strong>。</p><p>MP3 标准没有确切定义如何编码，但却明确定义了如何解码；不同的编码器使用不同方式导致编码结果大相径庭，但它们需要保证编码结果都可以使用同一个播放器来解码并播放。开源的 <a href="http://lame.sourceforge.net/" target="_blank" rel="noopener">LAME 项目</a> 是免费编码器的首选。</p><p>MP3 格式（于 1991 年标准化）是<strong>受版权约束</strong>的，这也解释了为什么 <code>Linux</code> 系统不能直接播放 MP3 文件。官方是要求 MP3 编解码器购买授权的，但 MP3 的版权非常混乱和碎片化，这也导致 MP3 成为<strong>事实上的免费格式</strong>。到 2015 ~ 2017 年， MP3 的专利也基本都到期了，也将成为公共领域的东西。所有随身听都可以播放 MP3 文件，MP3 音频流也可以嵌入至任意视频容器中。Adobe Flash 可以播放独立的 MP3 文件，也可以播放在 MP4 视频容器中的 MP3 音频流。</p><p><img src="/contents/html5-video/mp3.png" alt="MP3 audio format"><br><a href="http://caniuse.com/#search=mp3%20audio" target="_blank" rel="noopener">数据来源</a></p><h3 id="Advanced-Audio-Coding"><a href="#Advanced-Audio-Coding" class="headerlink" title="Advanced Audio Coding"></a>Advanced Audio Coding</h3><p><a href="http://en.wikipedia.org/wiki/Advanced_Audio_Coding" target="_blank" rel="noopener">Advanced Audio Coding</a> 通常简称为 <code>AAC</code>。标准化于 1997 年的这个规范，因苹果选择其作为 <code>iTunes Store</code> 的默认格式而声名鹊起。<code>AAC</code> 格式是<strong>需要收取版权费用</strong>的，收费标准可在 <a href="http://www.vialicensing.com/licensing/aac-fees.aspx" target="_blank" rel="noopener">这里</a> 查看。<strong>终端用户编码器和/或译码器产品制造商或开放商需要获得 AAC 专利授权。以 AAC 格式编码发布的比特流 —— 无论是通过广播、网络数据流或是通过物理媒体提供 —— 都没有专利授权费</strong>。</p><p><code>AAC</code> 被设计为在使用与 MP3 相同的比特率时提供更好的音质，并且可以使用任意比特率来编码（MP3 被限定在最高 320 kbps）。<code>AAC</code> 编码的音频<strong>最多可支持 48 个声道</strong>，虽然实际中并没有人需要使用这么多声道。<code>AAC</code> 格式还有一个区别于 MP3 的地方时，它同 <code>H.264</code> 一样，定义了多种<strong>配置</strong>（<code>profile</code>）。低端配置用以在计算资源有限的设备上实时播放，高端配置提供更好的音质，同时需要更长的编解码时间。</p><p>当前所有的苹果产品，包括 <code>iPod</code>、<code>AppleTV</code> 和 <code>QuickTime</code> 都支持播放在 MP4 视频容器中的 <code>ACC</code> 格式的固定配置音频流。<code>Adobe Flash</code> 通开源的 <code>MPlayer</code> 和 <code>VLC</code> 播放器一样，支持 MP4 容器中的任意配置的 <code>AAC</code> 格式音频。编码方面，<code>FAAC</code> 类库是一个可选的开源类库，同时还有 <code>mencoder</code> 和 <code>ffmpeg</code>。</p><p><img src="/contents/html5-video/aac.png" alt="AAC audio file format"><br><a href="http://caniuse.com/#search=AAC%20audio" target="_blank" rel="noopener">数据来源</a></p><h3 id="Vorbis"><a href="#Vorbis" class="headerlink" title="Vorbis"></a>Vorbis</h3><p><a href="http://en.wikipedia.org/wiki/Vorbis" target="_blank" rel="noopener">Vorbis</a> 通常被称作 <code>Ogg Vorbis</code>，不过从技术角度来说这个称呼是有误的。<code>Ogg</code> 只是一个视频容器格式，<code>Voribs</code> 音频流也可以被嵌入到其他视频容器中。<code>Vorbis</code> 是<strong>开放、免费且无专利限制</strong>的，因此所有主要的 <code>Linux</code> 发行版及移动设备都可以通过开源的 <a href="http://www.rockbox.org/" target="_blank" rel="noopener">Rockbox</a> 固件为其提供支持。<code>Vorbis</code> 格式音频流通常被嵌入在 <code>Ogg</code> 或 <code>WebM</code> 容器中，但它们同时也可以被嵌入在 <code>MP4</code> 或 <code>MKV</code> 容器里（甚至经过一些改动后，也可以嵌入在 <a href="http://www.alexander-noe.com/video/amg/" target="_blank" rel="noopener">AVI</a> 中）。<code>Vorbis</code> 支持<strong>任意数量的声道</strong>。</p><p>开源的 <code>Vorbis</code> 编码器和解码器有很多，包括 <a href="http://oggconvert.tristanb.net/" target="_blank" rel="noopener">OggConvert</a>（编码）、<a href="http://www.ffmpeg.org/" target="_blank" rel="noopener">ffmpeg</a>（解码）、<a href="http://www.geocities.jp/aoyoume/aotuv/" target="_blank" rel="noopener">aoTuV</a>（编码）和 <a href="http://downloads.xiph.org/releases/vorbis/" target="_blank" rel="noopener">libvorbis</a>（解码）。</p><p><img src="/contents/html5-video/vorbis.png" alt="Ogg Vorbis audio format"><br><a href="http://caniuse.com/#search=vorbis" target="_blank" rel="noopener">数据来源</a></p><h2 id="那么问题来了：我们该用哪个？"><a href="#那么问题来了：我们该用哪个？" class="headerlink" title="那么问题来了：我们该用哪个？"></a>那么问题来了：我们该用哪个？</h2><p>看了上面的介绍我们发现：</p><ul><li>没有任何一种容器和编解码器的组合能够在所有的 HTML5 浏览器中播放。</li><li>并且这种情况在可预见的未来并不会有明显的改善。</li></ul><p>要想让你的视频在任意设备和平台上播放，你需要对视频<strong>编码</strong>，<strong>并且不止一次</strong>。</p><p>针对不支持 <code>&lt;video&gt;</code> 元素的“上古”浏览器，可以继续沿用当前国内主流的 <code>Adobe Flash Player</code> 方案。在 Adobe 的 <a href="https://helpx.adobe.com/flash/kb/supported-codecs-flash-player.html" target="_blank" rel="noopener">帮助文档</a> 中我们能够找到 <code>Flash Player</code> 支持的音视频编解码器：</p><p><img src="/contents/html5-video/flash-player.png" alt="Supported codecs"></p><p>仔细观察之前各主流浏览器对音视频编码格式及容器格式的支持情况可以发现，<code>MP4(H.264+AAC)</code> 或 <code>MP4(H.264+MP3)</code> 已经可以覆盖 <code>90%</code> 以上的浏览器用户。而剩余的用户使用的浏览器又以 <code>IE9</code> 之前版本的 <code>IE</code> 及老版本的 Firefox 和 Opera 居多。这恰巧又是 <code>Flash Player</code> 的“势力范围”。支持 <code>MP4(H.264+AAC)</code> 的最低版本 <code>Flash Player v9.0.115.0</code> 于 2007 年底发布，距今也已近 <strong>8 年</strong>。</p><p><strong>有理由相信，使用 <code>MP4(H.264 + MP3/AAC)</code> 的容器和编码组合，与 <code>HTML5 播放器 + Adobe Flash Player</code> 的播放组合，可以满足现今绝大多数桌面及移动终端视频播放的需求。这样便可以只编码出一种视频格式（MP4），节省大量视频编码的耗时以及存储空间。</strong></p><h2 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h2><p>HTML5 提供了两种使用 <code>&lt;video&gt;</code> 元素的方式。在只有一个视频文件的时候，可以像 <code>&lt;img src=&quot;...&quot;&gt;</code> 一样，直接使用 <code>&lt;video&gt;</code> 元素的 <code>src</code> 属性，如：</p><pre><code class="html">&lt;video src=&quot;mov.mp4&quot;&gt;&lt;/video&gt;</code></pre><p>这就是你要做的全部。不过就像 <code>&lt;img&gt;</code> 元素一样，你应该总是在 <code>&lt;video&gt;</code> 元素中指定视频的宽高属性。这个宽高属性值应该与你在进行视频编码时指定的值一致。不用担心视频的某一维度会比指定值小，你的浏览器能够将其自动居中，并保证不会超出指定区域。</p><pre><code class="html">&lt;video src=&quot;mov.mp4&quot; width=&quot;480&quot; height=&quot;640&quot;&gt;&lt;/video&gt;</code></pre><p>默认情况下，<code>&lt;video&gt;</code> 元素不会显示任何播放控制器。你可以通过 <code>HTML</code>、<code>CSS</code> 和 <code>JavaScript</code> 创建属于你自己的播放控制器。<code>&lt;video&gt;</code> 元素包含 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#playing-the-media-resource" target="_blank" rel="noopener">播放和暂停</a> 方法，可读写的 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#dom-media-currenttime" target="_blank" rel="noopener">当前时间</a>、<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#dom-media-volume" target="_blank" rel="noopener">音量</a> 和 <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#dom-media-muted" target="_blank" rel="noopener">静音</a> 属性。所以你拥有了创建一个自己的播放界面的所有内容。</p><p>如果你不想自己构建一个播放器界面，也可以让浏览器显示其内置的控制器。只要增加一个 <code>controls</code> 属性即可：</p><pre><code class="html">&lt;video src=&quot;mov.mp4&quot; width=&quot;480&quot; height=&quot;640&quot; controls&gt;&lt;/video&gt;</code></pre><p>还有两个有用的属性：<code>preload</code> 和 <code>autoplay</code>。设置 <code>preload</code> 属性后浏览器会在页面加载完成后自动开始下载视频文件。当视频文件只是一个附加材料并不会有很多人观看时，还可以将 <code>preload</code> 设置为 <code>none</code> 以告知浏览器减轻网络压力。</p><p><code>autoplay</code> 属性会在页面加载后自动开始视频文件的下载，并尽快地开始播放视频。这是个有人爱有人恨的特性，但 HTML5 定义这样一个属性是很重要的。一些人希望他们的视频自动播放，即便这样会使访问者感到反感。如果 HTML5 没有定义一个标准的方式来自动播放视频，他们则会通过 JS 来达到目的（例如在 <code>window</code> 的 <code>load</code> 事件中直接调用 <code>play()</code> 方法）。这会使访问者难以应对。而现在则可以通过简单的浏览器插件或脚本告诉浏览器“忽略 <code>autoplay</code> 属性，我不想视频自动播放”。</p><p>当存在多个视频文件以满足浏览器兼容性问题时，HTML5 也提供了一种方式来添加所有这些视频：<code>&lt;source&gt;</code> 元素。每个 <code>&lt;video&gt;</code> 元素可以包含多个 <code>&lt;source&gt;</code> 元素。浏览器会在视频源列表中从上之下，选择第一个能够播放的视频。</p><p>这同时带来了另一个问题：浏览器如何知道哪个视频是它所支持的？在最坏的情况下，浏览器会加载每个视频并且尝试播放。这是非常浪费带宽资源的。但如果你能够直接告诉浏览器每个视频的编码信息，浏览器则可以通过该信息进行判断，以此节省大量网络带宽资源。可以通过 <code>&lt;source&gt;</code> 元素的 <code>type</code> 属性来设置视频编码信息：</p><pre><code class="html">&lt;video width=&quot;480&quot; height=&quot;640&quot; controls&gt;  &lt;source src=&quot;mov.mp4&quot; type=&quot;video/mp4; codecs=avc1.42E01E,mp4a.40.2&quot;&gt;  &lt;source src=&quot;mov.webm&quot; type=&quot;video/webm; codecs=vp8,vorbis&quot;&gt;  &lt;source src=&quot;mov.ogv&quot; type=&quot;video/ogg; codecs=theora,vorbis&quot;&gt;&lt;/video&gt;</code></pre><p><code>type</code> 属性的值看起来很复杂。它是由两部分组成的：<code>视频容器格式</code> 和 <code>视频/音频编码</code>。例如 <code>video/mp4</code> 代表视频容器格式是 <code>MP4</code> 格式。不过严格来说，这里使用的是视频容器格式的 <a href="https://wiki.whatwg.org/wiki/Video_type_parameters#MIME_types_used_in_the_wild_.28in_type.3D.22.22.29" target="_blank" rel="noopener"><code>MIME</code> 类型</a>。视频/音频的编解码器参数也很复杂，关于它的标准规范是在 <a href="http://tools.ietf.org/html/rfc6381" target="_blank" rel="noopener">RFC 6381</a> 中定义的，其中 <a href="http://tools.ietf.org/html/rfc6381#section-3.3" target="_blank" rel="noopener">3.3 节</a> 有关于这个参数的说明。概括来说，它代表了 <code>H.264</code> 使用的是 <code>baseline</code> 配置，<code>AAC</code> 使用的也是低复杂度的配置。更多的 <code>type</code> 属性参数可以在 <a href="https://wiki.whatwg.org/wiki/Video_type_parameters" target="_blank" rel="noopener">这里</a> 找到。关于 <code>codecs</code> 参数的具体含义可以参考 <a href="http://stackoverflow.com/questions/16363167/html5-video-tag-codecs-attribute" target="_blank" rel="noopener">这里</a>。</p><blockquote><p>注意：<code>codecs</code> 中视频编码和音频编码之间使用逗号间隔，不要加<strong>空格</strong>。</p></blockquote><p>还有一点需要注意：<strong>视频文件必须在服务端设置恰当的 MIME 类型</strong>，否则你可能会经常遇到类似视频文件在你本地环境一切正常，但在实际产品中无法播放的情况。仅在 <code>&lt;source&gt;</code> 元素的 <code>type</code> 属性中设置是不够的，你还需要为 web 服务器 HTTP 头中的 Content-Type 设置上 MIME 类型。</p><p>当遇到不支持 <code>&lt;video&gt;</code> 标签的那不足一成的浏览器时，只要你已经编码好了 <code>H.264</code> 格式的视频，即可通过基于 Flash 技术的视频播放器来将视频播放出来。可选的开源播放器有很多，<code>CC</code> 协议的 <a href="https://github.com/jwplayer/jwplayer" target="_blank" rel="noopener">jwplayer</a>、<code>GPL</code> 协议的 <a href="https://github.com/flowplayer/flowplayer" target="_blank" rel="noopener">flowplayer</a> 和 <code>Apache</code> 协议的 <a href="https://github.com/videojs/video-js-swf" target="_blank" rel="noopener">video-js-swf</a> 等。</p><p><code>Flash Player</code> 不认识 <code>&lt;video&gt;</code> 元素，也不会自动将 <code>&lt;video&gt;</code> 标签转换成 <code>Flash object</code>。但 HTML5 在设计时已经考虑到了这一点，你可以在 <code>&lt;video&gt;</code> 元素内部嵌入一个 <code>&lt;object&gt;</code> 元素。那些不支持 HTML5 视频播放的浏览器会忽略 <code>&lt;video&gt;</code> 标签，并直接渲染其中的 <code>&lt;object&gt;</code> 元素，借此调用 <code>Flash</code> 插件来播放视频。而支持 HTML5 视频播放的浏览器会在 <code>&lt;video&gt;</code> 元素中找到可播放的视频，并忽略其中的 <code>&lt;object&gt;</code> 元素。这些都是由 HTML5 规范和浏览器所支持的，无需额外的 <code>JS</code> 代码。</p><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><p>下面是一段示例代码，容器为 <code>MP4</code>，视频编码为 <code>H.264(Main Profile, Level 30)</code>，音频编码为 <code>AAC(low-complexity)</code>：</p><pre><code class="html">&lt;video width=&quot;360&quot; height=&quot;640&quot; preload controls&gt;  &lt;source src=&quot;/contents/html5-video/mov-h264_main_30-aac_lc.mp4&quot; type=&quot;video/mp4; codecs=avc1.4D401E,mp4a.40.2&quot;&gt;  &lt;object width=&quot;360&quot; height=&quot;640&quot; type=&quot;application/x-shockwave-flash&quot; data=&quot;http://releases.flowplayer.org/swf/flowplayer-3.2.16.swf&quot;&gt;    &lt;param name=&quot;movie&quot; value=&quot;http://releases.flowplayer.org/swf/flowplayer-3.2.16.swf&quot;&gt;    &lt;param name=&quot;allowfullscreen&quot; value=&quot;true&quot;&gt;    &lt;param name=&quot;flashvars&quot; value=&quot;config={&#39;clip&#39;: {&#39;url&#39;: &#39;http://alphahinex.github.io/contents/html5-video/mov-h264_main_30-aac_lc.mp4&#39;, &#39;autoPlay&#39;: false, &#39;autoBuffering&#39;: true}}&quot;&gt;  &lt;/object&gt;&lt;/video&gt;</code></pre><video width="360" height="640" preload controls>  <source src="/contents/html5-video/mov-h264_main_30-aac_lc.mp4" type="video/mp4; codecs=avc1.4D401E,mp4a.40.2">  <object width="360" height="640" type="application/x-shockwave-flash" data="http://releases.flowplayer.org/swf/flowplayer-3.2.16.swf">    <param name="movie" value="http://releases.flowplayer.org/swf/flowplayer-3.2.16.swf">    <param name="allowfullscreen" value="true">    <param name="flashvars" value="config={'clip': {'url': 'https://alphahinex.github.io/contents/html5-video/mov-h264_main_30-aac_lc.mp4', 'autoPlay': false, 'autoBuffering': true}}">  </object></video><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://diveintohtml5.info/video.html" target="_blank" rel="noopener">Video on the web</a></li><li><a href="https://html.spec.whatwg.org/multipage/" target="_blank" rel="noopener">HTML5 Specification</a></li><li><a href="http://diveintohtml5.info/index.html" target="_blank" rel="noopener">Dive into HTML5</a></li><li><a href="https://blog.shou.tv/the-technology-behind-shoutv" target="_blank" rel="noopener">The Technology Behind Shou.TV</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> Video </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《把时间当作朋友》书摘</title>
      <link href="2015/12/01/make-friends-with-time/"/>
      <url>2015/12/01/make-friends-with-time/</url>
      
        <content type="html"><![CDATA[<ul><li>Start at: 2015-09-02</li><li>End at: 2015-10-21</li><li>Process: 270/270</li></ul><h2 id="所有人的困境"><a href="#所有人的困境" class="headerlink" title="所有人的困境"></a>所有人的困境</h2><ul><li>所有人共有的弱点：<strong>懒惰</strong></li><li>“既勤奋又懒惰”的怪异现象来自于他们的“时间压力”感受。“没有时间了”，或者“时间不够了”的感受和恐惧，使得他们超乎寻常地勤奋，哪怕是虚假的“勤奋”，恨不能废寝忘食。而同样的感受，也使得他们终日寻找捷径，美其名曰“提高效率”，而实际上却想着“最好不费吹灰之力” —— 无论哪一种都注定是不现实的，因为，已经“没有时间了” —— 这却是冷冰冰的现实</li></ul><h2 id="心智的力量"><a href="#心智的力量" class="headerlink" title="心智的力量"></a>心智的力量</h2><h3 id="了解心智的力量"><a href="#了解心智的力量" class="headerlink" title="了解心智的力量"></a>了解心智的力量</h3><ul><li>所有的方法无非两种：正确的，或者错误的。确实去做了，并且坚持到底，那么方法是对是错自然就会明了</li><li>面对相同的问题 —— “为什么要学习”，心智能力的差异竟然会使人们因为相同的理由 —— “不知道学习有什么用” —— 而做出竟然完全相反的选择</li><li>因“不知道学习有什么用”而拒绝学习的人，会在接下来的日子里虚度无数光阴；而选择努力学习的人，每时每刻都充满了收获，并且会在将来的某一天获得更多的“意外”收获</li></ul><h3 id="心智力量的差异"><a href="#心智力量的差异" class="headerlink" title="心智力量的差异"></a>心智力量的差异</h3><h4 id="上司真的很愚蠢吗？"><a href="#上司真的很愚蠢吗？" class="headerlink" title="上司真的很愚蠢吗？"></a>上司真的很愚蠢吗？</h4><p>看看拥有强大的心智力量的人面对“上司的愚蠢”是如何思考的吧</p><pre><code>    ├─是，能否补救？    │  ├─能，补救的方法是什么？    │  └─不能，作为团队成员，能否有效地提供帮助？    │      ├─能，相处一个有效的方式去沟通，并提供帮助——因为这其实是团队的义务之一。    │      └─不能，作为团队成员，有没有其他可行的建议，或者可实施的有效方案？    │          ├─0有，想办法提交，并推进实行。    │          └─没有，暂时闭嘴——反正不是抱怨。    └─不是，能否平静对待？        ├─能，专心做自己的工作，完成自己的贡献。        └─不能，不要抱怨，应该安静地离开。</code></pre><h4 id="你真的那么优秀吗？"><a href="#你真的那么优秀吗？" class="headerlink" title="你真的那么优秀吗？"></a>你真的那么优秀吗？</h4><ul><li>猎头喜欢被低估的对象。一个相对比较简单的办法就是锁定二流人才。</li><li>也许你确实是“另外一只真正的老虎”，也许你其实并不是。如果你自己确信你自己是的话，那么猎头对你来说没什么用处 —— 你是注定要做自己的事情的，用不着他。如果你并不确定自己是，或者你自己清楚自己干脆就不是，那么猎头还是对你没什么用处 —— 因为你听信他的话很可能会让你走入另外一个困境，有的时候换一个环境意味着放弃过去所有的积累而彻底重新来过</li></ul><h4 id="兴趣真的那么重要么？"><a href="#兴趣真的那么重要么？" class="headerlink" title="兴趣真的那么重要么？"></a>兴趣真的那么重要么？</h4><ul><li>这些人并不是对正在做的事情没有兴趣，而是没能力把目前正在做的事情做好。最终，没有人喜欢自己做不好的事情</li><li>一定要问清楚自己这个问题：我不喜欢做这件事情有没有可能仅仅是因为这件事我并没有做好？要是因为自己没有做好而不喜欢，就要分辨另外一件事：做好这件事情究竟对自己有没有意义？如果有，那就要努力做，直到做好为止 —— 没有其他选择</li><li>兴趣并不是很重要。只要一件事你能做好，并且做到比谁都好，或者至少比大多数人好，你就不会对那件事没有兴趣</li><li>要根据孩子的情况，选出孩子最可能做得比别人好的事情（这可能就已经是极其耗时费力的了）；然后还要伤透脑筋想出怎样才能让孩子学会并做得好、做得比一般人好、做得比谁都好 —— 然后兴趣就自然出现了</li><li><strong>往往并不是有兴趣才能做好，而是做好了才有兴趣</strong></li></ul><h4 id="学习方法真的至关重要么？"><a href="#学习方法真的至关重要么？" class="headerlink" title="学习方法真的至关重要么？"></a>学习方法真的至关重要么？</h4><ul><li>所有学习上的成功，都只靠两件事：<strong>策略</strong>和<strong>坚持</strong>，而坚持本身就应该是最重要的策略。坚持，其实就是是重复；而重复，说到底就是时间的投入，大量的时间投入</li><li>与其不停地找更好的方法，还不如马上开始行动，省得虚度更多的时间</li></ul><h4 id="盲打究竟是否值得学会？"><a href="#盲打究竟是否值得学会？" class="headerlink" title="盲打究竟是否值得学会？"></a>盲打究竟是否值得学会？</h4><ul><li>重要的是，他每天都在“反省”。作为一个真正意义上的人，好像没有什么比这个更重要了</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>事实上，没有什么要比发现、培养、呵护、调整自己的心智更重要的事情了</li></ul><h2 id="开启自己的心智"><a href="#开启自己的心智" class="headerlink" title="开启自己的心智"></a>开启自己的心智</h2><h3 id="何谓心智"><a href="#何谓心智" class="headerlink" title="何谓心智"></a>何谓心智</h3><ul><li>乔治·博瑞（C. George Boeree）博士的定义：心智主要包括以下三个方面的能力：a. 获得知识；b. 应用知识；c. 抽象推理</li><li>透过“获取知识”、“应用知识”、以及同样需要学习才能获得的“抽象推理能力”，最终，一个人的心智可以被开启、培养、发展，可以被重建，再进一步甚至可以被反复重建</li></ul><h3 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h3><ul><li>可以用我们的大脑控制我们的大脑</li></ul><table class="table table-bordered table-hover">  <thead>    <tr>      <th style="text-align: left">你</th>      <th style="text-align: left">自己知道的</th>      <th style="text-align: left">自己并不知道的</th>    </tr>  </thead>  <tbody>    <tr>      <td style="text-align: left">别人知道的</td>      <td style="text-align: left">1</td>      <td style="text-align: left">2</td>    </tr>    <tr>      <td style="text-align: left">别人并不知道的</td>      <td style="text-align: left">3</td>      <td style="text-align: left">4</td>    </tr>  </tbody></table><ul><li>你现在竟然仅凭你的心智就知道了你原本并不知道的“你不知道别人也不知道的”你的存在</li></ul><table class="table table-bordered table-hover">  <thead>    <tr>      <th style="text-align: left">有些事情/道理</th>      <th style="text-align: left">实际上正确</th>      <th style="text-align: left">实际上错误</th>    </tr>  </thead>  <tbody>    <tr>      <td style="text-align: left">我们以为正确</td>      <td style="text-align: left">1</td>      <td style="text-align: left">2</td>    </tr>    <tr>      <td style="text-align: left">我们以为错误</td>      <td style="text-align: left">3</td>      <td style="text-align: left">4</td>    </tr>  </tbody></table><ul><li>在第一种情况与第四种情况下，我们是安全的；而在第二种或第三种情况下，我们必将面临错误，并很可能因为认知错误而付出惨痛的代价。但无论如何，只要牢记“我们的认知不仅可能也确实往往背离现实”这个事实本身，就已经足以保证我们不断进步了 —— 我们因了解这个事实而已经拥有了良好的自省机制</li></ul><h3 id="控制自己的大脑"><a href="#控制自己的大脑" class="headerlink" title="控制自己的大脑"></a>控制自己的大脑</h3><ul><li>你的大脑并不是你，你的大脑是（属于）“你的”大脑</li><li>即使是在极端恶劣的环境里，人们也会拥有一种最后的自由，那就是<strong>选择自己的态度的自由</strong></li></ul><h3 id="控制自己的情绪"><a href="#控制自己的情绪" class="headerlink" title="控制自己的情绪"></a>控制自己的情绪</h3><ul><li>痛苦就是这样，一旦我们竟然能运用心智把我们自己的注意力转移到其他地方上去的时候，痛苦就会几乎自动消失，在你重新注意它之前，它不会回来</li><li>心理学研究告诉我们，我们的大脑有一种自我保护功能 —— <strong>遗忘痛苦</strong></li><li>你现在知道你为什么总那么没记性了吧？因为在你遇到挫折或者面对那些你曾经的错误决定最终带来的惩罚的时候，你太痛苦了。而这样的痛苦，必然被你的大脑自动列入遗忘的序列，并在你的大脑里彻底消失</li><li>一个人遗忘痛苦的能力特别强的一个具体表现就是，这个人会很轻易地原谅自己</li><li>有两种办法很简单却又非常有效。第一种办法是当你面临尴尬的时候，记得一定要拿出纸笔来，把你所遇到的尴尬<strong>记录</strong>下来 —— 当然，最好是纪录在同一个本子里。这样的纪录是非常有意义的。因为它会提醒你，这是你曾经遇到过的尴尬。如果你不用纸笔记下来，那你就肯定会忘。然后还要养成一个习惯，定期拿出这个本子回顾一下。这个习惯往往会使你很有成就感的，因为你知道，甚至可以清楚地看到你已经有进步了，因为那个本子里记录过的很多的错误你都不再犯了 —— 当然，不再犯那些错误的原因是因为你在不停地提醒你自己</li><li>另外一个办法是，在面临尴尬的时候，尽量<strong>弱化</strong>你的痛苦。控制自己的情绪，不要被你的大脑的直接反应所左右。要知道，你所面临的所有尴尬，最终肯定有一部分原因是你自己造成的。所以，没必要找借口，没必要抱怨别人，没必要觉得这世界就对你一个人不公平，要记得“你并不孤独” —— 肯定还有别人也在不同的地方、不同的时间遭遇过同样的尴尬和痛苦。但是有多少人能像你现在这样平静地对待痛苦，而又清楚地意识到你不能被你的大脑的直接反应所左右呢？你这样一想，就释然了。只要你没那么痛苦，你的大脑就很难遗忘这个事件 —— 更何况你早就把这个事件和经验记录在案了呢</li><li>在做所有类似背单词的必须记住大量信息的工作的时候，一定要想办法由衷地把这件事当作快乐的事情来做</li></ul><h3 id="推迟满足感"><a href="#推迟满足感" class="headerlink" title="推迟满足感"></a>推迟满足感</h3><ul><li>a. 希望自己的欲望马上获得满足是大多数人的天性；b. 野心永远是少数人的天性</li><li>承认“希望自己的欲望马上获得满足”是自己的天性就好办了。因为，平静接受并且正确认识自己的天性是改变天性的第一步</li><li>在工作和学习上控制这种天性是最重要的。为了能在这方面控制住自己的天性，有的时候，在其他方面稍微放纵一下都是非常有必要的。但在工作和学习上，坚决不要放纵。工作和学习都是艰苦的，路程都是漫长的，成果都不可能一蹴而就</li><li>“推迟满足感”是心智成熟的人必备的能力，也是需要挣扎和锻炼才可以习得的能力</li></ul><h2 id="通过管理自己与时间做朋友"><a href="#通过管理自己与时间做朋友" class="headerlink" title="通过管理自己与时间做朋友"></a>通过管理自己与时间做朋友</h2><h3 id="精确感知时间"><a href="#精确感知时间" class="headerlink" title="精确感知时间"></a>精确感知时间</h3><ul><li>“事件记录”，往往只能记录事件的名称，是一种基于结果的记录；而”事件 - 时间日志”却是一种基于过程的记录。这里的细微差别是，<strong>基于过程的记录要比基于结果的记录只会更为详尽</strong></li><li>“事件 - 时间日志”会使你对时间的感觉越来越精确</li><li>既然“管理时间”是不可能的，那么解决方法就只能是，想尽一切办法真正了解自己，真正了解时间、精确地感知时间；而后再想尽一切办法使自己以及自己的行为与时间“合拍”，就是“与时间做朋友”</li></ul><h3 id="最好的工具：纸笔"><a href="#最好的工具：纸笔" class="headerlink" title="最好的工具：纸笔"></a>最好的工具：纸笔</h3><ul><li>事实上，养成任何非天生的习惯，都是需要挣扎才能做成的事情。我们只有一个习惯是天生的 —— “<strong>懒惰</strong>”</li><li>“心智开启”的起点是“意识到可以自律”，而心智发展的过程就是克服懒惰的过程</li><li>“人或多或少是经验主义的动物”。也许每个人的不幸都是一样的，他一生中最多的经验是“半途而废”，乃至于想要放弃“半途而废”要比“坚持到底最终成功”难太多了。<strong>当我们决心改变的时候，“懒惰”便会指使我们的那个“大脑的自我保护功能” —— “遗忘” —— 起作用，让我们不知不觉停止改变</strong></li></ul><h3 id="开始记录时间的开销"><a href="#开始记录时间的开销" class="headerlink" title="开始记录时间的开销"></a>开始记录时间的开销</h3><h3 id="制作时间预算"><a href="#制作时间预算" class="headerlink" title="制作时间预算"></a>制作时间预算</h3><h3 id="使用列表减少失误"><a href="#使用列表减少失误" class="headerlink" title="使用列表减少失误"></a>使用列表减少失误</h3><ul><li>大多数情况下确实没必要制作列表</li><li>最好的列表记录工具是纸和笔</li><li>列表没必要工整</li><li>列表一定要随手可及</li><li>最重要的任务永远只有一个</li><li>制作专门的下一阶段任务列表</li><li>给你的每个任务制定一个核对列表</li><li>列表一旦开始执行就一定要<strong>执行到底</strong></li></ul><h3 id="计划，-还是不计划，是个问题"><a href="#计划，-还是不计划，是个问题" class="headerlink" title="计划， 还是不计划，是个问题"></a>计划， 还是不计划，是个问题</h3><h4 id="计划成功的前提：目标现实可行"><a href="#计划成功的前提：目标现实可行" class="headerlink" title="计划成功的前提：目标现实可行"></a>计划成功的前提：目标现实可行</h4><ul><li>失败只有一种，就是半途而废</li></ul><h4 id="长期计划是需要通过实践才能习得的能力"><a href="#长期计划是需要通过实践才能习得的能力" class="headerlink" title="长期计划是需要通过实践才能习得的能力"></a>长期计划是需要通过实践才能习得的能力</h4><h4 id="有一些时候计划是没有必要的"><a href="#有一些时候计划是没有必要的" class="headerlink" title="有一些时候计划是没有必要的"></a>有一些时候计划是没有必要的</h4><ul><li>计划固然重要，<strong>行动</strong>更为重要</li><li>做任何事情，我们都可能要经历相同的过程：<strong>逐步熟悉，小心摸索，失败失败再失败，认真反思，卷土重来，直至成功</strong></li><li>我们一生做的事，大多都是一个<strong>试错（trial and error）</strong>的过程，对于人生，没有人能像解释数学那样给出普适的公式。永远记住，<strong>马上行动</strong>是最重要的</li></ul><h2 id="开拓我们的心智"><a href="#开拓我们的心智" class="headerlink" title="开拓我们的心智"></a>开拓我们的心智</h2><h3 id="获得知识的基本途径"><a href="#获得知识的基本途径" class="headerlink" title="获得知识的基本途径"></a>获得知识的基本途径</h3><ul><li>所有人获取知识的最基础的手段就是“<strong>体验</strong>”</li><li>比“体验”再高级一点的获取知识的手段，就是“<strong>试错</strong>”</li><li>在“试错”这个手段的基础上，另外一个“聪明”一点的，也重要得多的获取知识的方式是“<strong>观察</strong>”</li><li>“体验”、“试错”和“观察”都是存在局限的。于是，“<strong>阅读</strong>”就成了获取知识的更加重要的手段，当然也是相对更加需要心智能力的手段</li></ul><h3 id="摆脱经验的局限"><a href="#摆脱经验的局限" class="headerlink" title="摆脱经验的局限"></a>摆脱经验的局限</h3><ul><li>除了“试错”、“观察”、“阅读”之外，“<strong>思考</strong>”，准确地说，“<strong>正确地思考</strong>”，才是获取真正意义上的知识的主要手段</li><li>很多今天看起来没什么道理的传统，当初可确实曾经正确或者曾经最接近正确</li><li>“经验主义”的<strong>根本局限</strong>：首先，个体的经验有限；其次，群体的经验有限；最后，不仅存在无法通过个体或者群体经验获得的知识，还存在于现有经验相悖的知识</li><li>很多时候，人们的善良出自于软弱，而他们的残暴只不过来自于恐惧</li><li>所谓优秀的领导，能够把人们带到他们<strong>想去</strong>的地方；而所谓卓越的领导，能够把人们带到他们<strong>应该去但是没想到过要去</strong>的地方</li><li>人的一生中，要用相当长的时间通过枯燥的学习和反复的实践才能获得<strong>文字</strong>运用能力。有了文字能力才能通过<strong>阅读</strong>摆脱种种局限获得更多的知识。而后还要学会<strong>逻辑</strong>、通过科学的方法<strong>思考</strong>问题，然后才可能成长（或者干脆用“进化”作为类比更好一些）为真正意义上的人</li></ul><h3 id="提高自学能力"><a href="#提高自学能力" class="headerlink" title="提高自学能力"></a>提高自学能力</h3><h4 id="自学能力的基础技能是阅读理解能力"><a href="#自学能力的基础技能是阅读理解能力" class="headerlink" title="自学能力的基础技能是阅读理解能力"></a>自学能力的基础技能是阅读理解能力</h4><h4 id="检索能力是建立在相当熟练的阅读能力之上的能力"><a href="#检索能力是建立在相当熟练的阅读能力之上的能力" class="headerlink" title="检索能力是建立在相当熟练的阅读能力之上的能力"></a>检索能力是建立在相当熟练的阅读能力之上的能力</h4><h4 id="写作能力在自学能力中占据着重要的地位"><a href="#写作能力在自学能力中占据着重要的地位" class="headerlink" title="写作能力在自学能力中占据着重要的地位"></a>写作能力在自学能力中占据着重要的地位</h4><ul><li>从人类整体发展情况来看，除了“文学”之外，文字还有更多其他的责任 —— <strong>传递信息，积累经验，共享知识等</strong>；对大多数普通人来说，后者可能更重要一些</li></ul><h4 id="实践能力是自学能力最终能够转化为真正价值的根本"><a href="#实践能力是自学能力最终能够转化为真正价值的根本" class="headerlink" title="实践能力是自学能力最终能够转化为真正价值的根本"></a>实践能力是自学能力最终能够转化为真正价值的根本</h4><h4 id="永远保持开放的心态"><a href="#永远保持开放的心态" class="headerlink" title="永远保持开放的心态"></a>永远保持开放的心态</h4><h4 id="了解学习的进程"><a href="#了解学习的进程" class="headerlink" title="了解学习的进程"></a>了解学习的进程</h4><ul><li>认清<strong>时间</strong>和<strong>进展</strong>之间的<strong>非线性关系</strong></li></ul><h3 id="正确对待老师"><a href="#正确对待老师" class="headerlink" title="正确对待老师"></a>正确对待老师</h3><ul><li>不要因为讨厌老师而拒绝学习</li><li>无论如何，都不要也不应该用别人的错误惩罚自己，那么做不仅不对，并且愚蠢</li><li>不应该过分依赖老师；要明白“做得最好”和“教得最好”往往根本不是一回事；用自己的学习结果衡量老师往往并不正确；无论哪位老师，都有出错的时候</li><li>见识越少的人越喜欢用自己所有的见识作为判断依据，并且完全不顾自己见识的局限，也不知道自己的见识有局限</li></ul><h3 id="通过改变态度改变自己的世界"><a href="#通过改变态度改变自己的世界" class="headerlink" title="通过改变态度改变自己的世界"></a>通过改变态度改变自己的世界</h3><ul><li>只要你去改变你的态度，你就会发现你的世界会因此发生转变</li><li>抱怨最浪费时间，即便抱怨得正确</li></ul><h3 id="耐心培养记忆力"><a href="#耐心培养记忆力" class="headerlink" title="耐心培养记忆力"></a>耐心培养记忆力</h3><ul><li>不要相信自己的记忆力</li><li>很少有人仅凭天生的能力就可以拥有“神奇”的记忆力。“遗忘”是我们的自我保护功能。我们必须挣扎着经常整理已经输入大脑的信息，尽量让他们有序地排列起来 —— 最基本的方法，就是<strong>记笔记</strong></li><li>只有记笔记成为长期习惯之后，才会真正体会到这么做的好处</li></ul><h2 id="小心所谓“成功学”"><a href="#小心所谓“成功学”" class="headerlink" title="小心所谓“成功学”"></a>小心所谓“成功学”</h2><ul><li>心理健康的人不仅应该有能力看清真实的世界，还应该有足够的能力感知真实的自我</li><li>努力从失败者身上汲取经验</li><li>人家说什么你就信什么，挺傻的</li></ul><h3 id="人人都能成功，你是否相信"><a href="#人人都能成功，你是否相信" class="headerlink" title="人人都能成功，你是否相信"></a>人人都能成功，你是否相信</h3><ul><li>大量的实践与理论分析均表明，大多数随机变量均服从或近似服从<strong>正态分布</strong></li></ul><p><img src="/contents/books/make-friends-with-time-normal-distribution.png" alt="normal distribution"></p><ul><li>现代西方经济学缘起于亚当·斯密（AdamSmith，1723<del>1790）的学说，经过大卫·李嘉图（DavidRicardo，1772</del>1823）的补充，直至约翰·梅纳德·凯恩斯（JohnMaynardKeynes，1883~1946）才算是彻底正视<strong>资源的稀缺性</strong>，认为经济学的根本目的在于研究“如何运用有限的资源发挥最大的效用” —— 换言之，要在承认资源稀缺的前提下研究如何提高“效率”</li><li>所谓的“人人都能成功”明显是荒谬的。每个人拥有的资源不仅有限，并且各不相同，甚至大大不同</li></ul><h3 id="成功的定义-——-“成功学”的核心缺陷"><a href="#成功的定义-——-“成功学”的核心缺陷" class="headerlink" title="成功的定义 —— “成功学”的核心缺陷"></a>成功的定义 —— “成功学”的核心缺陷</h3><ul><li>细观很多人定义的“成功”，归根结底其实只要四个字就可以概括 —— “高人一等”</li><li>幸福是一种<strong>比较</strong>，可问题在于，比较是相对的，相对是永远没有尽头的</li><li>生活无法彻底回避比较，但是，事实上无需比较就可以获得的快乐和幸福也确实太多太多，只不过常常被人们忽略</li></ul><h3 id="个案分析-——-“成功学”的方法缺陷"><a href="#个案分析-——-“成功学”的方法缺陷" class="headerlink" title="个案分析 —— “成功学”的方法缺陷"></a>个案分析 —— “成功学”的方法缺陷</h3><ul><li>最为常见的就是“<strong>以偏概全</strong>”。某项经验在某个人身上灵验了，并不意味着这项经验在所有人身上都会起作用</li><li>另外一个更加隐蔽的逻辑错误是“<strong>单向成立</strong>”。很多论断只不过是“单向成立”的，比如“XXX成功，是因为他坚持不懈！所以，做任何事情，都要坚持不懈。只要坚持到底，就一定能够成功！”坚持到底就会成功的前提是，<strong>预期目标不仅现实可行，而后方法还得是正确的</strong></li></ul><h3 id="努力是应当的，无须强调"><a href="#努力是应当的，无须强调" class="headerlink" title="努力是应当的，无须强调"></a>努力是应当的，无须强调</h3><ul><li>所有人都需要努力。只是，强调努力和奋斗是挺可笑的而已。每个人都面临着自身一定的局限，而现实又是“资源不仅稀缺，并且分布很不均匀”，所以，每个人都要努力、奋斗、挣扎，无论是谁，无论他原本是什么样子</li><li>如果把进步程度投射在纵轴上，把学习所需要投入的时间和精力投射在横轴上，得到的曲线往往与“<strong>对数曲线</strong>”非常类似。<strong>最终的困难远比想象中的更加困难</strong></li></ul><p><img src="/contents/books/make-friends-with-time-log.png" alt="logarithm"></p><h3 id="“我是独一无二的”-——-最浪费时间的错觉"><a href="#“我是独一无二的”-——-最浪费时间的错觉" class="headerlink" title="“我是独一无二的” —— 最浪费时间的错觉"></a>“我是独一无二的” —— 最浪费时间的错觉</h3><ul><li>接受自己与别人没什么不同，至少没什么本质性上的不同，是心智正常成长的重要前提之一</li></ul><h3 id="留心成功者说的话"><a href="#留心成功者说的话" class="headerlink" title="留心成功者说的话"></a>留心成功者说的话</h3><ul><li>倾听任何人讲话的时候，都不应该带着“防备、质疑”的心态，那样可能会遗漏重要的信息。然而，对最终所获得的全部信息，不加分析、不加思考地全盘接受，也同样可能是危险的或有害的</li><li>人类拥有的普遍的认知偏差之一就是：把成功揽到自己身上，把失败归咎于别人或者坏运气</li><li>只有经过仔细甄别之后，真正的成功者的宝贵经验才是无价的</li></ul><h3 id="不要相信“运气”，更不要相信“机不可失，时不再来”"><a href="#不要相信“运气”，更不要相信“机不可失，时不再来”" class="headerlink" title="不要相信“运气”，更不要相信“机不可失，时不再来”"></a>不要相信“运气”，更不要相信“机不可失，时不再来”</h3><ul><li>运气确实是存在的，并且有好坏之分。概率是一样的，不一样的是你的欲望</li><li>相信运气其实是缺乏自制力的表现</li></ul><blockquote><p>弱者相信运气，强者只究因果 —— 爱默森（Ralph Waldo Emerson）</p></blockquote><blockquote><p>所谓的幸运就是当你准备好了的时候机会来了 —— 塞涅卡（罗马哲学家、悲剧作家、政治家）</p></blockquote><h3 id="打造人脉不如打造自己"><a href="#打造人脉不如打造自己" class="headerlink" title="打造人脉不如打造自己"></a>打造人脉不如打造自己</h3><ul><li>所有的人都喜欢并重视甚至偏爱一种交换，“<strong>公平交换</strong>”</li><li>承认自己能力有限，是心理健康的前提</li><li>往往只有优秀的人才拥有有效的人脉</li><li>整体上看，人脉当然很重要。不过针对某个个体来说，更重要的是他所拥有的资源。有些资源很难瞬间获得，有些资源却可以很容易从零开始，比如<strong>才华</strong>与<strong>学识</strong></li><li>生活的智慧就在于，集中精力改变那些能够改变的，而把那些不能改变的暂时忽略掉。<strong>专心打造自己，把自己打造成一个优秀的人，一个有用的人，一个独立的人，比什么都重要</strong>。打造自己，就等于打造人脉</li><li>专心做可以提升自己的事情；学习并拥有更多更好的技能；成为一个值得交往的人</li><li>学会独善其身，以不给他人制造麻烦为美德；用你的独立赢得尊重</li><li>除非有特殊原因，应该尽量回避那些连在物质生活上都不能独善其身的人；那些精神生活上都不能独善其身的，就更应该回避了 —— 尽管甄别起来比较困难</li><li>真正关心一个朋友的意思是说，你情愿在他身上花费甚至浪费更多的时间</li><li>记住，一个人的幸福程度，往往取决于他多大程度上可以脱离对外部世界的依附</li></ul><h3 id="关于“成功学”的最后一点啰嗦"><a href="#关于“成功学”的最后一点啰嗦" class="headerlink" title="关于“成功学”的最后一点啰嗦"></a>关于“成功学”的最后一点啰嗦</h3><ul><li>一辈子是很长的过程，而心智开启之后，“进化之路”又确实“路漫漫其修远”，值得我们为之“上下而求索”</li></ul><h2 id="更多思考"><a href="#更多思考" class="headerlink" title="更多思考"></a>更多思考</h2><h3 id="最节省时间的方法：学习"><a href="#最节省时间的方法：学习" class="headerlink" title="最节省时间的方法：学习"></a>最节省时间的方法：学习</h3><ul><li>很多人拒绝学习，本质上来看，就是在<strong>拒绝做人</strong> —— 因为几乎只有人类才有能力有机会“<strong>终生学习</strong>”</li><li>如果你曾经有过最终习得某种技能的经验，就知道在习得的那一瞬间，<strong>整个世界都会为之而变</strong>。或者换一个说法，因为你有能力做更多的事情了，你就不再存在于原本的世界里；因为你所习得的技能，你已经拥有另一个完全不同的世界</li><li>一旦拥有了一个起点，学习的欲望就好像是发了芽的<strong>种子</strong>，无论多大的石头都压不住它 —— 它会越来越茁壮，越来越坚强</li></ul><h3 id="被误解了的效率"><a href="#被误解了的效率" class="headerlink" title="被误解了的效率"></a>被误解了的效率</h3><ul><li>记住，你不可能百分之百地有效率，至少不可能总是百分之百地有效率</li><li>你必须清楚肯定会有意外事件发生，所以你要留些事件处理这些意外事件</li><li>你必须用适当的方法休息、放松，以便恢复良好的状态去做更多的事情</li></ul><h3 id="效率低下的根源：回避困难"><a href="#效率低下的根源：回避困难" class="headerlink" title="效率低下的根源：回避困难"></a>效率低下的根源：回避困难</h3><ul><li>他们的效率很差，根源在于，他们其实只做<strong>简单</strong>的事情，而<strong>回避</strong>那些有难度的工作</li></ul><h3 id="提高效率的最有效方法：克服拖拉"><a href="#提高效率的最有效方法：克服拖拉" class="headerlink" title="提高效率的最有效方法：克服拖拉"></a>提高效率的最有效方法：克服拖拉</h3><ul><li>做任何事情之前，花上一定的时间分析完成任务所需的种种技能</li><li>诚实面对自己，正视自己相对于这些技能上的熟练程度</li><li>如果自己在某些技能上有所欠缺，那么 a. 短期：求助于他人；b. 长期：求人不如求己 —— 开始学习</li><li>测算时间，把自己擅长的部分放到后面可能是优势策略</li><li>养成记录的习惯，以便自己随时监督自己</li><li>按部就班完成计划</li></ul><h3 id="把生活节奏调整得慢一点"><a href="#把生活节奏调整得慢一点" class="headerlink" title="把生活节奏调整得慢一点"></a>把生活节奏调整得慢一点</h3><ul><li>凡是值得做的事情，都值得慢慢做 —— 做很久很久</li><li>要想办法提前预知自己需要怎样的技能，然后确定那是一个自己可以通过练习真正熟练掌握的技能，而后制定长期计划，一点一点地执行该计划</li></ul><h3 id="做个不迟到的人"><a href="#做个不迟到的人" class="headerlink" title="做个不迟到的人"></a>做个不迟到的人</h3><h4 id="养成规律生活的习惯"><a href="#养成规律生活的习惯" class="headerlink" title="养成规律生活的习惯"></a>养成规律生活的习惯</h4><h4 id="每天检查自己的时间表至少三次"><a href="#每天检查自己的时间表至少三次" class="headerlink" title="每天检查自己的时间表至少三次"></a>每天检查自己的时间表至少三次</h4><h4 id="假定自己做的每件事情需要的时间比想象中更多一点"><a href="#假定自己做的每件事情需要的时间比想象中更多一点" class="headerlink" title="假定自己做的每件事情需要的时间比想象中更多一点"></a>假定自己做的每件事情需要的时间比想象中更多一点</h4><h4 id="假定你永远都会遇到交通堵塞"><a href="#假定你永远都会遇到交通堵塞" class="headerlink" title="假定你永远都会遇到交通堵塞"></a>假定你永远都会遇到交通堵塞</h4><ul><li>记住，意外总是发生绝对不是因为你的运气格外差，而往往只不过是因为你考虑得不够周全</li></ul><h4 id="假定其他人都会迟到"><a href="#假定其他人都会迟到" class="headerlink" title="假定其他人都会迟到"></a>假定其他人都会迟到</h4><h4 id="尽量不要因为别人迟到而责怪他们"><a href="#尽量不要因为别人迟到而责怪他们" class="headerlink" title="尽量不要因为别人迟到而责怪他们"></a>尽量不要因为别人迟到而责怪他们</h4><h3 id="关于开源节流的几点建议"><a href="#关于开源节流的几点建议" class="headerlink" title="关于开源节流的几点建议"></a>关于开源节流的几点建议</h3><ul><li>首先，不要盲目地试图减少睡眠时间</li><li>其次，尽量不要减少与家庭成员和亲属交流的时间</li><li>最后，最好不要放弃你的社交时间</li><li>你要学会不停地帮助身边人。你要想尽一切办法运用你自己的资源为值得帮助的人提供帮助。主动帮助的最基本方式就是共享</li></ul><h3 id="不要浪费时间去“证明自己”"><a href="#不要浪费时间去“证明自己”" class="headerlink" title="不要浪费时间去“证明自己”"></a>不要浪费时间去“证明自己”</h3><ul><li>所有的傻逼都是自证的</li><li>你比别人强一点，根本没用，真正有用的是你不仅比别人强一点，还要比别人强出很多很多才行</li></ul><h3 id="最浪费时间的句型：“要是……就好了！”"><a href="#最浪费时间的句型：“要是……就好了！”" class="headerlink" title="最浪费时间的句型：“要是……就好了！”"></a>最浪费时间的句型：“要是……就好了！”</h3><ul><li>过去的事情是无法更改的，现在的烦恼是无济于事的。但是，将来的尴尬也许是可以避免的 —— 如果现在的行动没有出错的话</li></ul><h3 id="自卑是最浪费时间的罪魁祸首之一"><a href="#自卑是最浪费时间的罪魁祸首之一" class="headerlink" title="自卑是最浪费时间的罪魁祸首之一"></a>自卑是最浪费时间的罪魁祸首之一</h3><ul><li>想做到不以物喜不以己悲的健康状态，要学会的第一件事就是：<strong>停止嘲弄他人</strong></li><li>另外一个比较技术一点的手段是：忘记自己的优点。准确地说，尽量<strong>漠视自己的优点</strong>就好了</li><li>还有一个相当不错的手段，把“优点”和“缺点”这两个词替换成“<strong>特点</strong>”</li><li>最后一个方法是：适当地放纵一下自己</li><li>承认自己是一个有缺点的人是让心智获得解放的重要前提。没有缺点的就不是人</li><li>自卑原本只不过是正常的感受，只不过是被定义成负面了而已</li></ul><h3 id="时间不一定就是金钱"><a href="#时间不一定就是金钱" class="headerlink" title="时间不一定就是金钱"></a>时间不一定就是金钱</h3><table class="table table-bordered table-hover">  <thead>    <tr>      <th style="text-align: right">年收入</th>      <th style="text-align: left">每秒钟的价值</th>    </tr>  </thead>  <tbody>    <tr>      <td style="text-align: right">100万元</td>      <td style="text-align: left">0.03170979元</td>    </tr>    <tr>      <td style="text-align: right">60万元</td>      <td style="text-align: left">0.01902587元</td>    </tr>    <tr>      <td style="text-align: right">20万元</td>      <td style="text-align: left">0.00634195元</td>    </tr>    <tr>      <td style="text-align: right">10万元</td>      <td style="text-align: left">0.00317097元</td>    </tr>    <tr>      <td style="text-align: right">8万元</td>      <td style="text-align: left">0.00253678元</td>    </tr>    <tr>      <td style="text-align: right">5万元</td>      <td style="text-align: left">0.00158549元</td>    </tr>    <tr>      <td style="text-align: right">3万元</td>      <td style="text-align: left">0.00095129元</td>    </tr>    <tr>      <td style="text-align: right">2万元</td>      <td style="text-align: left">0.00063419元</td>    </tr>  </tbody></table><ul><li>越是收入低的人越是不爱惜时间 —— 因为他的时间实在是没有什么价值</li><li>越是收入高的人越是吝惜自己的时间，因为他的每一秒都有着确定的价值，而他正忙着使他的每一秒钟变得更具价值</li></ul><blockquote><p>他有的，就再给他，让他多余；他没有的，就连同他所有的，一并夺走 —— 马太福音</p></blockquote><h3 id="被低估了的今天"><a href="#被低估了的今天" class="headerlink" title="被低估了的今天"></a>被低估了的今天</h3><ul><li>我们的大脑倾向于低估未来回报的价值，同时倾向于高估当前回报的价值。心理学家们把这种过分低估成为“Delaydiscounting”</li><li>人们普遍相信他们在明天会拥有比今天更多的金钱；人们普遍相信自己明天会有更多的时间。在这两种理论明显指出的曲解中，人们对时间的曲解程度远远高于对金钱的曲解程度</li></ul><h2 id="从此刻开始改变"><a href="#从此刻开始改变" class="headerlink" title="从此刻开始改变"></a>从此刻开始改变</h2><ul><li>大多数事情都需要提前准备，也都可以提前准备。认识到这一点本身就几乎是一切改变的起点</li></ul><h3 id="万事皆可提前准备"><a href="#万事皆可提前准备" class="headerlink" title="万事皆可提前准备"></a>万事皆可提前准备</h3><ul><li>“一般地，人们害怕当中演说甚于害怕死亡”。害怕死亡的理由自然不必说，人们害怕当中演说，却未必一定知道害怕的原因 —— 很简单，<strong>准备不足，所以害怕</strong></li></ul><h3 id="提前准备的好处"><a href="#提前准备的好处" class="headerlink" title="提前准备的好处"></a>提前准备的好处</h3><h4 id="所谓“灵感”"><a href="#所谓“灵感”" class="headerlink" title="所谓“灵感”"></a>所谓“灵感”</h4><ul><li>在鸡尾酒会中，所有的人都在以差不多同样大小的声音三五成群地相互谈话。你正在与某个或者某些人交谈，在你们正在谈话的相当长一段时间里，除了与你交谈的人们所说的话以及你自己对那些人说的话之外，其他的声音事实上都被你忽略，等同于并不存在。但是，如果另外一群人的谈话中突然出现了你的名字，甚至可能在他们事实上离你并不是很近的情况下，你都会瞬间捕捉到那个声音，就好像它突然冲进了你的耳朵一样。而奇怪的是，之前的相当长一段时间里，那些人一直在以同样大小的音量，在与你现在同样的距离之外进行交谈，但是你却完全不知道他们在说些什么，那个声音在此之前的部分全部被过滤掉了。<strong>这就是所谓的“鸡尾酒会效应”（Cock-tail party effect）</strong></li><li>我们大脑中的灰质中储存的各种信息只有很少一部分（很难超过 12%）是有序储存的，这部分被我们称作是“有意识的”。而更多的信息，或者信息碎片，是非有序储存的，甚至很难有意识地直接调出，这些往往就是被我们成为“无意识”或者“潜意识”的部分。<strong>随着信息输入越来越多，大脑就需要越来越多的灰质细胞。而颅腔的大小是有限的，灰质细胞的增加，最终会导致灰质密度越来越高。于是，灰质细胞之间就越有可能由神经元连接起来，产生我们所说的“融会贯通”的现象</strong></li><li>不要无谓地相信什么“突然闪现的灵感”的存在。灵感这东西就算存在，也不会是平白无故出现的，肯定是有来历的，只不过是我们经常说的“量变到质变”的那一瞬间突然绽放的铁树之花</li></ul><h4 id="所谓“能力”"><a href="#所谓“能力”" class="headerlink" title="所谓“能力”"></a>所谓“能力”</h4><ul><li>一个人在某方面的能力究竟有多大，几乎直接取决于此人能再哪方面提前多久进行过准备</li><li>准备不充分的人面临的困境，就好像是个手铐，越挣扎就被箍得越紧。面对最后期限，无法不产生无比的焦虑。而这些焦虑产生的唯一作用就是分散注意力，使得产能低下到极限；反过来，产能的低下和时间的紧迫所产生的唯一作用就是更加焦虑……恶性的死循环</li><li>尽管心智成熟的我们往往会避免基于比较的快乐，但没有任何理由拒绝基于比较的相对成功。所以，突破刚刚提到的“恶性的死循环”的最基本方法就是，比别人更早一些开始准备。越早一点，你与时间这个朋友之间就会变得越亲密；与你更加亲密的这个朋友会让你的每一天都多那么一点点从容；而一点点从容，会让你爱上时间这个伙伴</li></ul><h3 id="成功的核心素质：耐心"><a href="#成功的核心素质：耐心" class="headerlink" title="成功的核心素质：耐心"></a>成功的核心素质：耐心</h3><ul><li>所谓耐心，就是甘于把时间投入到简单、枯燥但是最终会意义非凡的重复当中去</li><li>任何与我们共享了某段时间的人，不论我们喜欢也好讨厌也罢，都已经成了我们生命中的一部分，对他们还是多点耐心吧</li></ul><blockquote><p>每次比赛之前，我都要乘车把比赛的线路仔细看一遍，并把沿途比较醒目的标志画下来，比如第一个标志是银行，第二个标志是一棵大树，第三个标志是一座红房子，这样一直画到赛程的终点。比赛开始后，我就以百米冲刺的速度奋力向第一个目标冲去，等到达第一个目标，我又以同样的速度向第二个目标冲去。四十几公里的赛程，就被我分解成这么几个小目标轻松地跑完了。起初，我并不懂这样的道理，我把我的目标定在四十几公里处的终点线上，结果我跑到十几公里时就疲惫不堪了，我被前面那段遥远的路程给吓倒了 —— 山本田一，1984 年和 1986 年马拉松世界冠军</p></blockquote><ul><li>了解本身也是需要耐心的，没有耐心的人是没耐心深入了解任何事情的，于是，最终他们对任何事情都没有耐心</li></ul><h3 id="越早醒悟越好"><a href="#越早醒悟越好" class="headerlink" title="越早醒悟越好"></a>越早醒悟越好</h3><ul><li>从每个人的感受出发，时间并不是匀速的，而是加速流逝的</li><li>心理学家可以用特别简单、准确而又非常精巧的方法清楚地解释为什么随着年龄的增长每个人都会觉得时间过得越来越快。对一个 5 岁的孩子来讲，未来的一年相当于他已经度过的人生的 20%；而对一个 50 岁的人来讲，未来的一年只相当于他已经度过的人生的 1/50，即 2%。所以，从感觉上来看，随着年龄的增加，时间好像越来越快</li><li>教育孩子的方法特别简单。在某一天，做一件让他印象务必深刻的事情。可以是讲一个故事，也可以是一次郊游，更可以是买一件让他惊喜的礼物 —— 反正一定要让他印象极度深刻。而后，你自己在日记里记录清楚这件事情，当然包括时间、地点与事件，而后千万要妥善保存。大约两三年之后，在他有一天开始觉得并抱怨时间太慢的时候，把那个记录翻出来，给他看，让他体会。这么做的要点只有一个 —— 耐心。首先，起点最好应该在大约七岁前后；其次，重点应该起码两三年之后。而后再过三五年，再提醒一次。这样的体验，不仅将使孩子永生难忘，还会影响他此后一生对时间的精确认识。早晚有一天，你的孩子将因此对你无比感激，充满崇敬。因为他终将明白，这种宝贵的“相对优势”根本就不是可以用金钱衡量的 —— 只需大致看看我们身边有多少人对此茫然无知你就很容易想象这个结果了</li><li>过去已经过去，无法更改。未来却可以更改 —— 通过改变我们今天的起始条件。当我们真正运用心智的力量认真而又正确地反思我们生活中遇到的所有尴尬时，最终会发现其中的大多数肯定是因为过去曾经做错过什么，或有意，或无意。那么，为了将来的正确，我们今天就要做到尽量不出错。今天任何一个小错误，都有可能在将来被无穷地放大。这样的认知，几乎会改变我们的一切。生活就是选择，而所谓的选择，只不过是一个人所拥有的观念对之衡量后的结果。一个人所拥有的观念，说穿了，就是心智力量的最终体现</li></ul>]]></content>
      
      
      <categories>
          
          <category> Book </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一步一步将 d3.js Calendar View 转变成 GitHub Contributions</title>
      <link href="2015/11/26/transform-d3-calendar-view-to-github-contributions-step-by-step/"/>
      <url>2015/11/26/transform-d3-calendar-view-to-github-contributions-step-by-step/</url>
      
        <content type="html"><![CDATA[<p>GitHub Contributions 日历热图表述力强，容易上瘾，并且引发了多种玩法：涂满或涂成名字、万圣节颜色……，让我们使用 d3.js 提供的 Calendar View 示例，一步一步将其修改成 GitHub 的样式，Let’s go！</p><p><img src="/contents/calendar-view/all.gif" alt="All"></p><p>先将 <a href="http://d3js.org/" target="_blank" rel="noopener">d3.js</a> 提供的 <a href="http://bl.ocks.org/mbostock/4063318" target="_blank" rel="noopener">Calendar View</a> 做一个 <a href="/contents/calendar-view/snapshot.zip">快照</a>，以免示例代码更新对本文中的修改造成影响。</p><p>修改前的文件为：</p><ul><li><a href="/contents/calendar-view/before.html">before.html</a></li><li><a href="/contents/calendar-view/dji.csv">dji.csv</a></li></ul><p>修改后文件为：</p><ul><li><a href="/contents/calendar-view/after.html">after.html</a></li></ul><p>最终效果见上面动态图。</p><h2 id="只留一年"><a href="#只留一年" class="headerlink" title="只留一年"></a>只留一年</h2><p>暂时先只保留 <code>2008</code> 年的日历</p><p><img src="/contents/calendar-view/2.png" alt="One year"></p><pre><code class="diff">@@ -47,7 +47,7 @@ var color = d3.scale.quantize()     .range(d3.range(11).map(function(d) { return &quot;q&quot; + d + &quot;-11&quot;; })); var svg = d3.select(&quot;body&quot;).selectAll(&quot;svg&quot;)-    .data(d3.range(1990, 2011))+    .data(d3.range(2008,2009))   .enter().append(&quot;svg&quot;)     .attr(&quot;width&quot;, width)     .attr(&quot;height&quot;, height)</code></pre><h2 id="修改样式"><a href="#修改样式" class="headerlink" title="修改样式"></a>修改样式</h2><p>按照 <code>GitHub Contributions</code> 对样式进行调整，包括去掉月份边框，调整单元格大小、间距及颜色</p><p><img src="/contents/calendar-view/3.png" alt="Change styles"></p><pre><code class="diff">@@ -8,27 +8,20 @@ body { } .day {-  fill: #fff;-  stroke: #ccc;+  width: 11px;+  height: 11px;+  fill: rgb(238, 238, 238); }-.month {-  fill: none;-  stroke: #000;-  stroke-width: 2px;+.day:hover {+  stroke: #555;+  stroke-width: 1px; }-.RdYlGn .q0-11{fill:rgb(165,0,38)}-.RdYlGn .q1-11{fill:rgb(215,48,39)}-.RdYlGn .q2-11{fill:rgb(244,109,67)}-.RdYlGn .q3-11{fill:rgb(253,174,97)}-.RdYlGn .q4-11{fill:rgb(254,224,139)}-.RdYlGn .q5-11{fill:rgb(255,255,191)}-.RdYlGn .q6-11{fill:rgb(217,239,139)}-.RdYlGn .q7-11{fill:rgb(166,217,106)}-.RdYlGn .q8-11{fill:rgb(102,189,99)}-.RdYlGn .q9-11{fill:rgb(26,152,80)}-.RdYlGn .q10-11{fill:rgb(0,104,55)}+.cv .lv1 {fill: #d6e685;}+.cv .lv2 {fill: #8cc665;}+.cv .lv3 {fill: #44a340;}+.cv .lv4 {fill: #1e6823;} &lt;/style&gt; &lt;body&gt;@@ -37,21 +30,21 @@ body { var width = 960,     height = 136,-    cellSize = 17; // cell size+    cellSize = 13; // cell size var percent = d3.format(&quot;.1%&quot;),     format = d3.time.format(&quot;%Y-%m-%d&quot;); var color = d3.scale.quantize()     .domain([-.05, .05])-    .range(d3.range(11).map(function(d) { return &quot;q&quot; + d + &quot;-11&quot;; }));+    .range(d3.range(1,5).map(function(d) { return &quot;lv&quot; + d; })); var svg = d3.select(&quot;body&quot;).selectAll(&quot;svg&quot;)     .data(d3.range(2008,2009))   .enter().append(&quot;svg&quot;)     .attr(&quot;width&quot;, width)     .attr(&quot;height&quot;, height)-    .attr(&quot;class&quot;, &quot;RdYlGn&quot;)+    .attr(&quot;class&quot;, &quot;cv&quot;)   .append(&quot;g&quot;)     .attr(&quot;transform&quot;, &quot;translate(&quot; + ((width - cellSize * 53) / 2) + &quot;,&quot; + (height - cellSize * 7 - 1) + &quot;)&quot;);@@ -73,12 +66,6 @@ var rect = svg.selectAll(&quot;.day&quot;) rect.append(&quot;title&quot;)     .text(function(d) { return d; });-svg.selectAll(&quot;.month&quot;)-    .data(function(d) { return d3.time.months(new Date(d, 0, 1), new Date(d + 1, 0, 1)); })-  .enter().append(&quot;path&quot;)-    .attr(&quot;class&quot;, &quot;month&quot;)-    .attr(&quot;d&quot;, monthPath);- d3.csv(&quot;dji.csv&quot;, function(error, csv) {   if (error) throw error;@@ -93,17 +80,6 @@ d3.csv(&quot;dji.csv&quot;, function(error, csv) {       .text(function(d) { return d + &quot;: &quot; + percent(data[d]); }); });-function monthPath(t0) {-  var t1 = new Date(t0.getFullYear(), t0.getMonth() + 1, 0),-      d0 = t0.getDay(), w0 = d3.time.weekOfYear(t0),-      d1 = t1.getDay(), w1 = d3.time.weekOfYear(t1);-  return &quot;M&quot; + (w0 + 1) * cellSize + &quot;,&quot; + d0 * cellSize-      + &quot;H&quot; + w0 * cellSize + &quot;V&quot; + 7 * cellSize-      + &quot;H&quot; + w1 * cellSize + &quot;V&quot; + (d1 + 1) * cellSize-      + &quot;H&quot; + (w1 + 1) * cellSize + &quot;V&quot; + 0-      + &quot;H&quot; + (w0 + 1) * cellSize + &quot;Z&quot;;-}- d3.select(self.frameElement).style(&quot;height&quot;, &quot;2910px&quot;); &lt;/script&gt;</code></pre><h2 id="过去一年"><a href="#过去一年" class="headerlink" title="过去一年"></a>过去一年</h2><p>将 Calendar View 显示的一整年调整为过去一年</p><p><img src="/contents/calendar-view/4.png" alt="Last whole year"></p><pre><code class="diff">@@ -39,27 +39,36 @@ var color = d3.scale.quantize()     .domain([-.05, .05])     .range(d3.range(1,5).map(function(d) { return &quot;lv&quot; + d; }));-var svg = d3.select(&quot;body&quot;).selectAll(&quot;svg&quot;)-    .data(d3.range(2008,2009))-  .enter().append(&quot;svg&quot;)+var svg = d3.select(&quot;body&quot;).append(&quot;svg&quot;)     .attr(&quot;width&quot;, width)     .attr(&quot;height&quot;, height)     .attr(&quot;class&quot;, &quot;cv&quot;)   .append(&quot;g&quot;)     .attr(&quot;transform&quot;, &quot;translate(&quot; + ((width - cellSize * 53) / 2) + &quot;,&quot; + (height - cellSize * 7 - 1) + &quot;)&quot;);-svg.append(&quot;text&quot;)-    .attr(&quot;transform&quot;, &quot;translate(-6,&quot; + cellSize * 3.5 + &quot;)rotate(-90)&quot;)-    .style(&quot;text-anchor&quot;, &quot;middle&quot;)-    .text(function(d) { return d; });+var today = new Date();+var lastYear = new Date(today.getTime() - 365 * 24 * 60 * 60 * 1000);+var shiftWeeks = 53 - d3.time.weekOfYear(lastYear);++var shiftWeek = function(d) {+  var year = d.getFullYear();+  var thisYear = today.getFullYear();+  var weekOfYear = d3.time.weekOfYear(d);+  if (year &lt; thisYear) {+    weekOfYear = weekOfYear - 53 + shiftWeeks;+  } else {+    weekOfYear += shiftWeeks - 1;+  }+  return weekOfYear;+}; var rect = svg.selectAll(&quot;.day&quot;)-    .data(function(d) { return d3.time.days(new Date(d, 0, 1), new Date(d + 1, 0, 1)); })+    .data(d3.time.days(lastYear, today))   .enter().append(&quot;rect&quot;)     .attr(&quot;class&quot;, &quot;day&quot;)     .attr(&quot;width&quot;, cellSize)     .attr(&quot;height&quot;, cellSize)-    .attr(&quot;x&quot;, function(d) { return d3.time.weekOfYear(d) * cellSize; })+    .attr(&quot;x&quot;, function(d) { return shiftWeek(d) * cellSize; })     .attr(&quot;y&quot;, function(d) { return d.getDay() * cellSize; })     .datum(format);</code></pre><h2 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h2><p>添加周及月份标签</p><p><img src="/contents/calendar-view/5.png" alt="Add labels"></p><pre><code class="diff">@@ -46,6 +46,18 @@ var svg = d3.select(&quot;body&quot;).append(&quot;svg&quot;)   .append(&quot;g&quot;)     .attr(&quot;transform&quot;, &quot;translate(&quot; + ((width - cellSize * 53) / 2) + &quot;,&quot; + (height - cellSize * 7 - 1) + &quot;)&quot;);+svg.append(&#39;text&#39;)+  .attr(&#39;transform&#39;, &#39;translate(-14,&#39; + cellSize*1.8 + &#39;)&#39;)+  .text(&#39;一&#39;);++svg.append(&#39;text&#39;)+  .attr(&#39;transform&#39;, &#39;translate(-14,&#39; + cellSize*3.8 + &#39;)&#39;)+  .text(&#39;三&#39;);++svg.append(&#39;text&#39;)+  .attr(&#39;transform&#39;, &#39;translate(-14,&#39; + cellSize*5.8 + &#39;)&#39;)+  .text(&#39;五&#39;);+ var today = new Date(); var lastYear = new Date(today.getTime() - 365 * 24 * 60 * 60 * 1000); var shiftWeeks = 53 - d3.time.weekOfYear(lastYear);@@ -62,6 +74,18 @@ var shiftWeek = function(d) {   return weekOfYear; };+var startYear = lastYear.getFullYear();+var startMonth = lastYear.getDate() === 1 ? lastYear.getMonth() : lastYear.getMonth() + 1;+for (var i = 0; i &lt; 12; i ++) {+  var s = new Date(startYear, startMonth + i, 1);+  var w = shiftWeek(s) + (s.getDay() &gt; 0 ? 1 : 0);+  if (w &gt; 52) {+    break;+  }+  var m = s.getMonth() + 1;+  var l = m &gt; 9 ? m : &#39;0&#39; + m;+  svg.append(&#39;text&#39;)+    .attr(&#39;transform&#39;, &#39;translate(&#39; + cellSize * w + &#39;, -5)&#39;)+    .text(l);+}+ var rect = svg.selectAll(&quot;.day&quot;)     .data(d3.time.days(lastYear, today))   .enter().append(&quot;rect&quot;)</code></pre><h2 id="修改数据源"><a href="#修改数据源" class="headerlink" title="修改数据源"></a>修改数据源</h2><p>将数据来源由 <code>csv</code> 调整为 <code>object</code></p><p><img src="/contents/calendar-view/6.png" alt="Change data source"></p><pre><code class="diff">@@ -99,19 +99,17 @@ var rect = svg.selectAll(&quot;.day&quot;) rect.append(&quot;title&quot;)     .text(function(d) { return d; });-d3.csv(&quot;dji.csv&quot;, function(error, csv) {-  if (error) throw error;--  var data = d3.nest()-    .key(function(d) { return d.Date; })-    .rollup(function(d) { return (d[0].Close - d[0].Open) / d[0].Open; })-    .map(csv);--  rect.filter(function(d) { return d in data; })-      .attr(&quot;class&quot;, function(d) { return &quot;day &quot; + color(data[d]); })-    .select(&quot;title&quot;)-      .text(function(d) { return d + &quot;: &quot; + percent(data[d]); });-});++var data = {+  &#39;2015-11-24&#39;: 0,+  &#39;2015-11-25&#39;: -0.5,+  &#39;2015-11-26&#39;: 0.5+};++rect.filter(function(d) { return d in data; })+    .attr(&quot;class&quot;, function(d) { return &quot;day &quot; + color(data[d]); })+  .select(&quot;title&quot;)+    .text(function(d) { return d + &quot;: &quot; + percent(data[d]); }); d3.select(self.frameElement).style(&quot;height&quot;, &quot;2910px&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Visualization </tag>
            
            <tag> D3 </tag>
            
            <tag> GitHub </tag>
            
            <tag> Calendar </tag>
            
            <tag> Contributions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker-machine 设置代理</title>
      <link href="2015/11/12/docker-machine-behind-proxy/"/>
      <url>2015/11/12/docker-machine-behind-proxy/</url>
      
        <content type="html"><![CDATA[<p>随着 Docker 1.8 的发布，docker-machine 将 boot2docker 封装了起来。docker-machine 在需要通过代理访问网络时需要特殊的配置，配置方式如下：</p><p><code>docker-machine</code> 实际是运行在 <code>OS X</code> 上的 <code>VirtualBox</code> 虚拟机内，将之前的 <code>boot2docker</code> 进行了封装，配置代理的方式与之前在 <code>boot2docker</code> 中的设置方式不同。具体设置步骤为：</p><pre><code class="bash"># ssh 到 default 虚拟机$ docker-machine ssh default# 连接后提示符类似这样：# docker@default:~$# 获得 root 权限$ sudo -s# 此时提示符类似这样：# root@default:~$# 设置代理$ echo &quot;export HTTP_PROXY=http://[uid]:[pw]@corporate.proxy.com:[port]&quot; &gt;&gt; /var/lib/boot2docker/profile$ echo &quot;export HTTPS_PROXY=http://[uid]:[pw]@corporate.proxy.com:[port]&quot; &gt;&gt; /var/lib/boot2docker/profile# 验证配置$ cat /var/lib/boot2docker/profile# 退出 root 及 ssh$ exit$ exit# 重启 default$ docker-machine restart default# 此时应该可以通过代理获得镜像了$ docker pull hello-world</code></pre><blockquote><p>几乎所有的 <code>boot2docker</code> 内的文件都会在重启后被重置，但 <code>/var/lib/boot2docker/profile</code> 是个例外，所以上面的配置只需设置一次即可；但若使用了 <code>DaoCloud</code> 的加速器，可能会将上面设置的代理信息重置，则需重新配置一遍</p></blockquote><p><strong>参考资料</strong></p><ul><li><a href="http://mflo.io/2015/08/13/docker-machine-behind-proxy/" target="_blank" rel="noopener">How to Run docker-machine from Behind a Corporate Proxy</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSX </tag>
            
            <tag> Docker </tag>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 AppleScript 切换 OSX 鼠标/触控板 滚动方向</title>
      <link href="2015/10/28/toggle-scrolling-direction-with-applescript/"/>
      <url>2015/10/28/toggle-scrolling-direction-with-applescript/</url>
      
        <content type="html"><![CDATA[<p>OSX 的鼠标和触控板共享相同的滚动方向设置。假设这样一个场景：在工作时给 MacBook 接上鼠标，休闲时直接使用触控板，通过系统偏好设置界面来调整滚动方向在切换频繁时很麻烦且低效，有没有更便捷的方式？</p><p>使用 <a href="https://en.wikipedia.org/wiki/AppleScript" target="_blank" rel="noopener">AppleScript</a> 脚本可以通过命令行方式来切换滚动方向。</p><p>以 <code>OS X EI Capitan</code> 为例，其他系统版本脚本可能会有差异</p><pre><code class="applescript">tell application &quot;System Preferences&quot;    set current pane to pane &quot;com.apple.preference.mouse&quot;end telltell application &quot;System Events&quot;    tell process &quot;System Preferences&quot;        click checkbox 1 of window 1    end tellend tellquit application &quot;System Preferences&quot;</code></pre><p>将上面脚本代码存储至文本文件，如：<code>toggle-scrolling-direction.applescript</code></p><p>在终端中可使用 <code>osascript toggle-scrolling-direction.applescript</code> 执行</p><blockquote><p>注意：执行过程中会弹出是否允许终端控制电脑的安全确认，如不允许脚本将无法执行。可在 <code>系统偏好设置</code> - <code>安全性与隐私</code> - <code>隐私</code> - <code>辅助功能</code> 中修改对应用的控制</p></blockquote><p>可以为 <code>osascript toggle-scrolling-direction.applescript</code> 指令定义一个 <code>alias</code>，这样切换的时候就更方便了：）</p><p><strong>参考资料</strong></p><ul><li><a href="http://apple.stackexchange.com/questions/153243/changing-trackpad-scroll-direction-with-applescript-in-yosemite" target="_blank" rel="noopener">Changing trackpad scroll direction with AppleScript in Yosemite</a></li><li><a href="http://apple.stackexchange.com/questions/60877/toggle-natural-scrolling-from-command-line-with-reload" target="_blank" rel="noopener">Toggle Natural scrolling from command line with reload</a></li><li><a href="https://github.com/epochblue/annoy-a-tron/pull/9/files" target="_blank" rel="noopener">Add applescript to reverse the scroll direction</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> script </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSX </tag>
            
            <tag> AppleScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Spring 项目中配置多个 property-placeholder</title>
      <link href="2015/10/22/set-multi-property-placeholders-in-spring/"/>
      <url>2015/10/22/set-multi-property-placeholders-in-spring/</url>
      
        <content type="html"><![CDATA[<p>使用 context:property-placeholder 的默认配置，在 Spring 项目中设置多处时会遇到其中某些配置的占位符不能正确替换的情况，如何解决？</p><p>提供两个方案：</p><ol><li><p>只设置一处 <code>context:property-placeholder</code></p><pre><code class="xml"> &lt;context:property-placeholder location=&quot;classpath*:path/to/*.properties&quot; /&gt;</code></pre><p> 假设你的 <code>profile</code> 是通过 <code>.properties</code> 文件设置差异的，用这种方法会将所有 <code>profile</code> 的配置都加载并覆盖只保留一份，丧失了设置 <code>profile</code> 的功能。</p></li><li><p>设置 <code>ignore-unresolvable</code> 为 <code>true</code></p><pre><code class="xml"> &lt;context:property-placeholder ignore-unresolvable=&quot;true&quot; location=&quot;classpath*:path/to/module.properties&quot;/&gt;</code></pre><p> 未能正确替换占位符的原因是 bean 在配置文件加载之前初始化了。<code>ignore-unresolvable</code> 属性正是用来解决这个问题的，当其设置为 <code>true</code>（默认值为 <code>false</code>）时，遇到不能处理的占位符会被忽略，交由其他配置来处理。需要在可能优先加载的配置中设置该属性，或在所有配置中都设置上。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> placeholder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试跟进 tomcat 源码</title>
      <link href="2015/10/14/how-to-debug-into-tomcat-sources/"/>
      <url>2015/10/14/how-to-debug-into-tomcat-sources/</url>
      
        <content type="html"><![CDATA[<p>调试 web 应用时，有时需要跟进 tomcat 的源码。下载 tomcat 源码并编译运行是一种方式，不过太麻烦，有没有简单点的办法呢？</p><p>给项目加上 tomcat 的 jar 包作为运行时依赖，并附加源码，就可以在调试的时候跟进 tomcat 的源码了。</p><p>以 <a href="http://gradle.org/" target="_blank" rel="noopener">Gradle</a> 和 <a href="http://tomcat.apache.org/download-70.cgi" target="_blank" rel="noopener">tomcat 7.0.63</a> 为例，只需在 <code>build.gradle</code> 的 <code>dependencies</code> 中加入如下代码即可：</p><pre><code class="gradle">depencencies {    def tomcatVer = &#39;7.0.63&#39;    runtime &quot;org.apache.tomcat.embed:tomcat-embed-core:${tomcatVer}&quot;,            &quot;org.apache.tomcat.embed:tomcat-embed-logging-juli:${tomcatVer}&quot;,            &quot;org.apache.tomcat.embed:tomcat-embed-jasper:${tomcatVer}&quot;}</code></pre><blockquote><p>如无 <code>gradle</code> 环境，可下载 <a href="/archives/gradle-wrapper/gradle-wrapper.zip">gradle-wrapper</a>，将解压出的 <code>gradle/</code>、<code>gradlew</code> 和 <code>gradlew.bat</code> 放入项目根路径，即可使用 <code>gradlew</code> 命令。gradle wrapper 会在第一次执行时自动下载在 <code>gradle/wrapper/gradle-wrapper.properties</code> 中设置的 gradle 版本</p></blockquote><h2 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h2><p>使用 <code>eclipse</code> 调试时，在 <code>build.gradle</code> 中加入</p><pre><code class="gradle">apply plugin: &#39;java&#39;apply plugin: &#39;war&#39;apply plugin: &#39;eclipse-wtp&#39;</code></pre><p>使用</p><pre><code class="bash">$ ./gradlew eclipse</code></pre><blockquote><p>注：<code>windows</code> 环境下使用 <code>gradlew eclipse</code> 命令</p></blockquote><p>生成 eclipse 所需文件后，即可将项目导入 eclipse 环境中。将 web 应用发布至 tomcat 后，加断点调试时会发现虽然能跟进 tomcat 的 class 里，确仍然没有源码。不过此时会有附加源码的按钮，选择 gradle 下载回的源码 jar 包就可以了</p><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>使用 IDEA 则比较简单，在 <code>build.gradle</code> 中加入</p><pre><code class="gradle">apply plugin: &#39;java&#39;apply plugin: &#39;war&#39;apply plugin: &#39;idea&#39;</code></pre><p>使用</p><pre><code class="bash">$ ./gradlew idea</code></pre><p>生成 IDEA 所需文件后，导入 IDEA 并发布至 tomcat 即可在调试时跟进 tomcat 的源码</p><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><p><a href="/contents/debug-into-tomcat/debug-into-tomcat.zip">下载 Demo 项目</a></p><p>包含文件：</p><pre><code>build.gradlesrc/main/java/io/github/alphahinex/DemoServlet.javasrc/main/webapp/WEB-INF/web.xml</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> Gradle </tag>
            
            <tag> IDEA </tag>
            
            <tag> Eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB GridFS 读写性能提升关键点</title>
      <link href="2014/10/27/key-of-read-and-write-speed-for-gridfs/"/>
      <url>2014/10/27/key-of-read-and-write-speed-for-gridfs/</url>
      
        <content type="html"><![CDATA[<p>提升 GridFS 读写性能的关键，就在于分散对 GridFS 的读写请求至集群内的所有分片上，即不能使用 <code>{files_id:1}</code> 来分片。这与官方文档内容完全相悖的矛盾如何能调和呢？</p><p>MongoDB(v2.6 current) 官方文档中关于 <a href="http://docs.mongodb.org/manual/tutorial/shard-gridfs-data/" target="_blank" rel="noopener">Shard GridFS Data Store</a> 有如下说明：</p><blockquote><p><strong>IMPORTANT</strong></p><p>{ files_id : 1 , n : 1 } and {  files_id : 1 } are the <strong>only</strong> supported shard keys for the chunks collection of a GridFS store.</p></blockquote><p>即 GridFS 的 chunks collection 只支持 <code>{files_id:1, n:1}</code> 和 <code>{files_id:1}</code> 作为片键。而 <code>files_id:1</code> 是按照 files collection 的 <code>_id</code> 升序分片。这样的话无论 MongoDB 集群如何部署以及如何分片，GridFS 的读写压力还是会集中在一个分片上。</p><p><strong>所以提升 GridFS 读写性能的关键，就在于分散对 GridFS 的读写请求至集群内的所有分片上，即不能使用 <code>{files_id:1}</code> 来分片。</strong></p><p>这与官方文档内容完全相悖的矛盾如何能调和呢？</p><p>经过测试发现，虽然 MongoDB 提供的操作 GridFS 的工具 <code>mongofiles</code> 和 <code>python driver</code> 都如文档所述，只支持按照 <code>files_id</code> 升序分片，但 <strong><code>java driver</code> 却没有这个限制，可以任意设置片键</strong>。</p><p>在测试环境中（千兆网络），将 chunks collection 的片键设置为 <code>{files_id: &#39;hashed&#39;}</code>，集群中设置 6 个分片，写入数据均匀分布在了所有分片上。<strong>与使用 <code>files_id</code> 升序片键相比，读写性能可提升 2~3 倍，100 并发下读写 1mb 大小文件，写速度可达到 <code>90.75mb/s</code>，读速度可达到 <code>110.62mb/s</code></strong>。</p>]]></content>
      
      
      <categories>
          
          <category> NOSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> GridFS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
